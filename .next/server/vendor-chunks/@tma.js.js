"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tma.js";
exports.ids = ["vendor-chunks/@tma.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tma.js/sdk-react/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@tma.js/sdk-react/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BackButton: () => (/* binding */ Ne),\n/* harmony export */   BasicNavigator: () => (/* binding */ As),\n/* harmony export */   BiometryManager: () => (/* binding */ je),\n/* harmony export */   BrowserNavigator: () => (/* binding */ se),\n/* harmony export */   ClosingBehavior: () => (/* binding */ Je),\n/* harmony export */   CloudStorage: () => (/* binding */ Xe),\n/* harmony export */   ERR_INVALID_PATH_BASE: () => (/* binding */ Ee),\n/* harmony export */   ERR_INVOKE_CUSTOM_METHOD_RESPONSE: () => (/* binding */ fe),\n/* harmony export */   ERR_METHOD_PARAMETER_UNSUPPORTED: () => (/* binding */ we),\n/* harmony export */   ERR_METHOD_UNSUPPORTED: () => (/* binding */ _e),\n/* harmony export */   ERR_NAVIGATION_HISTORY_EMPTY: () => (/* binding */ ve),\n/* harmony export */   ERR_NAVIGATION_INDEX_INVALID: () => (/* binding */ ye),\n/* harmony export */   ERR_NAVIGATION_ITEM_INVALID: () => (/* binding */ dn),\n/* harmony export */   ERR_PARSE: () => (/* binding */ St),\n/* harmony export */   ERR_SSR_INIT: () => (/* binding */ _n),\n/* harmony export */   ERR_TIMED_OUT: () => (/* binding */ me),\n/* harmony export */   ERR_UNEXPECTED_TYPE: () => (/* binding */ be),\n/* harmony export */   ERR_UNKNOWN_ENV: () => (/* binding */ ge),\n/* harmony export */   EventEmitter: () => (/* binding */ D),\n/* harmony export */   HapticFeedback: () => (/* binding */ es),\n/* harmony export */   InitData: () => (/* binding */ ns),\n/* harmony export */   Invoice: () => (/* binding */ is),\n/* harmony export */   MainButton: () => (/* binding */ as),\n/* harmony export */   MiniApp: () => (/* binding */ us),\n/* harmony export */   Popup: () => (/* binding */ _s),\n/* harmony export */   QRScanner: () => (/* binding */ gs),\n/* harmony export */   SDKError: () => (/* binding */ W),\n/* harmony export */   SDKProvider: () => (/* binding */ rr),\n/* harmony export */   SettingsButton: () => (/* binding */ ms),\n/* harmony export */   ThemeParams: () => (/* binding */ vs),\n/* harmony export */   Utils: () => (/* binding */ Es),\n/* harmony export */   Viewport: () => (/* binding */ Rs),\n/* harmony export */   array: () => (/* binding */ Ze),\n/* harmony export */   bindMiniAppCSSVars: () => (/* binding */ bn),\n/* harmony export */   bindThemeParamsCSSVars: () => (/* binding */ vn),\n/* harmony export */   bindViewportCSSVars: () => (/* binding */ yn),\n/* harmony export */   boolean: () => (/* binding */ E),\n/* harmony export */   captureSameReq: () => (/* binding */ Dt),\n/* harmony export */   classNames: () => (/* binding */ st),\n/* harmony export */   compareVersions: () => (/* binding */ Ie),\n/* harmony export */   createBrowserNavigatorFromLocation: () => (/* binding */ ks),\n/* harmony export */   createPostEvent: () => (/* binding */ qe),\n/* harmony export */   createSafeURL: () => (/* binding */ U),\n/* harmony export */   date: () => (/* binding */ $t),\n/* harmony export */   getHash: () => (/* binding */ xn),\n/* harmony export */   getPathname: () => (/* binding */ ee),\n/* harmony export */   initBackButton: () => (/* binding */ Ge),\n/* harmony export */   initBiometryManager: () => (/* binding */ Ke),\n/* harmony export */   initClosingBehavior: () => (/* binding */ Fe),\n/* harmony export */   initCloudStorage: () => (/* binding */ ts),\n/* harmony export */   initHapticFeedback: () => (/* binding */ ss),\n/* harmony export */   initInitData: () => (/* binding */ rs),\n/* harmony export */   initInvoice: () => (/* binding */ os),\n/* harmony export */   initMainButton: () => (/* binding */ cs),\n/* harmony export */   initMiniApp: () => (/* binding */ ls),\n/* harmony export */   initNavigator: () => (/* binding */ Cn),\n/* harmony export */   initPopup: () => (/* binding */ ws),\n/* harmony export */   initQRScanner: () => (/* binding */ fs),\n/* harmony export */   initSettingsButton: () => (/* binding */ bs),\n/* harmony export */   initThemeParams: () => (/* binding */ ys),\n/* harmony export */   initUtils: () => (/* binding */ Ps),\n/* harmony export */   initViewport: () => (/* binding */ xs),\n/* harmony export */   initWeb: () => (/* binding */ Cs),\n/* harmony export */   invokeCustomMethod: () => (/* binding */ O),\n/* harmony export */   isColorDark: () => (/* binding */ Vt),\n/* harmony export */   isIframe: () => (/* binding */ ht),\n/* harmony export */   isPageReload: () => (/* binding */ Qt),\n/* harmony export */   isRGB: () => (/* binding */ ct),\n/* harmony export */   isRGBShort: () => (/* binding */ Pe),\n/* harmony export */   isSDKError: () => (/* binding */ Ts),\n/* harmony export */   isSDKErrorOfType: () => (/* binding */ Rn),\n/* harmony export */   isSSR: () => (/* binding */ Ss),\n/* harmony export */   isTMA: () => (/* binding */ En),\n/* harmony export */   json: () => (/* binding */ w),\n/* harmony export */   mergeClassNames: () => (/* binding */ gn),\n/* harmony export */   mockTelegramEnv: () => (/* binding */ Pn),\n/* harmony export */   number: () => (/* binding */ x),\n/* harmony export */   off: () => (/* binding */ z),\n/* harmony export */   on: () => (/* binding */ y),\n/* harmony export */   parseInitData: () => (/* binding */ fn),\n/* harmony export */   parseLaunchParams: () => (/* binding */ dt),\n/* harmony export */   parseThemeParams: () => (/* binding */ Xt),\n/* harmony export */   postEvent: () => (/* binding */ B),\n/* harmony export */   request: () => (/* binding */ g),\n/* harmony export */   requestBiometryInfo: () => (/* binding */ ze),\n/* harmony export */   requestThemeParams: () => (/* binding */ mn),\n/* harmony export */   requestViewport: () => (/* binding */ te),\n/* harmony export */   retrieveLaunchParams: () => (/* binding */ nt),\n/* harmony export */   rgb: () => (/* binding */ It),\n/* harmony export */   searchParams: () => (/* binding */ lt),\n/* harmony export */   serializeLaunchParams: () => (/* binding */ Ue),\n/* harmony export */   serializeThemeParams: () => (/* binding */ Jt),\n/* harmony export */   setCSSVar: () => (/* binding */ P),\n/* harmony export */   setDebug: () => (/* binding */ le),\n/* harmony export */   setTargetOrigin: () => (/* binding */ wn),\n/* harmony export */   string: () => (/* binding */ h),\n/* harmony export */   subscribe: () => (/* binding */ pe),\n/* harmony export */   supports: () => (/* binding */ C),\n/* harmony export */   targetOrigin: () => (/* binding */ ke),\n/* harmony export */   toRGB: () => (/* binding */ At),\n/* harmony export */   unsubscribe: () => (/* binding */ Ct),\n/* harmony export */   urlToPath: () => (/* binding */ H),\n/* harmony export */   useBackButton: () => (/* binding */ Ds),\n/* harmony export */   useBackButtonRaw: () => (/* binding */ Ns),\n/* harmony export */   useBiometryManager: () => (/* binding */ Ms),\n/* harmony export */   useBiometryManagerRaw: () => (/* binding */ Bs),\n/* harmony export */   useClosingBehavior: () => (/* binding */ Ls),\n/* harmony export */   useClosingBehaviorRaw: () => (/* binding */ Vs),\n/* harmony export */   useCloudStorage: () => (/* binding */ Us),\n/* harmony export */   useCloudStorageRaw: () => (/* binding */ $s),\n/* harmony export */   useHapticFeedback: () => (/* binding */ Ws),\n/* harmony export */   useHapticFeedbackRaw: () => (/* binding */ Hs),\n/* harmony export */   useInitData: () => (/* binding */ js),\n/* harmony export */   useInitDataRaw: () => (/* binding */ Gs),\n/* harmony export */   useInvoice: () => (/* binding */ Ks),\n/* harmony export */   useInvoiceRaw: () => (/* binding */ zs),\n/* harmony export */   useLaunchParams: () => (/* binding */ Xn),\n/* harmony export */   useMainButton: () => (/* binding */ Fs),\n/* harmony export */   useMainButtonRaw: () => (/* binding */ Js),\n/* harmony export */   useMiniApp: () => (/* binding */ Ys),\n/* harmony export */   useMiniAppRaw: () => (/* binding */ Qs),\n/* harmony export */   usePopup: () => (/* binding */ Xs),\n/* harmony export */   usePopupRaw: () => (/* binding */ Zs),\n/* harmony export */   useQRScanner: () => (/* binding */ en),\n/* harmony export */   useQRScannerRaw: () => (/* binding */ tn),\n/* harmony export */   useSDK: () => (/* binding */ Os),\n/* harmony export */   useSettingsButton: () => (/* binding */ nn),\n/* harmony export */   useSettingsButtonRaw: () => (/* binding */ sn),\n/* harmony export */   useThemeParams: () => (/* binding */ on),\n/* harmony export */   useThemeParamsRaw: () => (/* binding */ rn),\n/* harmony export */   useUtils: () => (/* binding */ cn),\n/* harmony export */   useUtilsRaw: () => (/* binding */ an),\n/* harmony export */   useViewport: () => (/* binding */ pn),\n/* harmony export */   useViewportRaw: () => (/* binding */ hn),\n/* harmony export */   withBackButton: () => (/* binding */ Tn),\n/* harmony export */   withBackButtonRaw: () => (/* binding */ Sn),\n/* harmony export */   withBiometryManager: () => (/* binding */ In),\n/* harmony export */   withBiometryManagerRaw: () => (/* binding */ An),\n/* harmony export */   withClosingBehavior: () => (/* binding */ qn),\n/* harmony export */   withClosingBehaviorRaw: () => (/* binding */ kn),\n/* harmony export */   withCloudStorage: () => (/* binding */ Nn),\n/* harmony export */   withCloudStorageRaw: () => (/* binding */ On),\n/* harmony export */   withHapticFeedback: () => (/* binding */ Bn),\n/* harmony export */   withHapticFeedbackRaw: () => (/* binding */ Dn),\n/* harmony export */   withInitData: () => (/* binding */ Vn),\n/* harmony export */   withInitDataRaw: () => (/* binding */ Mn),\n/* harmony export */   withInvoice: () => (/* binding */ $n),\n/* harmony export */   withInvoiceRaw: () => (/* binding */ Ln),\n/* harmony export */   withMainButton: () => (/* binding */ Hn),\n/* harmony export */   withMainButtonRaw: () => (/* binding */ Un),\n/* harmony export */   withMiniApp: () => (/* binding */ Gn),\n/* harmony export */   withMiniAppRaw: () => (/* binding */ Wn),\n/* harmony export */   withPopup: () => (/* binding */ zn),\n/* harmony export */   withPopupRaw: () => (/* binding */ jn),\n/* harmony export */   withQRScanner: () => (/* binding */ Jn),\n/* harmony export */   withQRScannerRaw: () => (/* binding */ Kn),\n/* harmony export */   withSettingsButton: () => (/* binding */ Qn),\n/* harmony export */   withSettingsButtonRaw: () => (/* binding */ Fn),\n/* harmony export */   withThemeParams: () => (/* binding */ Zn),\n/* harmony export */   withThemeParamsRaw: () => (/* binding */ Yn),\n/* harmony export */   withTimeout: () => (/* binding */ Mt),\n/* harmony export */   withUtils: () => (/* binding */ er),\n/* harmony export */   withUtilsRaw: () => (/* binding */ tr),\n/* harmony export */   withViewport: () => (/* binding */ nr),\n/* harmony export */   withViewportRaw: () => (/* binding */ sr)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\nvar ce = Object.defineProperty, he = (e, t, s) => t in e ? ce(e, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[t] = s, c = (e, t, s) => he(e, typeof t != \"symbol\" ? t + \"\" : t, s);\nfunction xt(e, t) {\n  let s;\n  const n = () => {\n    s !== void 0 && t && t(s), s = void 0;\n  };\n  return [() => s === void 0 ? s = e(n) : s, n];\n}\nfunction Ct(e) {\n  const t = j(), { count: s } = t;\n  t.unsubscribe(e), s && !t.count && Ae();\n}\nfunction pe(e) {\n  return j().subscribe(e), () => Ct(e);\n}\nclass ue {\n  constructor(t, s = {}) {\n    this.scope = t, this.options = s;\n  }\n  /**\n   * Prints message into a console in case, logger is currently enabled.\n   * @param level - log level.\n   * @param args - arguments.\n   */\n  print(t, ...s) {\n    const n = /* @__PURE__ */ new Date(), r = Intl.DateTimeFormat(\"en-GB\", {\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n      fractionalSecondDigits: 3,\n      timeZone: \"UTC\"\n    }).format(n), { textColor: i, bgColor: o } = this.options, a = \"font-weight: bold;padding: 0 5px;border-radius:5px\";\n    console[t](\n      `%c${r}%c / %c${this.scope}`,\n      `${a};background-color: lightblue;color:black`,\n      \"\",\n      `${a};${i ? `color:${i};` : \"\"}${o ? `background-color:${o}` : \"\"}`,\n      ...s\n    );\n  }\n  /**\n   * Prints error message into a console.\n   * @param args\n   */\n  error(...t) {\n    this.print(\"error\", ...t);\n  }\n  /**\n   * Prints log message into a console.\n   * @param args\n   */\n  log(...t) {\n    this.print(\"log\", ...t);\n  }\n}\nconst it = new ue(\"SDK\", {\n  bgColor: \"forestgreen\",\n  textColor: \"white\"\n});\nlet X = !1;\nconst vt = ({ name: e, payload: t }) => {\n  it.log(\"Event received:\", t ? { name: e, payload: t } : { name: e });\n};\nfunction le(e) {\n  X !== e && (X = e, e ? pe(vt) : Ct(vt));\n}\nfunction de(...e) {\n  X && it.log(...e);\n}\nclass D {\n  constructor() {\n    c(this, \"listeners\", /* @__PURE__ */ new Map()), c(this, \"listenersCount\", 0), c(this, \"subscribeListeners\", []);\n  }\n  /**\n   * Removes all event listeners.\n   */\n  clear() {\n    this.listeners.clear(), this.subscribeListeners = [];\n  }\n  /**\n   * Returns count of bound listeners.\n   */\n  get count() {\n    return this.listenersCount + this.subscribeListeners.length;\n  }\n  emit(t, ...s) {\n    this.subscribeListeners.forEach((n) => n({\n      event: t,\n      args: s\n    })), (this.listeners.get(t) || []).forEach(([n, r]) => {\n      n(...s), r && this.off(t, n);\n    });\n  }\n  /**\n   * Adds new event listener.\n   * @param event - event name.\n   * @param listener - event listener.\n   * @param once - should listener be called only once.\n   * @returns Function to remove bound event listener.\n   */\n  on(t, s, n) {\n    let r = this.listeners.get(t);\n    return r || this.listeners.set(t, r = []), r.push([s, n]), this.listenersCount += 1, () => this.off(t, s);\n  }\n  /**\n   * Removes event listener. In case, specified listener was bound several times, it removes\n   * only a single one.\n   * @param event - event name.\n   * @param listener - event listener.\n   */\n  off(t, s) {\n    const n = this.listeners.get(t) || [];\n    for (let r = 0; r < n.length; r += 1)\n      if (s === n[r][0]) {\n        n.splice(r, 1), this.listenersCount -= 1;\n        return;\n      }\n  }\n  /**\n   * Adds a new event listener for all events.\n   * @param listener - event listener.\n   * @returns Function to remove event listener.\n   */\n  subscribe(t) {\n    return this.subscribeListeners.push(t), () => this.unsubscribe(t);\n  }\n  /**\n   * Removes global event listener. In case, specified listener was bound several times, it removes\n   * only a single one.\n   * @param listener - event listener.\n   */\n  unsubscribe(t) {\n    for (let s = 0; s < this.subscribeListeners.length; s += 1)\n      if (this.subscribeListeners[s] === t) {\n        this.subscribeListeners.splice(s, 1);\n        return;\n      }\n  }\n}\nfunction tt(e, t, s) {\n  return window.addEventListener(e, t, s), () => window.removeEventListener(e, t, s);\n}\nfunction ot(...e) {\n  let t = !1;\n  const s = [...e];\n  return [\n    (n) => !t && s.push(n),\n    () => {\n      t || (t = !0, s.forEach((n) => n()));\n    },\n    t\n  ];\n}\nclass W extends Error {\n  constructor(t, s, n) {\n    super(s, { cause: n }), this.type = t, Object.setPrototypeOf(this, W.prototype);\n  }\n}\nfunction m(e, t, s) {\n  return new W(e, t, s);\n}\nconst _e = \"ERR_METHOD_UNSUPPORTED\", we = \"ERR_METHOD_PARAMETER_UNSUPPORTED\", ge = \"ERR_UNKNOWN_ENV\", fe = \"ERR_INVOKE_CUSTOM_METHOD_RESPONSE\", me = \"ERR_TIMED_OUT\", be = \"ERR_UNEXPECTED_TYPE\", St = \"ERR_PARSE\", ve = \"ERR_NAVIGATION_LIST_EMPTY\", ye = \"ERR_NAVIGATION_CURSOR_INVALID\", dn = \"ERR_NAVIGATION_ITEM_INVALID\", _n = \"ERR_SSR_INIT\", Ee = \"ERR_INVALID_PATH_BASE\";\nfunction T() {\n  return m(be, \"Value has unexpected type\");\n}\nclass G {\n  constructor(t, s, n) {\n    this.parser = t, this.isOptional = s, this.type = n;\n  }\n  /**\n   * Attempts to parse passed value\n   * @param value - value to parse.\n   * @throws {SDKError} ERR_PARSE\n   * @see ERR_PARSE\n   */\n  parse(t) {\n    if (!(this.isOptional && t === void 0))\n      try {\n        return this.parser(t);\n      } catch (s) {\n        throw m(\n          St,\n          `Unable to parse value${this.type ? ` as ${this.type}` : \"\"}`,\n          s\n        );\n      }\n  }\n  optional() {\n    return this.isOptional = !0, this;\n  }\n}\nfunction A(e, t) {\n  return () => new G(e, !1, t);\n}\nconst E = A((e) => {\n  if (typeof e == \"boolean\")\n    return e;\n  const t = String(e);\n  if (t === \"1\" || t === \"true\")\n    return !0;\n  if (t === \"0\" || t === \"false\")\n    return !1;\n  throw T();\n}, \"boolean\");\nfunction Tt(e, t) {\n  const s = {};\n  for (const n in e) {\n    const r = e[n];\n    if (!r)\n      continue;\n    let i, o;\n    if (typeof r == \"function\" || \"parse\" in r)\n      i = n, o = typeof r == \"function\" ? r : r.parse.bind(r);\n    else {\n      const { type: a } = r;\n      i = r.from || n, o = typeof a == \"function\" ? a : a.parse.bind(a);\n    }\n    try {\n      const a = o(t(i));\n      a !== void 0 && (s[n] = a);\n    } catch (a) {\n      throw m(St, `Unable to parse field \"${n}\"`, a);\n    }\n  }\n  return s;\n}\nfunction at(e) {\n  let t = e;\n  if (typeof t == \"string\" && (t = JSON.parse(t)), typeof t != \"object\" || t === null || Array.isArray(t))\n    throw T();\n  return t;\n}\nfunction w(e, t) {\n  return new G((s) => {\n    const n = at(s);\n    return Tt(e, (r) => n[r]);\n  }, !1, t);\n}\nconst x = A((e) => {\n  if (typeof e == \"number\")\n    return e;\n  if (typeof e == \"string\") {\n    const t = Number(e);\n    if (!Number.isNaN(t))\n      return t;\n  }\n  throw T();\n}, \"number\");\nfunction ct(e) {\n  return /^#[\\da-f]{6}$/i.test(e);\n}\nfunction Pe(e) {\n  return /^#[\\da-f]{3}$/i.test(e);\n}\nfunction At(e) {\n  const t = e.replace(/\\s/g, \"\").toLowerCase();\n  if (ct(t))\n    return t;\n  if (Pe(t)) {\n    let n = \"#\";\n    for (let r = 0; r < 3; r += 1)\n      n += t[1 + r].repeat(2);\n    return n;\n  }\n  const s = t.match(/^rgb\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3})\\)$/) || t.match(/^rgba\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3}),\\d{1,3}\\)$/);\n  if (!s)\n    throw new Error(`Value \"${e}\" does not satisfy any of known RGB formats.`);\n  return s.slice(1).reduce((n, r) => {\n    const i = parseInt(r, 10).toString(16);\n    return n + (i.length === 1 ? \"0\" : \"\") + i;\n  }, \"#\");\n}\nconst h = A((e) => {\n  if (typeof e == \"string\" || typeof e == \"number\")\n    return e.toString();\n  throw T();\n}, \"string\"), It = A((e) => At(h().parse(e)), \"rgb\");\nfunction kt(e) {\n  return w({\n    eventType: h(),\n    eventData: (t) => t\n  }).parse(e);\n}\nfunction Re() {\n  [\"TelegramGameProxy_receiveEvent\", \"TelegramGameProxy\", \"Telegram\"].forEach((e) => {\n    delete window[e];\n  });\n}\nfunction et(e, t) {\n  window.dispatchEvent(new MessageEvent(\"message\", {\n    data: JSON.stringify({ eventType: e, eventData: t }),\n    // We specify window.parent to imitate the case, the parent iframe sent us this event.\n    source: window.parent\n  }));\n}\nfunction xe() {\n  [\n    [\"TelegramGameProxy_receiveEvent\"],\n    // Windows Phone.\n    [\"TelegramGameProxy\", \"receiveEvent\"],\n    // Desktop.\n    [\"Telegram\", \"WebView\", \"receiveEvent\"]\n    // Android and iOS.\n  ].forEach((e) => {\n    let t = window;\n    e.forEach((s, n, r) => {\n      if (n === r.length - 1) {\n        t[s] = et;\n        return;\n      }\n      s in t || (t[s] = {}), t = t[s];\n    });\n  });\n}\nconst Ce = {\n  clipboard_text_received: w({\n    req_id: h(),\n    data: (e) => e === null ? e : h().optional().parse(e)\n  }),\n  custom_method_invoked: w({\n    req_id: h(),\n    result: (e) => e,\n    error: h().optional()\n  }),\n  invoice_closed: w({ slug: h(), status: h() }),\n  phone_requested: w({ status: h() }),\n  popup_closed: {\n    parse(e) {\n      return w({\n        button_id: (t) => t == null ? void 0 : h().parse(t)\n      }).parse(e ?? {});\n    }\n  },\n  qr_text_received: w({ data: h().optional() }),\n  theme_changed: w({\n    theme_params: (e) => {\n      const t = It().optional();\n      return Object.entries(at(e)).reduce((s, [n, r]) => (s[n] = t.parse(r), s), {});\n    }\n  }),\n  viewport_changed: w({\n    height: x(),\n    width: (e) => e == null ? window.innerWidth : x().parse(e),\n    is_state_stable: E(),\n    is_expanded: E()\n  }),\n  write_access_requested: w({ status: h() })\n};\nfunction Se() {\n  const e = new D(), t = new D();\n  t.subscribe((n) => {\n    e.emit(\"event\", { name: n.event, payload: n.args[0] });\n  }), xe();\n  const [, s] = ot(\n    // Don't forget to remove created handlers.\n    Re,\n    // Add \"resize\" event listener to make sure, we always have fresh viewport information.\n    // Desktop version of Telegram is sometimes not sending the viewport_changed\n    // event. For example, when the MainButton is shown. That's why we should\n    // add our own listener to make sure, viewport information is always fresh.\n    // Issue: https://github.com/Telegram-Mini-Apps/tma.js/issues/10\n    tt(\"resize\", () => {\n      t.emit(\"viewport_changed\", {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        is_state_stable: !0,\n        is_expanded: !0\n      });\n    }),\n    // Add listener, which handles events sent from the Telegram web application and also events\n    // generated by the local emitEvent function.\n    tt(\"message\", (n) => {\n      if (n.source !== window.parent)\n        return;\n      let r;\n      try {\n        r = kt(n.data);\n      } catch {\n        return;\n      }\n      const { eventType: i, eventData: o } = r, a = Ce[i];\n      try {\n        const p = a ? a.parse(o) : o;\n        t.emit(...p ? [i, p] : [i]);\n      } catch (p) {\n        it.error(\n          `An error occurred processing the \"${i}\" event from the Telegram application. Please, file an issue here: https://github.com/Telegram-Mini-Apps/tma.js/issues/new/choose`,\n          r,\n          p\n        );\n      }\n    }),\n    // Clear emitters.\n    () => e.clear(),\n    () => t.clear()\n  );\n  return [{\n    on: t.on.bind(t),\n    off: t.off.bind(t),\n    subscribe(n) {\n      return e.on(\"event\", n);\n    },\n    unsubscribe(n) {\n      e.off(\"event\", n);\n    },\n    get count() {\n      return t.count + e.count;\n    }\n  }, s];\n}\nconst [Te, Ae] = xt(\n  (e) => {\n    const [t, s] = Se(), n = t.off.bind(t);\n    return t.off = (r, i) => {\n      const { count: o } = t;\n      n(r, i), o && !t.count && e();\n    }, [t, s];\n  },\n  ([, e]) => e()\n);\nfunction j() {\n  return Te()[0];\n}\nfunction z(e, t) {\n  j().off(e, t);\n}\nfunction y(e, t, s) {\n  return j().on(e, t, s);\n}\nfunction V(e) {\n  return typeof e == \"object\" && e !== null && !Array.isArray(e);\n}\nfunction Ie(e, t) {\n  const s = e.split(\".\"), n = t.split(\".\"), r = Math.max(s.length, n.length);\n  for (let i = 0; i < r; i += 1) {\n    const o = parseInt(s[i] || \"0\", 10), a = parseInt(n[i] || \"0\", 10);\n    if (o !== a)\n      return o > a ? 1 : -1;\n  }\n  return 0;\n}\nfunction v(e, t) {\n  return Ie(e, t) <= 0;\n}\nfunction C(e, t, s) {\n  if (typeof s == \"string\") {\n    if (e === \"web_app_open_link\" && t === \"try_instant_view\")\n      return v(\"6.4\", s);\n    if (e === \"web_app_set_header_color\" && t === \"color\")\n      return v(\"6.9\", s);\n  }\n  switch (e) {\n    case \"web_app_open_tg_link\":\n    case \"web_app_open_invoice\":\n    case \"web_app_setup_back_button\":\n    case \"web_app_set_background_color\":\n    case \"web_app_set_header_color\":\n    case \"web_app_trigger_haptic_feedback\":\n      return v(\"6.1\", t);\n    case \"web_app_open_popup\":\n      return v(\"6.2\", t);\n    case \"web_app_close_scan_qr_popup\":\n    case \"web_app_open_scan_qr_popup\":\n    case \"web_app_read_text_from_clipboard\":\n      return v(\"6.4\", t);\n    case \"web_app_switch_inline_query\":\n      return v(\"6.7\", t);\n    case \"web_app_invoke_custom_method\":\n    case \"web_app_request_write_access\":\n    case \"web_app_request_phone\":\n      return v(\"6.9\", t);\n    case \"web_app_setup_settings_button\":\n      return v(\"6.10\", t);\n    case \"web_app_biometry_get_info\":\n    case \"web_app_biometry_open_settings\":\n    case \"web_app_biometry_request_access\":\n    case \"web_app_biometry_request_auth\":\n    case \"web_app_biometry_update_token\":\n      return v(\"7.2\", t);\n    default:\n      return [\n        \"iframe_ready\",\n        \"iframe_will_reload\",\n        \"web_app_close\",\n        \"web_app_data_send\",\n        \"web_app_expand\",\n        \"web_app_open_link\",\n        \"web_app_ready\",\n        \"web_app_request_theme\",\n        \"web_app_request_viewport\",\n        \"web_app_setup_main_button\",\n        \"web_app_setup_closing_behavior\"\n      ].includes(e);\n  }\n}\nfunction qt(e) {\n  return \"external\" in e && V(e.external) && \"notify\" in e.external && typeof e.external.notify == \"function\";\n}\nfunction Ot(e) {\n  return \"TelegramWebviewProxy\" in e && V(e.TelegramWebviewProxy) && \"postEvent\" in e.TelegramWebviewProxy && typeof e.TelegramWebviewProxy.postEvent == \"function\";\n}\nfunction ht() {\n  try {\n    return window.self !== window.top;\n  } catch {\n    return !0;\n  }\n}\nlet Nt = \"https://web.telegram.org\";\nfunction wn(e) {\n  Nt = e;\n}\nfunction ke() {\n  return Nt;\n}\nfunction B(e, t, s) {\n  let n = {}, r;\n  t === void 0 && s === void 0 ? n = {} : t !== void 0 && s !== void 0 ? (n = s, r = t) : t !== void 0 && (\"targetOrigin\" in t ? n = t : r = t);\n  const { targetOrigin: i = ke() } = n;\n  if (de(\"Posting event:\", r ? { event: e, data: r } : { event: e }), ht()) {\n    window.parent.postMessage(JSON.stringify({ eventType: e, eventData: r }), i);\n    return;\n  }\n  if (qt(window)) {\n    window.external.notify(JSON.stringify({ eventType: e, eventData: r }));\n    return;\n  }\n  if (Ot(window)) {\n    window.TelegramWebviewProxy.postEvent(e, JSON.stringify(r));\n    return;\n  }\n  throw m(\n    ge,\n    \"Unable to determine current environment and possible way to send event. You are probably trying to use Mini Apps method outside of Telegram application environment.\"\n  );\n}\nfunction qe(e) {\n  return (t, s) => {\n    if (!C(t, e))\n      throw m(_e, `Method \"${t}\" is unsupported in Mini Apps version ${e}`);\n    if (V(s)) {\n      let n;\n      if (t === \"web_app_open_link\" && \"try_instant_view\" in s ? n = \"try_instant_view\" : t === \"web_app_set_header_color\" && \"color\" in s && (n = \"color\"), n && !C(t, n, e))\n        throw m(\n          we,\n          `Parameter \"${n}\" of \"${t}\" method is unsupported in Mini Apps version ${e}`\n        );\n    }\n    return B(t, s);\n  };\n}\nfunction Dt(e) {\n  return ({ req_id: t }) => t === e;\n}\nfunction Bt(e) {\n  return m(me, `Timeout reached: ${e}ms`);\n}\nfunction Mt(e, t) {\n  return Promise.race([\n    typeof e == \"function\" ? e() : e,\n    new Promise((s, n) => {\n      setTimeout(() => {\n        n(Bt(t));\n      }, t);\n    })\n  ]);\n}\nasync function g(e) {\n  let t;\n  const s = new Promise((a) => {\n    t = a;\n  }), { event: n, capture: r, timeout: i } = e, [, o] = ot(\n    ...(Array.isArray(n) ? n : [n]).map(\n      (a) => y(a, (p) => (!r || r(p)) && t(p))\n    )\n  );\n  try {\n    return (e.postEvent || B)(e.method, e.params), await (i ? Mt(s, i) : s);\n  } finally {\n    o();\n  }\n}\nasync function O(e, t, s, n = {}) {\n  const {\n    result: r,\n    error: i\n  } = await g({\n    ...n,\n    method: \"web_app_invoke_custom_method\",\n    event: \"custom_method_invoked\",\n    params: {\n      method: e,\n      params: t,\n      req_id: s\n    },\n    capture: Dt(s)\n  });\n  if (i)\n    throw m(fe, i);\n  return r;\n}\nfunction st(...e) {\n  return e.map((t) => {\n    if (typeof t == \"string\")\n      return t;\n    if (V(t))\n      return st(Object.entries(t).map((s) => s[1] && s[0]));\n    if (Array.isArray(t))\n      return st(...t);\n  }).filter(Boolean).join(\" \");\n}\nfunction gn(...e) {\n  return e.reduce((t, s) => (V(s) && Object.entries(s).forEach(([n, r]) => {\n    const i = st(t[n], r);\n    i.length && (t[n] = i);\n  }), t), {});\n}\nfunction Vt(e) {\n  const t = At(e);\n  return Math.sqrt(\n    [0.299, 0.587, 0.114].reduce((s, n, r) => {\n      const i = parseInt(t.slice(1 + r * 2, 1 + (r + 1) * 2), 16);\n      return s + i * i * n;\n    }, 0)\n  ) < 120;\n}\nclass Oe {\n  constructor(t) {\n    c(this, \"ee\", new D()), c(this, \"on\", this.ee.on.bind(this.ee)), c(this, \"off\", this.ee.off.bind(this.ee)), this.state = t;\n  }\n  /**\n   * Clones current state and returns its copy.\n   */\n  clone() {\n    return { ...this.state };\n  }\n  set(t, s) {\n    Object.entries(typeof t == \"string\" ? { [t]: s } : t).reduce((n, [r, i]) => this.state[r] === i || i === void 0 ? n : (this.state[r] = i, this.ee.emit(`change:${r}`, i), !0), !1) && this.ee.emit(\"change\", this.state);\n  }\n  /**\n   * Returns value by specified key.\n   * @param key - state key.\n   */\n  get(t) {\n    return this.state[t];\n  }\n}\nclass pt {\n  constructor(t) {\n    c(this, \"state\"), c(this, \"get\"), c(this, \"set\"), c(this, \"clone\"), this.state = new Oe(t), this.set = this.state.set.bind(this.state), this.get = this.state.get.bind(this.state), this.clone = this.state.clone.bind(this.state);\n  }\n}\nfunction Lt(e, t) {\n  return (s) => C(t[s], e);\n}\nclass ut extends pt {\n  constructor(t, s, n) {\n    super(t), c(this, \"supports\"), this.supports = Lt(s, n);\n  }\n}\nclass Ne extends ut {\n  constructor(t, s, n) {\n    super({ isVisible: t }, s, {\n      show: \"web_app_setup_back_button\",\n      hide: \"web_app_setup_back_button\"\n    }), c(this, \"on\", (r, i) => r === \"click\" ? y(\"back_button_pressed\", i) : this.state.on(r, i)), c(this, \"off\", (r, i) => r === \"click\" ? z(\"back_button_pressed\", i) : this.state.off(r, i)), this.postEvent = n;\n  }\n  set isVisible(t) {\n    this.set(\"isVisible\", t), this.postEvent(\"web_app_setup_back_button\", { is_visible: t });\n  }\n  /**\n   * True if BackButton is currently visible.\n   */\n  get isVisible() {\n    return this.get(\"isVisible\");\n  }\n  /**\n   * Hides the BackButton.\n   */\n  hide() {\n    this.isVisible = !1;\n  }\n  /**\n   * Shows the BackButton.\n   */\n  show() {\n    this.isVisible = !0;\n  }\n}\nconst $t = A((e) => e instanceof Date ? e : new Date(x().parse(e) * 1e3), \"Date\");\nfunction lt(e, t) {\n  return new G((s) => {\n    if (typeof s != \"string\" && !(s instanceof URLSearchParams))\n      throw T();\n    const n = typeof s == \"string\" ? new URLSearchParams(s) : s;\n    return Tt(e, (r) => {\n      const i = n.get(r);\n      return i === null ? void 0 : i;\n    });\n  }, !1, t);\n}\nconst De = w({\n  id: x(),\n  type: h(),\n  title: h(),\n  photoUrl: {\n    type: h().optional(),\n    from: \"photo_url\"\n  },\n  username: h().optional()\n}, \"Chat\").optional(), yt = w({\n  addedToAttachmentMenu: {\n    type: E().optional(),\n    from: \"added_to_attachment_menu\"\n  },\n  allowsWriteToPm: {\n    type: E().optional(),\n    from: \"allows_write_to_pm\"\n  },\n  firstName: {\n    type: h(),\n    from: \"first_name\"\n  },\n  id: x(),\n  isBot: {\n    type: E().optional(),\n    from: \"is_bot\"\n  },\n  isPremium: {\n    type: E().optional(),\n    from: \"is_premium\"\n  },\n  languageCode: {\n    type: h().optional(),\n    from: \"language_code\"\n  },\n  lastName: {\n    type: h().optional(),\n    from: \"last_name\"\n  },\n  photoUrl: {\n    type: h().optional(),\n    from: \"photo_url\"\n  },\n  username: h().optional()\n}, \"User\").optional();\nfunction Ut() {\n  return lt({\n    authDate: {\n      type: $t(),\n      from: \"auth_date\"\n    },\n    canSendAfter: {\n      type: x().optional(),\n      from: \"can_send_after\"\n    },\n    chat: De,\n    chatInstance: {\n      type: h().optional(),\n      from: \"chat_instance\"\n    },\n    chatType: {\n      type: h().optional(),\n      from: \"chat_type\"\n    },\n    hash: h(),\n    queryId: {\n      type: h().optional(),\n      from: \"query_id\"\n    },\n    receiver: yt,\n    startParam: {\n      type: h().optional(),\n      from: \"start_param\"\n    },\n    user: yt\n  }, \"InitData\");\n}\nfunction Be(e) {\n  return e.replace(/_[a-z]/g, (t) => t[1].toUpperCase());\n}\nfunction Me(e) {\n  return e.replace(/[A-Z]/g, (t) => `_${t.toLowerCase()}`);\n}\nconst Ht = A(\n  (e) => {\n    const t = It().optional();\n    return Object.entries(at(e)).reduce((s, [n, r]) => (s[Be(n)] = t.parse(r), s), {});\n  },\n  \"ThemeParams\"\n);\nfunction dt(e) {\n  return lt({\n    botInline: {\n      type: E().optional(),\n      from: \"tgWebAppBotInline\"\n    },\n    initData: {\n      type: Ut().optional(),\n      from: \"tgWebAppData\"\n    },\n    initDataRaw: {\n      type: h().optional(),\n      from: \"tgWebAppData\"\n    },\n    platform: {\n      type: h(),\n      from: \"tgWebAppPlatform\"\n    },\n    showSettings: {\n      type: E().optional(),\n      from: \"tgWebAppShowSettings\"\n    },\n    startParam: {\n      type: h().optional(),\n      from: \"tgWebAppStartParam\"\n    },\n    themeParams: {\n      type: Ht(),\n      from: \"tgWebAppThemeParams\"\n    },\n    version: {\n      type: h(),\n      from: \"tgWebAppVersion\"\n    }\n  }).parse(e);\n}\nfunction Wt(e) {\n  return dt(\n    e.replace(/^[^?#]*[?#]/, \"\").replace(/[?#]/g, \"&\")\n  );\n}\nfunction Ve() {\n  return Wt(window.location.href);\n}\nfunction Gt() {\n  return performance.getEntriesByType(\"navigation\")[0];\n}\nfunction Le() {\n  const e = Gt();\n  if (!e)\n    throw new Error(\"Unable to get first navigation entry.\");\n  return Wt(e.name);\n}\nfunction jt(e) {\n  return `tma.js/${e.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`)}`;\n}\nfunction zt(e, t) {\n  sessionStorage.setItem(jt(e), JSON.stringify(t));\n}\nfunction Kt(e) {\n  const t = sessionStorage.getItem(jt(e));\n  try {\n    return t ? JSON.parse(t) : void 0;\n  } catch {\n  }\n}\nfunction $e() {\n  return dt(Kt(\"launchParams\") || \"\");\n}\nfunction Jt(e) {\n  return JSON.stringify(\n    Object.fromEntries(\n      Object.entries(e).map(([t, s]) => [Me(t), s])\n    )\n  );\n}\nfunction Ue(e) {\n  const {\n    initDataRaw: t,\n    themeParams: s,\n    platform: n,\n    version: r,\n    showSettings: i,\n    startParam: o,\n    botInline: a\n  } = e, p = new URLSearchParams();\n  return p.set(\"tgWebAppPlatform\", n), p.set(\"tgWebAppThemeParams\", Jt(s)), p.set(\"tgWebAppVersion\", r), t && p.set(\"tgWebAppData\", t), o && p.set(\"tgWebAppStartParam\", o), typeof i == \"boolean\" && p.set(\"tgWebAppShowSettings\", i ? \"1\" : \"0\"), typeof a == \"boolean\" && p.set(\"tgWebAppBotInline\", a ? \"1\" : \"0\"), p.toString();\n}\nfunction Ft(e) {\n  zt(\"launchParams\", Ue(e));\n}\nfunction nt() {\n  for (const e of [\n    // Try to retrieve launch parameters from the current location. This method can return\n    // nothing in case, location was changed and then page was reloaded.\n    Ve,\n    // Then, try using the lower level API - window.performance.\n    Le,\n    // Finally, try to extract launch parameters from the session storage.\n    $e\n  ])\n    try {\n      const t = e();\n      return Ft(t), t;\n    } catch {\n    }\n  throw new Error(\"Unable to retrieve launch parameters from any known source.\");\n}\nfunction Qt() {\n  const e = Gt();\n  return !!(e && e.type === \"reload\");\n}\nfunction He() {\n  let e = 0;\n  return () => (e += 1).toString();\n}\nconst [We] = xt(He);\nfunction l(e, t) {\n  return () => {\n    const s = nt(), n = {\n      ...s,\n      postEvent: qe(s.version),\n      createRequestId: We()\n    };\n    if (typeof e == \"function\")\n      return e(n);\n    const [r, i, o] = ot(), a = t({\n      ...n,\n      // State should only be passed only in case, current page was reloaded. If we don't add\n      // this check, state restoration will work improperly in the web version of Telegram,\n      // when we are always working in the same \"session\" (tab).\n      state: Qt() ? Kt(e) : void 0,\n      addCleanup: r\n    }), p = (u) => (o || r(\n      u.on(\"change\", (S) => {\n        zt(e, S);\n      })\n    ), u);\n    return [\n      a instanceof Promise ? a.then(p) : p(a),\n      i\n    ];\n  };\n}\nconst Ge = l(\"backButton\", ({\n  postEvent: e,\n  version: t,\n  state: s = { isVisible: !1 }\n}) => new Ne(s.isVisible, t, e));\nclass L extends ut {\n  constructor() {\n    super(...arguments), c(this, \"on\", this.state.on.bind(this.state)), c(this, \"off\", this.state.off.bind(this.state));\n  }\n}\nfunction Yt(e) {\n  const t = e.available ? e : {\n    available: !1,\n    device_id: \"\",\n    token_saved: !1,\n    access_requested: !1,\n    access_granted: !1,\n    type: \"\"\n  };\n  return {\n    available: !0,\n    type: t.type,\n    deviceId: t.device_id,\n    tokenSaved: t.token_saved,\n    accessRequested: t.access_requested,\n    accessGranted: t.access_granted\n  };\n}\nclass je extends L {\n  constructor({ postEvent: t, version: s, ...n }) {\n    super(n, s, {\n      auth: \"web_app_biometry_request_auth\",\n      openSettings: \"web_app_biometry_open_settings\",\n      requestAccess: \"web_app_biometry_request_access\",\n      updateToken: \"web_app_biometry_update_token\"\n    }), c(this, \"postEvent\"), c(this, \"authPromise\"), c(this, \"accessPromise\"), this.postEvent = t;\n  }\n  /**\n   * Shows whether biometry is available.\n   */\n  get available() {\n    return this.get(\"available\");\n  }\n  /**\n   * Shows whether permission to use biometrics has been granted.\n   */\n  get accessGranted() {\n    return this.get(\"accessGranted\");\n  }\n  /**\n   * Shows whether if permission to use biometrics has been requested.\n   */\n  get accessRequested() {\n    return this.get(\"accessRequested\");\n  }\n  /**\n   * Authenticates the user using biometrics.\n   * @param options - method options.\n   * @since 7.2\n   * @returns Token from the local secure storage, if authentication was successful.\n   */\n  async authenticate({\n    reason: t,\n    ...s\n  }) {\n    return this.authPromise || (this.authPromise = g({\n      ...s,\n      method: \"web_app_biometry_request_auth\",\n      event: \"biometry_auth_requested\",\n      postEvent: this.postEvent,\n      params: {\n        // TODO: Check if reason is empty works fine.\n        reason: (t || \"\").trim()\n      }\n    }).then(({ token: n }) => n).finally(() => this.authPromise = void 0)), this.authPromise;\n  }\n  /**\n   * A unique device identifier that can be used to match the token to the device.\n   */\n  get deviceId() {\n    return this.get(\"deviceId\");\n  }\n  /**\n   * Opens the biometric access settings for bots. Useful when you need to request biometrics\n   * access to users who haven't granted it yet.\n   *\n   * _Note that this method can be called only in response to user interaction with the Mini App\n   * interface (e.g. a click inside the Mini App or on the main button)_.\n   * @since 7.2\n   */\n  openSettings() {\n    this.postEvent(\"web_app_biometry_open_settings\");\n  }\n  /**\n   * Requests permission to use biometrics.\n   * @since 7.2\n   * @returns Promise with true, if access was granted.\n   */\n  requestAccess({ reason: t, ...s } = {}) {\n    return this.accessPromise || (this.accessPromise = g({\n      ...s,\n      postEvent: this.postEvent,\n      method: \"web_app_biometry_request_access\",\n      event: \"biometry_info_received\",\n      params: { reason: t || \"\" }\n    }).then((n) => {\n      const r = Yt(n);\n      return this.set(r), r.accessGranted;\n    }).finally(() => this.accessPromise = void 0)), this.accessPromise;\n  }\n  /**\n   * The type of biometrics currently available on the device.\n   */\n  get biometryType() {\n    return this.get(\"biometryType\");\n  }\n  /**\n   * Shows whether token was saved previously in the local secure storage.\n   */\n  get tokenSaved() {\n    return this.get(\"tokenSaved\");\n  }\n  /**\n   * Updates the biometric token in a secure storage on the device.\n   * @returns Promise with `true`, if token was updated.\n   */\n  async updateToken({ token: t, ...s } = {}) {\n    return [\"removed\", \"updated\"].includes(\n      (await g({\n        ...s,\n        postEvent: this.postEvent,\n        method: \"web_app_biometry_update_token\",\n        event: \"biometry_token_updated\",\n        params: { token: t || \"\" }\n      })).status\n    );\n  }\n}\nasync function ze(e) {\n  return Yt(\n    await g({\n      ...e || {},\n      method: \"web_app_biometry_get_info\",\n      event: \"biometry_info_received\"\n    })\n  );\n}\nconst Ke = l(\n  \"biometryManager\",\n  async ({ postEvent: e, version: t, state: s }) => new je({\n    ...s || C(\"web_app_biometry_get_info\", t) ? s || await ze({ timeout: 1e3 }) : {\n      available: !1,\n      accessGranted: !1,\n      accessRequested: !1,\n      tokenSaved: !1,\n      deviceId: \"\"\n    },\n    version: t,\n    postEvent: e\n  })\n);\nclass _t extends pt {\n  constructor() {\n    super(...arguments), c(this, \"on\", this.state.on.bind(this.state)), c(this, \"off\", this.state.off.bind(this.state));\n  }\n}\nclass Je extends _t {\n  constructor(t, s) {\n    super({ isConfirmationNeeded: t }), this.postEvent = s;\n  }\n  set isConfirmationNeeded(t) {\n    this.set(\"isConfirmationNeeded\", t), this.postEvent(\"web_app_setup_closing_behavior\", { need_confirmation: t });\n  }\n  /**\n   * True, if the confirmation dialog should be shown while the user is trying to close\n   * the Mini App.\n   */\n  get isConfirmationNeeded() {\n    return this.get(\"isConfirmationNeeded\");\n  }\n  /**\n   * Disables the confirmation dialog when closing the Mini App.\n   */\n  disableConfirmation() {\n    this.isConfirmationNeeded = !1;\n  }\n  /**\n   * Enables the confirmation dialog when closing the Mini App.\n   */\n  enableConfirmation() {\n    this.isConfirmationNeeded = !0;\n  }\n}\nconst Fe = l(\n  \"closingBehavior\",\n  ({\n    postEvent: e,\n    state: t = { isConfirmationNeeded: !1 }\n  }) => new Je(t.isConfirmationNeeded, e)\n);\nclass wt {\n  constructor(t, s) {\n    c(this, \"supports\"), this.supports = Lt(t, s);\n  }\n}\nfunction Qe(e) {\n  if (Array.isArray(e))\n    return e;\n  if (typeof e == \"string\")\n    try {\n      const t = JSON.parse(e);\n      if (Array.isArray(t))\n        return t;\n    } catch {\n    }\n  throw T();\n}\nclass Ye extends G {\n  constructor(t, s, n) {\n    super(Qe, s, n), c(this, \"itemParser\"), this.itemParser = typeof t == \"function\" ? t : t.parse.bind(t);\n  }\n  /**\n   * Attempts to parse passed value\n   * @param value - value to parse.\n   * @throws {SDKError} ERR_PARSE\n   * @see ERR_PARSE\n   */\n  parse(t) {\n    const s = super.parse(t);\n    return s === void 0 ? s : s.map(this.itemParser);\n  }\n  of(t) {\n    return this.itemParser = typeof t == \"function\" ? t : t.parse.bind(t), this;\n  }\n}\nfunction Ze(e) {\n  return new Ye((t) => t, !1, e);\n}\nfunction Et(e, t) {\n  return Object.fromEntries(e.map((s) => [s, t]));\n}\nclass Xe extends wt {\n  constructor(t, s, n) {\n    super(t, {\n      delete: \"web_app_invoke_custom_method\",\n      get: \"web_app_invoke_custom_method\",\n      getKeys: \"web_app_invoke_custom_method\",\n      set: \"web_app_invoke_custom_method\"\n    }), this.createRequestId = s, this.postEvent = n;\n  }\n  /**\n   * Deletes specified key or keys from the cloud storage.\n   * @param keyOrKeys - key or keys to delete.\n   * @param options - request execution options.\n   */\n  async delete(t, s = {}) {\n    const n = Array.isArray(t) ? t : [t];\n    n.length && await O(\n      \"deleteStorageValues\",\n      { keys: n },\n      this.createRequestId(),\n      { ...s, postEvent: this.postEvent }\n    );\n  }\n  /**\n   * Returns list of all keys presented in the cloud storage.\n   * @param options - request execution options.\n   */\n  async getKeys(t = {}) {\n    return Ze().of(h()).parse(\n      await O(\n        \"getStorageKeys\",\n        {},\n        this.createRequestId(),\n        { ...t, postEvent: this.postEvent }\n      )\n    );\n  }\n  async get(t, s = {}) {\n    const n = Array.isArray(t) ? t : [t];\n    if (!n.length)\n      return Et(n, \"\");\n    const r = await O(\n      \"getStorageValues\",\n      { keys: n },\n      this.createRequestId(),\n      { ...s, postEvent: this.postEvent }\n    ), i = w(Et(n, h()), \"CloudStorageData\").parse(r);\n    return Array.isArray(t) ? i : i[t];\n  }\n  /**\n   * Saves specified value by key.\n   * @param key - storage key.\n   * @param value - storage value.\n   * @param options - request execution options.\n   */\n  async set(t, s, n = {}) {\n    await O(\n      \"saveStorageValue\",\n      { key: t, value: s },\n      this.createRequestId(),\n      { ...n, postEvent: this.postEvent }\n    );\n  }\n}\nconst ts = l(\n  ({ createRequestId: e, postEvent: t, version: s }) => new Xe(s, e, t)\n);\nclass es extends wt {\n  constructor(t, s) {\n    super(t, {\n      impactOccurred: \"web_app_trigger_haptic_feedback\",\n      notificationOccurred: \"web_app_trigger_haptic_feedback\",\n      selectionChanged: \"web_app_trigger_haptic_feedback\"\n    }), this.postEvent = s;\n  }\n  /**\n   * A method tells that an impact occurred. The Telegram app may play the\n   * appropriate haptics based on style value passed.\n   * @param style - impact style.\n   */\n  impactOccurred(t) {\n    this.postEvent(\"web_app_trigger_haptic_feedback\", {\n      type: \"impact\",\n      impact_style: t\n    });\n  }\n  /**\n   * A method tells that a task or action has succeeded, failed, or produced\n   * a warning. The Telegram app may play the appropriate haptics based on\n   * type value passed.\n   * @param type - notification type.\n   */\n  notificationOccurred(t) {\n    this.postEvent(\"web_app_trigger_haptic_feedback\", {\n      type: \"notification\",\n      notification_type: t\n    });\n  }\n  /**\n   * A method tells that the user has changed a selection. The Telegram app\n   * may play the appropriate haptics.\n   *\n   * Do not use this feedback when the user makes or confirms a selection;\n   * use it only when the selection changes.\n   */\n  selectionChanged() {\n    this.postEvent(\"web_app_trigger_haptic_feedback\", { type: \"selection_change\" });\n  }\n}\nconst ss = l(\n  ({ version: e, postEvent: t }) => new es(e, t)\n);\nclass ns {\n  constructor(t) {\n    this.initData = t;\n  }\n  /**\n   * @see InitDataParsed.authDate\n   */\n  get authDate() {\n    return this.initData.authDate;\n  }\n  /**\n   * @see InitDataParsed.canSendAfter\n   */\n  get canSendAfter() {\n    return this.initData.canSendAfter;\n  }\n  /**\n   * Date after which it is allowed to call\n   * the [answerWebAppQuery](https://core.telegram.org/bots/api#answerwebappquery) method.\n   */\n  get canSendAfterDate() {\n    const { canSendAfter: t } = this;\n    return t ? new Date(this.authDate.getTime() + t * 1e3) : void 0;\n  }\n  /**\n   * @see InitDataParsed.chat\n   */\n  get chat() {\n    return this.initData.chat;\n  }\n  /**\n   * @see InitDataParsed.chatType\n   */\n  get chatType() {\n    return this.initData.chatType;\n  }\n  /**\n   * @see InitDataParsed.chatInstance\n   */\n  get chatInstance() {\n    return this.initData.chatInstance;\n  }\n  /**\n   * @see InitDataParsed.hash\n   */\n  get hash() {\n    return this.initData.hash;\n  }\n  /**\n   * @see InitDataParsed.queryId\n   */\n  get queryId() {\n    return this.initData.queryId;\n  }\n  /**\n   * @see InitDataParsed.receiver\n   */\n  get receiver() {\n    return this.initData.receiver;\n  }\n  /**\n   * @see InitDataParsed.startParam\n   */\n  get startParam() {\n    return this.initData.startParam;\n  }\n  /**\n   * @see InitDataParsed.user\n   */\n  get user() {\n    return this.initData.user;\n  }\n}\nconst rs = l(\n  ({ initData: e }) => e ? new ns(e) : void 0\n);\nfunction fn(e) {\n  return Ut().parse(e);\n}\nclass is extends L {\n  constructor(t, s, n) {\n    super({ isOpened: t }, s, { open: \"web_app_open_invoice\" }), this.postEvent = n;\n  }\n  set isOpened(t) {\n    this.set(\"isOpened\", t);\n  }\n  /**\n   * True if invoice is currently opened.\n   */\n  get isOpened() {\n    return this.get(\"isOpened\");\n  }\n  async open(t, s) {\n    if (this.isOpened)\n      throw new Error(\"Invoice is already opened\");\n    let n;\n    if (!s)\n      n = t;\n    else {\n      const { hostname: r, pathname: i } = new URL(t, window.location.href);\n      if (r !== \"t.me\")\n        throw new Error(`Incorrect hostname: ${r}`);\n      const o = i.match(/^\\/(\\$|invoice\\/)([A-Za-z0-9\\-_=]+)$/);\n      if (!o)\n        throw new Error('Link pathname has incorrect format. Expected to receive \"/invoice/{slug}\" or \"/${slug}\"');\n      [, , n] = o;\n    }\n    this.isOpened = !0;\n    try {\n      return (await g({\n        method: \"web_app_open_invoice\",\n        event: \"invoice_closed\",\n        params: { slug: n },\n        postEvent: this.postEvent,\n        capture(r) {\n          return n === r.slug;\n        }\n      })).status;\n    } finally {\n      this.isOpened = !1;\n    }\n  }\n}\nconst os = l(\n  ({ version: e, postEvent: t }) => new is(!1, e, t)\n);\nclass as extends pt {\n  constructor({ postEvent: t, ...s }) {\n    super(s), c(this, \"postEvent\"), c(this, \"on\", (n, r) => n === \"click\" ? y(\"main_button_pressed\", r) : this.state.on(n, r)), c(this, \"off\", (n, r) => n === \"click\" ? z(\"main_button_pressed\", r) : this.state.off(n, r)), this.postEvent = t;\n  }\n  /**\n   * The MainButton background color.\n   */\n  get bgColor() {\n    return this.get(\"bgColor\");\n  }\n  /**\n   * Sends current local state to the Telegram application.\n   */\n  commit() {\n    this.text !== \"\" && this.postEvent(\"web_app_setup_main_button\", {\n      is_visible: this.isVisible,\n      is_active: this.isEnabled,\n      is_progress_visible: this.isLoaderVisible,\n      text: this.text,\n      color: this.bgColor,\n      text_color: this.textColor\n    });\n  }\n  /**\n   * Disables the MainButton.\n   * @see Does not work on Android: https://github.com/Telegram-Mini-Apps/issues/issues/1\n   */\n  disable() {\n    return this.isEnabled = !1, this;\n  }\n  /**\n   * Enables the MainButton.\n   */\n  enable() {\n    return this.isEnabled = !0, this;\n  }\n  /**\n   * Hides the MainButton.\n   */\n  hide() {\n    return this.isVisible = !1, this;\n  }\n  /**\n   * Hides the MainButton loading indicator.\n   */\n  hideLoader() {\n    return this.isLoaderVisible = !1, this;\n  }\n  set isEnabled(t) {\n    this.setParams({ isEnabled: t });\n  }\n  /**\n   * True if the MainButton is enabled.\n   */\n  get isEnabled() {\n    return this.get(\"isEnabled\");\n  }\n  set isLoaderVisible(t) {\n    this.setParams({ isLoaderVisible: t });\n  }\n  /**\n   * True if the MainButton loader is visible.\n   */\n  get isLoaderVisible() {\n    return this.get(\"isLoaderVisible\");\n  }\n  set isVisible(t) {\n    this.setParams({ isVisible: t });\n  }\n  /**\n   * True if the MainButton is visible.\n   */\n  get isVisible() {\n    return this.get(\"isVisible\");\n  }\n  /**\n   * Shows the MainButton.\n   *\n   * Note that opening the Mini App from the attachment menu hides the main button until the\n   * user interacts with the Mini App interface.\n   */\n  show() {\n    return this.isVisible = !0, this;\n  }\n  /**\n   * Shows a loading indicator on the Main Button.\n   */\n  showLoader() {\n    return this.isLoaderVisible = !0, this;\n  }\n  /**\n   * Sets a new MainButton text. Minimal length for the text is 1 symbol, and maximum is 64 symbols.\n   * @param text - a new text.\n   */\n  setText(t) {\n    return this.setParams({ text: t });\n  }\n  /**\n   * Sets a new Main Button text color.\n   * @param textColor - new text color.\n   */\n  setTextColor(t) {\n    return this.setParams({ textColor: t });\n  }\n  /**\n   * Updates current Main Button color.\n   * @param bgColor - color to set.\n   */\n  setBgColor(t) {\n    return this.setParams({ bgColor: t });\n  }\n  /**\n   * Allows setting multiple Main Button parameters.\n   * @param params - Main Button parameters.\n   */\n  setParams(t) {\n    return this.set(t), this.commit(), this;\n  }\n  /**\n   * The MainButton text.\n   */\n  get text() {\n    return this.get(\"text\");\n  }\n  /**\n   * The MainButton text color.\n   */\n  get textColor() {\n    return this.get(\"textColor\");\n  }\n}\nconst cs = l(\n  \"mainButton\",\n  ({\n    postEvent: e,\n    themeParams: t,\n    state: s = {\n      isVisible: !1,\n      isEnabled: !1,\n      text: \"\",\n      isLoaderVisible: !1,\n      textColor: t.buttonTextColor || \"#ffffff\",\n      bgColor: t.buttonColor || \"#000000\"\n    }\n  }) => new as({ ...s, postEvent: e })\n);\nfunction hs() {\n  return lt({\n    contact: w({\n      userId: {\n        type: x(),\n        from: \"user_id\"\n      },\n      phoneNumber: {\n        type: h(),\n        from: \"phone_number\"\n      },\n      firstName: {\n        type: h(),\n        from: \"first_name\"\n      },\n      lastName: {\n        type: h().optional(),\n        from: \"last_name\"\n      }\n    }),\n    authDate: {\n      type: $t(),\n      from: \"auth_date\"\n    },\n    hash: h()\n  }, \"RequestedContact\");\n}\nfunction Zt(e, t) {\n  return (s) => {\n    const [n, r] = t[s];\n    return C(n, r, e);\n  };\n}\nfunction ps(e) {\n  return new Promise((t) => {\n    setTimeout(t, e);\n  });\n}\nclass us extends L {\n  constructor({ postEvent: t, createRequestId: s, version: n, botInline: r, ...i }) {\n    super(i, n, {\n      requestPhoneAccess: \"web_app_request_phone\",\n      requestWriteAccess: \"web_app_request_write_access\",\n      switchInlineQuery: \"web_app_switch_inline_query\",\n      setHeaderColor: \"web_app_set_header_color\",\n      setBackgroundColor: \"web_app_set_background_color\"\n    }), c(this, \"botInline\"), c(this, \"postEvent\"), c(this, \"createRequestId\"), c(this, \"requestPhoneAccessPromise\"), c(this, \"requestWriteAccessPromise\"), c(this, \"supportsParam\"), this.createRequestId = s, this.postEvent = t, this.botInline = r;\n    const o = this.supports.bind(this);\n    this.supports = (a) => o(a) ? a !== \"switchInlineQuery\" || r : !1, this.supportsParam = Zt(n, {\n      \"setHeaderColor.color\": [\"web_app_set_header_color\", \"color\"]\n    });\n  }\n  /**\n   * Attempts to get requested contact.\n   * @param timeout - request timeout.\n   */\n  async getRequestedContact({\n    timeout: t = 1e4\n  } = {}) {\n    return hs().parse(\n      await O(\n        \"getRequestedContact\",\n        {},\n        this.createRequestId(),\n        { postEvent: this.postEvent, timeout: t }\n      )\n    );\n  }\n  /**\n   * The Mini App background color.\n   * @example \"#ffaabb\"\n   */\n  get bgColor() {\n    return this.get(\"bgColor\");\n  }\n  /**\n   * Closes the Mini App.\n   */\n  close() {\n    this.postEvent(\"web_app_close\");\n  }\n  /**\n   * The Mini App header color.\n   * @example \"#ffaabb\"\n   * @example \"bg_color\"\n   */\n  get headerColor() {\n    return this.get(\"headerColor\");\n  }\n  /**\n   * True if the Mini App is currently launched in bot inline mode.\n   */\n  get isBotInline() {\n    return this.botInline;\n  }\n  /**\n   * True if current Mini App background color is recognized as dark.\n   */\n  get isDark() {\n    return Vt(this.bgColor);\n  }\n  /**\n   * Informs the Telegram app that the Mini App is ready to be displayed.\n   *\n   * It is recommended to call this method as early as possible, as soon as all essential\n   * interface elements loaded. Once this method called, the loading placeholder is hidden\n   * and the Mini App shown.\n   *\n   * If the method not called, the placeholder will be hidden only when the page fully loaded.\n   */\n  ready() {\n    this.postEvent(\"web_app_ready\");\n  }\n  /**\n   * Requests current user contact information. In contrary to requestPhoneAccess, this method\n   * returns promise with contact information that rejects in case, user denied access, or request\n   * failed.\n   * @param options - additional options.\n   */\n  async requestContact({ timeout: t = 5e3 } = {}) {\n    try {\n      return await this.getRequestedContact();\n    } catch {\n    }\n    if (await this.requestPhoneAccess() !== \"sent\")\n      throw new Error(\"Access denied.\");\n    const s = Date.now() + t;\n    let n = 50;\n    return Mt(async () => {\n      for (; Date.now() < s; ) {\n        try {\n          return await this.getRequestedContact();\n        } catch {\n        }\n        await ps(n), n += 50;\n      }\n      throw Bt(t);\n    }, t);\n  }\n  /**\n   * Requests current user phone access. Method returns promise, which resolves\n   * status of the request. In case, user accepted the request, Mini App bot will receive\n   * the according notification.\n   *\n   * To obtain the retrieved information instead, utilize the `requestContact` method.\n   * @param options - additional options.\n   * @see requestContact\n   */\n  async requestPhoneAccess(t = {}) {\n    return this.requestPhoneAccessPromise || (this.requestPhoneAccessPromise = g({\n      ...t,\n      method: \"web_app_request_phone\",\n      event: \"phone_requested\",\n      postEvent: this.postEvent\n    }).then(({ status: s }) => s).finally(() => this.requestPhoneAccessPromise = void 0)), this.requestPhoneAccessPromise;\n  }\n  /**\n   * Requests write message access to current user.\n   * @param options - additional options.\n   */\n  async requestWriteAccess(t = {}) {\n    return this.requestWriteAccessPromise || (this.requestWriteAccessPromise = g({\n      ...t,\n      method: \"web_app_request_write_access\",\n      event: \"write_access_requested\",\n      postEvent: this.postEvent\n    }).then(({ status: s }) => s).finally(() => this.requestWriteAccessPromise = void 0)), this.requestWriteAccessPromise;\n  }\n  /**\n   * A method used to send data to the bot. When this method called, a service message sent to\n   * the bot containing the data of the length up to 4096 bytes, and the Mini App closed. See the\n   * field `web_app_data` in the class [Message](https://core.telegram.org/bots/api#message).\n   *\n   * This method is only available for Mini Apps launched via a Keyboard button.\n   * @param data - data to send to bot.\n   * @throws {Error} data has incorrect size.\n   */\n  sendData(t) {\n    const { size: s } = new Blob([t]);\n    if (!s || s > 4096)\n      throw new Error(`Passed data has incorrect size: ${s}`);\n    this.postEvent(\"web_app_data_send\", { data: t });\n  }\n  /**\n   * Updates current Mini App header color.\n   *\n   * @see No effect on desktop: https://github.com/Telegram-Mini-Apps/tma.js/issues/9\n   * @see Works incorrectly in Android: https://github.com/Telegram-Mini-Apps/tma.js/issues/8\n   * @param color - color key or RGB color.\n   */\n  setHeaderColor(t) {\n    this.postEvent(\"web_app_set_header_color\", ct(t) ? { color: t } : { color_key: t }), this.set(\"headerColor\", t);\n  }\n  /**\n   * Updates current Mini App background color.\n   *\n   * @see No effect on desktop: https://github.com/Telegram-Mini-Apps/tma.js/issues/9\n   * @see Works incorrectly in Android: https://github.com/Telegram-Mini-Apps/tma.js/issues/8\n   * @param color - RGB color.\n   */\n  setBgColor(t) {\n    this.postEvent(\"web_app_set_background_color\", { color: t }), this.set(\"bgColor\", t);\n  }\n  /**\n   * Inserts the bot's username and the specified inline query in the current chat's input field.\n   * Query may be empty, in which case only the bot's username will be inserted. The client prompts\n   * the user to choose a specific chat, then opens that chat and inserts the bot's username and\n   * the specified inline query in the input field.\n   * @param text - text which should be inserted in the input after the current bot name. Max\n   * length is 256 symbols.\n   * @param chatTypes - List of chat types which could be chosen to send the message. Could be\n   * empty list.\n   */\n  switchInlineQuery(t, s = []) {\n    if (!this.supports(\"switchInlineQuery\") && !this.isBotInline)\n      throw new Error(\"Method is unsupported because Mini App should be launched in inline mode.\");\n    this.postEvent(\"web_app_switch_inline_query\", { query: t, chat_types: s });\n  }\n}\nconst ls = l(\n  \"miniApp\",\n  ({\n    themeParams: e,\n    botInline: t = !1,\n    state: s = {\n      bgColor: e.bgColor || \"#ffffff\",\n      headerColor: e.headerBgColor || \"#000000\"\n    },\n    ...n\n  }) => new us({ ...n, ...s, botInline: t })\n);\nfunction ds(e) {\n  const t = e.message.trim(), s = (e.title || \"\").trim(), n = e.buttons || [];\n  let r;\n  if (s.length > 64)\n    throw new Error(`Title has incorrect size: ${s.length}`);\n  if (!t.length || t.length > 256)\n    throw new Error(`Message has incorrect size: ${t.length}`);\n  if (n.length > 3)\n    throw new Error(`Buttons have incorrect size: ${n.length}`);\n  return n.length ? r = n.map((i) => {\n    const { id: o = \"\" } = i;\n    if (o.length > 64)\n      throw new Error(`Button ID has incorrect size: ${o}`);\n    if (!i.type || i.type === \"default\" || i.type === \"destructive\") {\n      const a = i.text.trim();\n      if (!a.length || a.length > 64) {\n        const p = i.type || \"default\";\n        throw new Error(`Button text with type \"${p}\" has incorrect size: ${i.text.length}`);\n      }\n      return { ...i, text: a, id: o };\n    }\n    return { ...i, id: o };\n  }) : r = [{ type: \"close\", id: \"\" }], { title: s, message: t, buttons: r };\n}\nclass _s extends L {\n  constructor(t, s, n) {\n    super({ isOpened: t }, s, { open: \"web_app_open_popup\" }), this.postEvent = n;\n  }\n  set isOpened(t) {\n    this.set(\"isOpened\", t);\n  }\n  /**\n   * True if the Popup is opened.\n   */\n  get isOpened() {\n    return this.get(\"isOpened\");\n  }\n  /**\n   * A method that shows a native popup described by the `params` argument.\n   * Promise will be resolved when popup is closed. Resolved value will have\n   * an identifier of pressed button.\n   *\n   * In case, user clicked outside the popup or clicked top right popup close\n   * button, null will be returned.\n   *\n   * @param options - popup parameters.\n   * @throws {Error} Popup is already opened.\n   */\n  async open(t) {\n    if (this.isOpened)\n      throw new Error(\"Popup is already opened.\");\n    this.isOpened = !0;\n    try {\n      const { button_id: s = null } = await g({\n        event: \"popup_closed\",\n        method: \"web_app_open_popup\",\n        postEvent: this.postEvent,\n        params: ds(t)\n      });\n      return s;\n    } finally {\n      this.isOpened = !1;\n    }\n  }\n}\nconst ws = l(\n  ({ postEvent: e, version: t }) => new _s(!1, t, e)\n);\nclass gs extends L {\n  constructor(t, s, n) {\n    super({ isOpened: t }, s, {\n      close: \"web_app_close_scan_qr_popup\",\n      open: \"web_app_open_scan_qr_popup\"\n    }), this.postEvent = n;\n  }\n  /**\n   * Closes scanner.\n   */\n  close() {\n    this.postEvent(\"web_app_close_scan_qr_popup\"), this.isOpened = !1;\n  }\n  set isOpened(t) {\n    this.set(\"isOpened\", t);\n  }\n  /**\n   * Returns true in case, QR scanner is currently opened.\n   */\n  get isOpened() {\n    return this.get(\"isOpened\");\n  }\n  async open(t) {\n    if (this.isOpened)\n      throw new Error(\"QR scanner is already opened.\");\n    const { text: s, capture: n } = (typeof t == \"string\" ? { text: t } : t) || {};\n    this.isOpened = !0;\n    try {\n      const r = (await g({\n        method: \"web_app_open_scan_qr_popup\",\n        event: [\"qr_text_received\", \"scan_qr_popup_closed\"],\n        postEvent: this.postEvent,\n        params: { text: s },\n        capture(i) {\n          return i.event === \"scan_qr_popup_closed\" || !n || n(i.payload);\n        }\n      }) || {}).data || null;\n      return r && this.close(), r;\n    } catch (r) {\n      throw this.isOpened = !1, r;\n    }\n  }\n}\nconst fs = l(\n  ({ version: e, postEvent: t }) => new gs(!1, e, t)\n);\nclass ms extends ut {\n  constructor(t, s, n) {\n    super({ isVisible: t }, s, {\n      show: \"web_app_setup_settings_button\",\n      hide: \"web_app_setup_settings_button\"\n    }), c(this, \"on\", (r, i) => r === \"click\" ? y(\"settings_button_pressed\", i) : this.state.on(r, i)), c(this, \"off\", (r, i) => r === \"click\" ? z(\"settings_button_pressed\", i) : this.state.off(r, i)), this.postEvent = n;\n  }\n  set isVisible(t) {\n    this.set(\"isVisible\", t), this.postEvent(\"web_app_setup_settings_button\", { is_visible: t });\n  }\n  /**\n   * True if the SettingsButton is visible.\n   */\n  get isVisible() {\n    return this.get(\"isVisible\");\n  }\n  /**\n   * Hides the SettingsButton.\n   */\n  hide() {\n    this.isVisible = !1;\n  }\n  /**\n   * Shows the SettingsButton.\n   */\n  show() {\n    this.isVisible = !0;\n  }\n}\nconst bs = l(\n  \"settingsButton\",\n  ({\n    version: e,\n    postEvent: t,\n    state: s = { isVisible: !1 }\n  }) => new ms(s.isVisible, e, t)\n);\nfunction Xt(e) {\n  return Ht().parse(e);\n}\nclass vs extends _t {\n  /**\n   * @since v6.10\n   */\n  get accentTextColor() {\n    return this.get(\"accentTextColor\");\n  }\n  get bgColor() {\n    return this.get(\"bgColor\");\n  }\n  get buttonColor() {\n    return this.get(\"buttonColor\");\n  }\n  get buttonTextColor() {\n    return this.get(\"buttonTextColor\");\n  }\n  get destructiveTextColor() {\n    return this.get(\"destructiveTextColor\");\n  }\n  /**\n   * Returns the copy of the internal state of the current component instance.\n   */\n  getState() {\n    return this.clone();\n  }\n  /**\n   * @since v6.10\n   */\n  get headerBgColor() {\n    return this.get(\"headerBgColor\");\n  }\n  get hintColor() {\n    return this.get(\"hintColor\");\n  }\n  /**\n   * @returns True in case, current color scheme is recognized as dark. This\n   * value is calculated according to theme bg color.\n   */\n  get isDark() {\n    return !this.bgColor || Vt(this.bgColor);\n  }\n  get linkColor() {\n    return this.get(\"linkColor\");\n  }\n  get secondaryBgColor() {\n    return this.get(\"secondaryBgColor\");\n  }\n  /**\n   * @since v6.10\n   */\n  get sectionBgColor() {\n    return this.get(\"sectionBgColor\");\n  }\n  /**\n   * @since v6.10\n   */\n  get sectionHeaderTextColor() {\n    return this.get(\"sectionHeaderTextColor\");\n  }\n  /**\n   * Starts listening to the external theme changes and applies them.\n   * @returns Function to stop listening.\n   */\n  listen() {\n    return y(\"theme_changed\", (t) => {\n      this.set(Xt(t.theme_params));\n    });\n  }\n  /**\n   * @since v6.10\n   */\n  get subtitleTextColor() {\n    return this.get(\"subtitleTextColor\");\n  }\n  get textColor() {\n    return this.get(\"textColor\");\n  }\n}\nconst ys = l(\n  \"themeParams\",\n  ({ themeParams: e, state: t = e, addCleanup: s }) => {\n    const n = new vs(t);\n    return s(n.listen()), n;\n  }\n);\nfunction mn(e = {}) {\n  return g({\n    ...e,\n    method: \"web_app_request_theme\",\n    event: \"theme_changed\"\n  }).then(Xt);\n}\nclass Es extends wt {\n  constructor(t, s, n) {\n    super(t, { readTextFromClipboard: \"web_app_read_text_from_clipboard\" }), c(this, \"supportsParam\"), this.version = t, this.createRequestId = s, this.postEvent = n, this.supportsParam = Zt(t, {\n      \"openLink.tryInstantView\": [\"web_app_open_link\", \"try_instant_view\"]\n    });\n  }\n  /**\n   * Opens a link in an external browser. The Mini App will not be closed.\n   *\n   * Note that this method can be called only in response to the user\n   * interaction with the Mini App interface (e.g. click inside the Mini App\n   * or on the main button).\n   * @param url - URL to be opened.\n   * @param tryInstantView\n   */\n  openLink(t, s) {\n    const n = new URL(t, window.location.href).toString();\n    if (!C(\"web_app_open_link\", this.version)) {\n      window.open(n, \"_blank\");\n      return;\n    }\n    this.postEvent(\"web_app_open_link\", {\n      url: n,\n      ...typeof s == \"boolean\" ? { try_instant_view: s } : {}\n    });\n  }\n  /**\n   * Opens a Telegram link inside Telegram app. The Mini App will be closed. It expects passing\n   * link in full format, with hostname \"t.me\".\n   * @param url - URL to be opened.\n   * @throws {Error} URL has not allowed hostname.\n   */\n  openTelegramLink(t) {\n    const { hostname: s, pathname: n, search: r } = new URL(t, \"https://t.me\");\n    if (s !== \"t.me\")\n      throw new Error(`URL has not allowed hostname: ${s}. Only \"t.me\" is allowed`);\n    if (!C(\"web_app_open_tg_link\", this.version)) {\n      window.location.href = t;\n      return;\n    }\n    this.postEvent(\"web_app_open_tg_link\", { path_full: n + r });\n  }\n  /**\n   * Reads text from clipboard and returns string or null. null is returned\n   * in cases:\n   * - Value in clipboard is not text\n   * - Access to clipboard is not allowed\n   */\n  async readTextFromClipboard() {\n    const t = this.createRequestId(), {\n      data: s = null\n    } = await g({\n      method: \"web_app_read_text_from_clipboard\",\n      event: \"clipboard_text_received\",\n      postEvent: this.postEvent,\n      params: { req_id: t },\n      capture: Dt(t)\n    });\n    return s;\n  }\n  /**\n   * Shares specified URL with the passed to the chats, selected by user. After being called,\n   * it closes the mini application.\n   *\n   * This method uses Telegram's Share Links.\n   * @param url - URL to share.\n   * @param text - text to append after the URL.\n   * @see https://core.telegram.org/api/links#share-links\n   * @see https://core.telegram.org/widgets/share#custom-buttons\n   */\n  shareURL(t, s) {\n    this.openTelegramLink(\n      \"https://t.me/share/url?\" + new URLSearchParams({ url: t, text: s || \"\" }).toString()\n    );\n  }\n}\nconst Ps = l(\n  ({ version: e, postEvent: t, createRequestId: s }) => new Es(e, s, t)\n);\nasync function te(e = {}) {\n  const {\n    is_expanded: t,\n    is_state_stable: s,\n    ...n\n  } = await g({\n    ...e,\n    method: \"web_app_request_viewport\",\n    event: \"viewport_changed\"\n  });\n  return { ...n, isExpanded: t, isStateStable: s };\n}\nfunction q(e) {\n  return e < 0 ? 0 : e;\n}\nclass Rs extends _t {\n  constructor({ postEvent: t, stableHeight: s, height: n, width: r, isExpanded: i }) {\n    super({\n      height: q(n),\n      isExpanded: i,\n      stableHeight: q(s),\n      width: q(r)\n    }), c(this, \"postEvent\"), this.postEvent = t;\n  }\n  /**\n   * Requests viewport information from the Telegram application and updates current Viewport\n   * instance.\n   * @param options - options to request fresh data.\n   */\n  async sync(t) {\n    const { isStateStable: s, ...n } = await te(t);\n    this.set({\n      ...n,\n      stableHeight: s ? n.height : this.get(\"stableHeight\")\n    });\n  }\n  /**\n   * The current height of the **visible area** of the Mini App.\n   *\n   * The application can display just the top part of the Mini App, with its lower part remaining\n   * outside the screen area. From this position, the user can \"pull\" the Mini App to its\n   * maximum height, while the bot can do the same by calling `expand` method. As the position of\n   * the Mini App changes, the current height value of the visible area will be updated  in real\n   * time.\n   *\n   * Please note that the refresh rate of this value is not sufficient to smoothly follow the\n   * lower border of the window. It should not be used to pin interface elements to the bottom\n   * of the visible area. It's more appropriate to use the value of the `stableHeight`\n   * field for this purpose.\n   *\n   * @see stableHeight\n   */\n  get height() {\n    return this.get(\"height\");\n  }\n  /**\n   * The height of the visible area of the Mini App in its last stable state.\n   *\n   * The application can display just the top part of the Mini App, with its lower part remaining\n   * outside the screen area. From this position, the user can \"pull\" the Mini App to its\n   * maximum height, while the application can do the same by calling `expand` method.\n   *\n   * Unlike the value of `height`, the value of `stableHeight` does not change as the position\n   * of the Mini App changes with user gestures or during animations. The value of `stableHeight`\n   * will be updated after all gestures and animations are completed and\n   * the Mini App reaches its final size.\n   *\n   * @see height\n   */\n  get stableHeight() {\n    return this.get(\"stableHeight\");\n  }\n  /**\n   * Starts listening to viewport changes and applies them.\n   * @returns Function to stop listening.\n   */\n  listen() {\n    return y(\"viewport_changed\", (t) => {\n      const {\n        height: s,\n        width: n,\n        is_expanded: r,\n        is_state_stable: i\n      } = t, o = q(s);\n      this.set({\n        height: o,\n        isExpanded: r,\n        width: q(n),\n        ...i ? { stableHeight: o } : {}\n      });\n    });\n  }\n  /**\n   * True if the Mini App is expanded to the maximum available height. Otherwise, if\n   * the Mini App occupies part of the screen and can be expanded to the full height using\n   * `expand` method.\n   * @see expand\n   */\n  get isExpanded() {\n    return this.get(\"isExpanded\");\n  }\n  /**\n   * Current visible area width.\n   */\n  get width() {\n    return this.get(\"width\");\n  }\n  /**\n   * A method that expands the Mini App to the maximum available height. To find out if the Mini\n   * App is expanded to the maximum height, refer to the value of the `isExpanded`.\n   * @see isExpanded\n   */\n  expand() {\n    this.postEvent(\"web_app_expand\"), this.set(\"isExpanded\", !0);\n  }\n  /**\n   * True if the current viewport height is stable and is not going to change in the next moment.\n   */\n  get isStable() {\n    return this.stableHeight === this.height;\n  }\n}\nconst xs = l(\n  \"viewport\",\n  async ({ state: e, platform: t, postEvent: s, addCleanup: n }) => {\n    let r = !1, i = 0, o = 0, a = 0;\n    if (e)\n      r = e.isExpanded, i = e.height, o = e.width, a = e.stableHeight;\n    else if ([\"macos\", \"tdesktop\", \"unigram\", \"webk\", \"weba\", \"web\"].includes(t))\n      r = !0, i = window.innerHeight, o = window.innerWidth, a = window.innerHeight;\n    else {\n      const u = await te({ timeout: 1e3, postEvent: s });\n      r = u.isExpanded, i = u.height, o = u.width, a = u.isStateStable ? i : 0;\n    }\n    const p = new Rs({\n      postEvent: s,\n      height: i,\n      width: o,\n      stableHeight: a,\n      isExpanded: r\n    });\n    return n(p.listen()), p;\n  }\n);\nfunction P(e, t) {\n  document.documentElement.style.setProperty(e, t);\n}\nfunction bn(e, t, s) {\n  s || (s = (a) => `--tg-${a}-color`);\n  const n = s(\"header\"), r = s(\"bg\"), i = () => {\n    const { headerColor: a } = e;\n    if (ct(a))\n      P(n, a);\n    else {\n      const { bgColor: p, secondaryBgColor: u } = t;\n      a === \"bg_color\" && p ? P(n, p) : a === \"secondary_bg_color\" && u && P(n, u);\n    }\n    P(r, e.bgColor);\n  }, o = [\n    t.on(\"change\", i),\n    e.on(\"change\", i)\n  ];\n  return i(), () => o.forEach((a) => a());\n}\nfunction vn(e, t) {\n  t || (t = (n) => `--tg-theme-${n.replace(/[A-Z]/g, (r) => `-${r.toLowerCase()}`)}`);\n  const s = () => {\n    Object.entries(e.getState()).forEach(([n, r]) => {\n      r && P(t(n), r);\n    });\n  };\n  return s(), e.on(\"change\", s);\n}\nfunction yn(e, t) {\n  t || (t = (u) => `--tg-viewport-${u}`);\n  const [\n    s,\n    n,\n    r\n  ] = [\"height\", \"width\", \"stable-height\"].map((u) => t(u)), i = () => P(s, `${e.height}px`), o = () => P(n, `${e.width}px`), a = () => P(r, `${e.stableHeight}px`), p = [\n    e.on(\"change:height\", i),\n    e.on(\"change:width\", o),\n    e.on(\"change:stableHeight\", a)\n  ];\n  return i(), o(), a(), () => p.forEach((u) => u());\n}\nfunction Cs(e = !0) {\n  const t = [\n    y(\"reload_iframe\", () => {\n      B(\"iframe_will_reload\"), window.location.reload();\n    })\n  ], s = () => t.forEach((n) => n());\n  if (e) {\n    const n = document.createElement(\"style\");\n    n.id = \"telegram-custom-styles\", document.head.appendChild(n), t.push(\n      y(\"set_custom_style\", (r) => {\n        n.innerHTML = r;\n      }),\n      () => document.head.removeChild(n)\n    );\n  }\n  return B(\"iframe_ready\", { reload_supported: !0 }), s;\n}\nfunction Ss() {\n  return typeof window > \"u\";\n}\nasync function En() {\n  if (Ot(window))\n    return !0;\n  try {\n    return await g({ method: \"web_app_request_theme\", event: \"theme_changed\", timeout: 100 }), !0;\n  } catch {\n    return !1;\n  }\n}\nfunction Pn(e) {\n  const t = typeof e == \"string\" ? dt(e) : e;\n  Ft(t);\n  function s(r) {\n    if (typeof r == \"string\")\n      try {\n        const { eventType: i } = kt(r);\n        i === \"web_app_request_theme\" && et(\"theme_changed\", {\n          theme_params: JSON.parse(Jt(t.themeParams))\n        }), i === \"web_app_request_viewport\" && et(\"viewport_changed\", {\n          width: window.innerWidth,\n          height: window.innerHeight,\n          is_state_stable: !0,\n          is_expanded: !0\n        });\n      } catch {\n      }\n  }\n  if (ht()) {\n    const r = window.parent.postMessage.bind(window.parent);\n    window.parent.postMessage = (i) => {\n      s(i), r(i);\n    };\n    return;\n  }\n  if (qt(window)) {\n    const r = window.external.notify.bind(window.external);\n    window.external.notify = (i) => {\n      s(i), r(i);\n    };\n    return;\n  }\n  const n = window.TelegramWebviewProxy;\n  window.TelegramWebviewProxy = {\n    ...n || {},\n    postEvent(...r) {\n      s(JSON.stringify({ eventType: r[0], eventData: r[1] })), n && n.postEvent(...r);\n    }\n  };\n}\nfunction Ts(e) {\n  return e instanceof W;\n}\nfunction Rn(e, t) {\n  return Ts(e) && e.type === t;\n}\nfunction J(e, t) {\n  let s, n, r;\n  return typeof e == \"string\" ? s = e : (s = e.pathname === void 0 ? t : e.pathname, n = e.params, r = e.id), Object.freeze({\n    id: r || (Math.random() * 2 ** 14 | 0).toString(16),\n    pathname: s,\n    params: n\n  });\n}\nclass As {\n  constructor(t, s, n = B) {\n    if (c(this, \"history\"), c(this, \"ee\", new D()), c(this, \"attached\", !1), c(this, \"back\", () => this.go(-1)), c(this, \"on\", this.ee.on.bind(this.ee)), c(this, \"off\", this.ee.off.bind(this.ee)), this._index = s, this.postEvent = n, t.length === 0)\n      throw m(ve, \"History should not be empty.\");\n    if (s < 0 || s >= t.length)\n      throw m(\n        ye,\n        \"Index should not be zero and higher or equal than history size.\"\n      );\n    this.history = t.map((r) => J(r, \"\"));\n  }\n  /**\n   * Allows this navigator to control the `BackButton` visibility state. It also tracks the\n   * `BackButton` clicks and calls the `back` method.\n   */\n  attach() {\n    this.attached || (this.attached = !0, this.sync(), y(\"back_button_pressed\", this.back));\n  }\n  /**\n   * Currently active history item.\n   */\n  get current() {\n    return this.history[this.index];\n  }\n  /**\n   * Prevents current navigator from controlling the BackButton visibility state.\n   */\n  detach() {\n    this.attached = !1, z(\"back_button_pressed\", this.back);\n  }\n  /**\n   * Goes to the next history item.\n   */\n  forward() {\n    this.go(1);\n  }\n  /**\n   * Changes currently active history item index by the specified delta. This method doesn't\n   * change index in case, the updated index points to the non-existing history item. This behavior\n   * is preserved until the `fit` argument is specified.\n   * @param delta - index delta.\n   * @param fit - cuts the delta argument to fit the bounds `[0, history.length - 1]`.\n   */\n  go(t, s) {\n    const n = this.index + t, r = Math.min(\n      Math.max(0, n),\n      this.history.length - 1\n    );\n    (n === r || s) && this.replaceAndMove(r, this.history[r]);\n  }\n  /**\n   * Goes to the specified index. Method does nothing in case, passed index is out of bounds.\n   *\n   * If \"fit\" option was specified and index is out of bounds, it will be cut to the nearest\n   * bound.\n   * @param index - target index.\n   * @param fit - cuts the index argument to fit the bounds `[0, history.length - 1]`.\n   */\n  goTo(t, s) {\n    this.go(t - this.index, s);\n  }\n  /**\n   * True if navigator has items before the current item.\n   */\n  get hasPrev() {\n    return this.index > 0;\n  }\n  /**\n   * True if navigator has items after the current item.\n   */\n  get hasNext() {\n    return this.index !== this.history.length - 1;\n  }\n  /**\n   * Currently active history item index.\n   */\n  get index() {\n    return this._index;\n  }\n  /**\n   * Adds a new history item removing all after the current one.\n   * @param item - item to add.\n   */\n  push(t) {\n    this.hasNext && this.history.splice(this.index + 1), this.replaceAndMove(this.index + 1, J(t, this.current.pathname));\n  }\n  /**\n   * Replaces the current history item.\n   * @param item - item to replace the current item with.\n   */\n  replace(t) {\n    this.replaceAndMove(this.index, J(t, this.current.pathname));\n  }\n  /**\n   * Sets history item by the specified index.\n   * @param index - history item index to replace.\n   * @param historyItem - history item to set.\n   */\n  replaceAndMove(t, s) {\n    const n = t - this.index;\n    if (!n && this.current === s)\n      return;\n    const r = this.current;\n    if (this.index !== t) {\n      const i = this._index;\n      this._index = t, this.attached && i > 0 != t > 0 && this.sync();\n    }\n    this.history[t] = s, this.ee.emit(\"change\", {\n      navigator: this,\n      from: r,\n      to: this.current,\n      delta: n\n    });\n  }\n  /**\n   * Actualizes the `BackButton` visibility state.\n   */\n  sync() {\n    this.postEvent(\"web_app_setup_back_button\", { is_visible: !!this.index });\n  }\n}\nfunction F({\n  params: e,\n  ...t\n}) {\n  return { ...e || { hash: \"\", search: \"\" }, ...t };\n}\nfunction M(e, t) {\n  return e.startsWith(t) ? e : `${t}${e}`;\n}\nfunction U(e) {\n  return new URL(\n    typeof e == \"string\" ? e : `${e.pathname || \"\"}${M(e.search || \"\", \"?\")}${M(e.hash || \"\", \"#\")}`,\n    \"http://a\"\n  );\n}\nfunction H(e) {\n  const t = typeof e == \"string\" ? e.startsWith(\"/\") : !!(e.pathname && e.pathname.startsWith(\"/\")), s = U(e);\n  return `${t ? s.pathname : s.pathname.slice(1)}${s.search}${s.hash}`;\n}\nfunction Q(e, t, s) {\n  let n, r;\n  typeof e == \"string\" ? n = e : (n = H(e), s = e.state, r = e.id);\n  const { pathname: i, search: o, hash: a } = new URL(n, `http://a${M(t, \"/\")}`);\n  return { id: r, pathname: i, params: { hash: a, search: o, state: s } };\n}\nasync function N(e) {\n  return e === 0 ? !0 : Promise.race([\n    new Promise((t) => {\n      const s = tt(\"popstate\", () => {\n        s(), t(!0);\n      });\n      window.history.go(e);\n    }),\n    // Usually, it takes about 1ms to emit this event, but we use some buffer.\n    new Promise((t) => {\n      setTimeout(t, 50, !1);\n    })\n  ]);\n}\nasync function Is() {\n  if (window.history.length <= 1 || (window.history.pushState(null, \"\"), await N(1 - window.history.length)))\n    return;\n  let e = await N(-1);\n  for (; e; )\n    e = await N(-1);\n}\nfunction ee(e) {\n  return U(e).pathname;\n}\nconst Pt = 0, Y = 1, Z = 2;\nclass se {\n  constructor(t, s, { postEvent: n, hashMode: r = \"classic\", base: i } = {}) {\n    c(this, \"navigator\"), c(this, \"ee\", new D()), c(this, \"hashMode\"), c(this, \"base\"), c(this, \"attached\", !1), c(this, \"onPopState\", ({ state: o }) => {\n      if (o === null)\n        return this.push(this.parsePath(window.location.href));\n      o === Pt ? window.history.forward() : o === Y && this.back(), o === Z && this.forward();\n    }), c(this, \"onNavigatorChange\", async ({\n      to: o,\n      from: a,\n      delta: p\n    }) => {\n      this.attached && await this.syncHistory(), this.ee.emit(\"change\", {\n        delta: p,\n        from: F(a),\n        to: F(o),\n        navigator: this\n      });\n    }), c(this, \"on\", this.ee.on.bind(this.ee)), c(this, \"off\", this.ee.off.bind(this.ee)), this.navigator = new As(\n      t.map((o) => Q(o, \"/\")),\n      s,\n      n\n    ), this.navigator.on(\"change\", (o) => {\n      this.onNavigatorChange(o);\n    }), this.hashMode = r, this.base = ee(i || \"\");\n  }\n  /**\n   * Attaches current navigator to the browser history allowing navigator to manipulate it.\n   */\n  async attach() {\n    this.attached || (this.attached = !0, this.navigator.attach(), window.addEventListener(\"popstate\", this.onPopState), await this.syncHistory());\n  }\n  /**\n   * Goes back in history by 1.\n   */\n  back() {\n    this.navigator.back();\n  }\n  /**\n   * Detaches current navigator from the browser history.\n   */\n  detach() {\n    this.attached = !1, this.navigator.detach(), window.removeEventListener(\"popstate\", this.onPopState);\n  }\n  /**\n   * Goes forward in history.\n   */\n  forward() {\n    return this.navigator.forward();\n  }\n  /**\n   * Current history cursor.\n   */\n  get index() {\n    return this.navigator.index;\n  }\n  /**\n   * Current history item identifier.\n   */\n  get id() {\n    return this.navigator.current.id;\n  }\n  /**\n   * Changes currently active history item index by the specified delta. This method doesn't\n   * change index in case, the updated index points to the non-existing history item. This behavior\n   * is preserved until the `fit` argument is specified.\n   * @param delta - index delta.\n   * @param fit - cuts the delta argument to fit the bounds `[0, history.length - 1]`.\n   */\n  go(t, s) {\n    return this.navigator.go(t, s);\n  }\n  /**\n   * Goes to the specified index. Method does nothing in case, passed index is out of bounds.\n   *\n   * If \"fit\" option was specified and index is out of bounds, it will be cut to the nearest\n   * bound.\n   * @param index - target index.\n   * @param fit - cuts the index argument to fit the bounds `[0, history.length - 1]`.\n   */\n  goTo(t, s) {\n    this.navigator.goTo(t, s);\n  }\n  /**\n   * Current history item hash.\n   * @see URL.hash\n   * @example\n   * \"\", \"#my-hash\"\n   */\n  get hash() {\n    return (this.navigator.current.params || {}).hash || \"\";\n  }\n  /**\n   * True if navigator has items before the current item.\n   */\n  get hasPrev() {\n    return this.navigator.hasPrev;\n  }\n  /**\n   * True if navigator has items after the current item.\n   */\n  get hasNext() {\n    return this.navigator.hasNext;\n  }\n  /**\n   * Navigation history.\n   */\n  get history() {\n    return this.navigator.history.map(F);\n  }\n  /**\n   * Path, including pathname, search and hash.\n   * @example Pathname only.\n   * \"/pathname\"\n   * @example Pathname + search.\n   * \"/pathname?search\"\n   * @example Pathname + hash.\n   * \"/pathname#hash\"\n   * @example Pathname + search + hash.\n   * \"/pathname?search#hash\"\n   */\n  get path() {\n    return H(this);\n  }\n  /**\n   * Current pathname. Always starts with the slash.\n   * @see URL.pathname\n   * @example\n   * \"/\", \"/abc\"\n   */\n  get pathname() {\n    return this.navigator.current.pathname;\n  }\n  /**\n   * Depending on the current navigation type, parses incoming path and returns it presented as\n   * an object. In other words, this method parses the passed path and returns object, describing\n   * how the navigator \"sees\" it.\n   *\n   * @example Hash mode is omitted.\n   * parsePath('/abc?a=1#hash');\n   * // { pathname: '/abc', search: '?a=1', hash: '#hash' }\n   * parsePath('http://example.com/abc?a=1#hash');\n   * // { pathname: '/abc', search: '?a=1', hash: '#hash' }\n   *\n   * @example Hash mode is enabled.\n   * parsePath('/abc?a=1#tma?is=cool#yeah');\n   * // { pathname: '/tma', search: '?is=cool', hash: '#yeah' }\n   * parsePath('http://example.com/abc?a=1#tma?is=cool#yeah');\n   * // { pathname: '/tma', search: '?is=cool', hash: '#yeah' }\n   */\n  parsePath(t) {\n    let s = U(t);\n    return this.hashMode && (s = U(s.hash.slice(1))), {\n      pathname: s.pathname,\n      search: s.search,\n      hash: s.hash\n    };\n  }\n  push(t, s) {\n    const n = Q(t, this.path), { state: r = s } = n.params;\n    this.navigator.push({ ...n, params: { ...n.params, state: r } });\n  }\n  replace(t, s) {\n    const n = Q(t, this.path), { state: r = s } = n.params;\n    this.navigator.replace({ ...n, params: { ...n.params, state: r } });\n  }\n  /**\n   * Combines the navigator `base` property with the passed path data applying the navigator\n   * navigation mode.\n   * @param value - path presented as string or URLLike.\n   */\n  renderPath(t) {\n    const s = (this.base.length === 1 ? \"\" : this.base) + M(H(t), \"/\");\n    return this.hashMode ? M(s.slice(1), this.hashMode === \"classic\" ? \"#\" : \"#/\") : s;\n  }\n  /**\n   * Synchronizes current navigator state with browser history.\n   */\n  async syncHistory() {\n    window.removeEventListener(\"popstate\", this.onPopState);\n    const { state: t } = this, s = this.renderPath(this);\n    await Is(), this.hasPrev && this.hasNext ? (window.history.replaceState(Y, \"\"), window.history.pushState(t, \"\", s), window.history.pushState(Z, \"\"), await N(-1)) : this.hasPrev ? (window.history.replaceState(Y, \"\"), window.history.pushState(t, \"\", s)) : this.hasNext ? (window.history.replaceState(t, s), window.history.pushState(Z, \"\"), await N(-1)) : (window.history.replaceState(Pt, \"\"), window.history.pushState(t, \"\", s)), window.addEventListener(\"popstate\", this.onPopState);\n  }\n  /**\n   * Current query parameters.\n   * @see URL.search\n   * @example\n   * \"\", \"?\", \"?a=1\"\n   */\n  get search() {\n    return (this.navigator.current.params || {}).search || \"\";\n  }\n  /**\n   * Current history item state.\n   */\n  get state() {\n    return (this.navigator.current.params || {}).state;\n  }\n}\nfunction ks(e) {\n  e || (e = {});\n  const { href: t, hash: s } = window.location;\n  let n = H(\n    e.hashMode === null ? t : s.includes(\"?\") ? s.slice(1) : `?${s.slice(1)}`\n  );\n  const r = e.base ? ee(e.base) : void 0;\n  if (r) {\n    if (!n.startsWith(r))\n      throw m(\n        Ee,\n        `Path \"${n}\" expected to be starting with \"${r}\"`\n      );\n    n = n.slice(r.length);\n  }\n  return new se([n], 0, e);\n}\nfunction xn(e) {\n  const t = e.match(/#(.+)/);\n  return t ? t[1] : null;\n}\nfunction qs(e, t) {\n  if (Qt()) {\n    const s = sessionStorage.getItem(e);\n    if (s)\n      try {\n        const { index: n, history: r } = JSON.parse(s);\n        return new se(\n          r,\n          n,\n          t\n        );\n      } catch (n) {\n        console.error(\"Unable to restore hash navigator state.\", n);\n      }\n  }\n  return ks(t);\n}\nfunction Cn(e, t) {\n  const s = qs(e, t), n = () => sessionStorage.setItem(e, JSON.stringify({\n    index: s.index,\n    history: s.history\n  }));\n  return s.on(\"change\", n), n(), s;\n}\nfunction d(e, t) {\n  function s(n) {\n    return function(i, o, a) {\n      return (p) => {\n        const u = {\n          ...p,\n          [i]: n(o)\n        };\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(a, { ...u });\n      };\n    };\n  }\n  return [s(e), s(t)];\n}\nconst ne = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(void 0);\nfunction Os() {\n  const e = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ne);\n  if (!e)\n    throw new Error(\"useSDK was used outside the SDKProvider.\");\n  return e;\n}\nfunction _(e) {\n  function t(n) {\n    const r = Os(), [i, o] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\n      n ? void 0 : () => {\n        if (Ss())\n          throw new Error(\"Using hooks on the server side, you must explicitly specify ssr = true option\");\n        return r.use(e);\n      }\n    );\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n      o(r.use(e));\n    }, [r]), i;\n  }\n  function s(n) {\n    const r = t(n);\n    if (r) {\n      if (\"error\" in r)\n        throw r.error;\n      return r.result;\n    }\n  }\n  return [t, s];\n}\nconst [Ns, Ds] = _(Ge), [Sn, Tn] = d(\n  Ns,\n  Ds\n), [Bs, Ms] = _(Ke), [An, In] = d(\n  Bs,\n  Ms\n), [Vs, Ls] = _(Fe), [kn, qn] = d(\n  Vs,\n  Ls\n), [$s, Us] = _(ts), [On, Nn] = d(\n  $s,\n  Us\n), [Hs, Ws] = _(ss), [Dn, Bn] = d(\n  Hs,\n  Ws\n), [Gs, js] = _(rs), [Mn, Vn] = d(Gs, js), [zs, Ks] = _(os), [Ln, $n] = d(zs, Ks), [Js, Fs] = _(cs), [Un, Hn] = d(Js, Fs), [Qs, Ys] = _(ls), [Wn, Gn] = d(Qs, Ys), [Zs, Xs] = _(ws), [jn, zn] = d(Zs, Xs), [tn, en] = _(fs), [Kn, Jn] = d(tn, en), [sn, nn] = _(bs), [Fn, Qn] = d(\n  sn,\n  nn\n), [rn, on] = _(ys), [Yn, Zn] = d(rn, on);\nfunction Xn(e) {\n  const [t, s] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(() => e ? void 0 : nt());\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    e && s(nt());\n  }, []), t;\n}\nconst [an, cn] = _(Ps), [tr, er] = d(an, cn), [hn, pn] = _(xs), [sr, nr] = d(hn, pn);\nfunction rr({ children: e, acceptCustomStyles: t, debug: s }) {\n  const n = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(!0), [r, i] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(/* @__PURE__ */ new Map()), o = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(r), a = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n    (u) => {\n      n.current && i((S) => (u && u(S), new Map(S)));\n    },\n    []\n  ), p = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => ({\n    use(u, ...S) {\n      const gt = r.get(u);\n      if (gt)\n        return gt;\n      let b, K;\n      try {\n        b = u(...S);\n      } catch (f) {\n        K = f;\n      }\n      function $(f) {\n        return r.set(u, f), f;\n      }\n      if (K)\n        return $({ error: K });\n      let I;\n      if (Array.isArray(b) && (I = b[1], b = b[0]), !b)\n        return $({ result: b, cleanup: I });\n      function ft(f) {\n        if (\"on\" in f) {\n          const k = f.on(\"change\", () => a()), mt = I;\n          I = () => {\n            mt && mt(), k();\n          };\n        }\n        return { result: f, cleanup: I };\n      }\n      return b instanceof Promise ? (b.then(\n        (f) => a((k) => k.set(u, ft(f))),\n        (f) => a((k) => k.set(u, { error: f }))\n      ), $({})) : $(ft(b));\n    }\n  }), [r]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => (n.current = !0, () => {\n    n.current = !1;\n  }), []), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (ht())\n      return Cs(t);\n  }, [t]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    le(s || !1);\n  }, [s]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    o.current = r;\n  }, [r]), (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => () => {\n    o.current.forEach((u) => {\n      \"cleanup\" in u && u.cleanup && u.cleanup();\n    });\n  }, []), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ne.Provider, { value: p, children: e });\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRtYS5qcy9zZGstcmVhY3QvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE4QztBQUNnRztBQUM5SSxzRUFBc0UsMERBQTBEO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssZUFBZSwyQkFBMkIsdUNBQXVDLGVBQWU7QUFDckc7QUFDQSxXQUFXLEVBQUUsU0FBUyxXQUFXO0FBQ2pDLFNBQVMsR0FBRyw0QkFBNEI7QUFDeEM7QUFDQSxTQUFTLEdBQUcsRUFBRSxhQUFhLEdBQUcsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE9BQU87QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkMsa0NBQWtDLHNCQUFzQixJQUFJLFNBQVM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsY0FBYyw2QkFBNkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsK0NBQStDLEVBQUU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osd0NBQXdDO0FBQ3hDLFVBQVUseUJBQXlCO0FBQ25DLGlDQUFpQyxvQkFBb0IsSUFBSSxVQUFVO0FBQ25FLCtDQUErQyw0QkFBNEI7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDRCQUE0QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEVBQUUsd0NBQXdDLEVBQUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixFQUFFLFFBQVEsRUFBRSwrQ0FBK0MsRUFBRTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBLG1DQUFtQyxFQUFFO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEtBQUssbUNBQW1DO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxTQUFTO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDRDQUE0QyxTQUFTLGdIQUFnSCxFQUFFO0FBQ3ZLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw0RUFBNEUsZUFBZTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxnQkFBZ0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckYsR0FBRztBQUNIO0FB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QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaURBQWlELElBQUk7QUFDM0UsMElBQTBJLFVBQVU7QUFDcEo7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGVBQWU7QUFDaEQsMEJBQTBCLGdCQUFnQix5QkFBeUI7QUFDbkU7QUFDQTtBQUNBLGlDQUFpQyxlQUFlO0FBQ2hELDZCQUE2QixnQkFBZ0IseUJBQXlCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVSxtQkFBbUI7QUFDN0I7QUFDQSxpRUFBaUUsV0FBVztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsRUFBRSxrQ0FBa0MsRUFBRTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzREFBRSxNQUFNLE1BQU07QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0RBQUU7QUFDYjtBQUNBLFlBQVksaURBQUU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsK0NBQUU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnREFBQztBQUNaO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtDQUFFO0FBQ25CLFNBQVMsZ0RBQUM7QUFDVjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsY0FBYyw4Q0FBOEM7QUFDNUQsWUFBWSw2Q0FBRSxlQUFlLCtDQUFFLGlDQUFpQyw2Q0FBRSxTQUFTLGtEQUFFO0FBQzdFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxTQUFTLDhDQUFFO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFVBQVU7QUFDN0MsYUFBYTtBQUNiO0FBQ0EsR0FBRztBQUNILFNBQVMsZ0RBQUM7QUFDVjtBQUNBLEdBQUcsUUFBUSxnREFBQztBQUNaO0FBQ0E7QUFDQSxHQUFHLFFBQVEsZ0RBQUM7QUFDWjtBQUNBLEdBQUcsUUFBUSxnREFBQztBQUNaO0FBQ0EsR0FBRyxRQUFRLGdEQUFDO0FBQ1o7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHLHVCQUF1QixzREFBRSxnQkFBZ0IsdUJBQXVCO0FBQ25FO0FBdUtFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iZWV2ZXJzZS1tYWluLWRldi10bWEvLi9ub2RlX21vZHVsZXMvQHRtYS5qcy9zZGstcmVhY3QvZGlzdC9pbmRleC5qcz8yZGQ3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeCBhcyBSdCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyByZSwgdXNlQ29udGV4dCBhcyBpZSwgdXNlU3RhdGUgYXMgcnQsIHVzZUVmZmVjdCBhcyBSLCB1c2VSZWYgYXMgYnQsIHVzZUNhbGxiYWNrIGFzIG9lLCB1c2VNZW1vIGFzIGFlIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgY2UgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIGhlID0gKGUsIHQsIHMpID0+IHQgaW4gZSA/IGNlKGUsIHQsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IHMgfSkgOiBlW3RdID0gcywgYyA9IChlLCB0LCBzKSA9PiBoZShlLCB0eXBlb2YgdCAhPSBcInN5bWJvbFwiID8gdCArIFwiXCIgOiB0LCBzKTtcbmZ1bmN0aW9uIHh0KGUsIHQpIHtcbiAgbGV0IHM7XG4gIGNvbnN0IG4gPSAoKSA9PiB7XG4gICAgcyAhPT0gdm9pZCAwICYmIHQgJiYgdChzKSwgcyA9IHZvaWQgMDtcbiAgfTtcbiAgcmV0dXJuIFsoKSA9PiBzID09PSB2b2lkIDAgPyBzID0gZShuKSA6IHMsIG5dO1xufVxuZnVuY3Rpb24gQ3QoZSkge1xuICBjb25zdCB0ID0gaigpLCB7IGNvdW50OiBzIH0gPSB0O1xuICB0LnVuc3Vic2NyaWJlKGUpLCBzICYmICF0LmNvdW50ICYmIEFlKCk7XG59XG5mdW5jdGlvbiBwZShlKSB7XG4gIHJldHVybiBqKCkuc3Vic2NyaWJlKGUpLCAoKSA9PiBDdChlKTtcbn1cbmNsYXNzIHVlIHtcbiAgY29uc3RydWN0b3IodCwgcyA9IHt9KSB7XG4gICAgdGhpcy5zY29wZSA9IHQsIHRoaXMub3B0aW9ucyA9IHM7XG4gIH1cbiAgLyoqXG4gICAqIFByaW50cyBtZXNzYWdlIGludG8gYSBjb25zb2xlIGluIGNhc2UsIGxvZ2dlciBpcyBjdXJyZW50bHkgZW5hYmxlZC5cbiAgICogQHBhcmFtIGxldmVsIC0gbG9nIGxldmVsLlxuICAgKiBAcGFyYW0gYXJncyAtIGFyZ3VtZW50cy5cbiAgICovXG4gIHByaW50KHQsIC4uLnMpIHtcbiAgICBjb25zdCBuID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIHIgPSBJbnRsLkRhdGVUaW1lRm9ybWF0KFwiZW4tR0JcIiwge1xuICAgICAgaG91cjogXCIyLWRpZ2l0XCIsXG4gICAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxuICAgICAgc2Vjb25kOiBcIjItZGlnaXRcIixcbiAgICAgIGZyYWN0aW9uYWxTZWNvbmREaWdpdHM6IDMsXG4gICAgICB0aW1lWm9uZTogXCJVVENcIlxuICAgIH0pLmZvcm1hdChuKSwgeyB0ZXh0Q29sb3I6IGksIGJnQ29sb3I6IG8gfSA9IHRoaXMub3B0aW9ucywgYSA9IFwiZm9udC13ZWlnaHQ6IGJvbGQ7cGFkZGluZzogMCA1cHg7Ym9yZGVyLXJhZGl1czo1cHhcIjtcbiAgICBjb25zb2xlW3RdKFxuICAgICAgYCVjJHtyfSVjIC8gJWMke3RoaXMuc2NvcGV9YCxcbiAgICAgIGAke2F9O2JhY2tncm91bmQtY29sb3I6IGxpZ2h0Ymx1ZTtjb2xvcjpibGFja2AsXG4gICAgICBcIlwiLFxuICAgICAgYCR7YX07JHtpID8gYGNvbG9yOiR7aX07YCA6IFwiXCJ9JHtvID8gYGJhY2tncm91bmQtY29sb3I6JHtvfWAgOiBcIlwifWAsXG4gICAgICAuLi5zXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogUHJpbnRzIGVycm9yIG1lc3NhZ2UgaW50byBhIGNvbnNvbGUuXG4gICAqIEBwYXJhbSBhcmdzXG4gICAqL1xuICBlcnJvciguLi50KSB7XG4gICAgdGhpcy5wcmludChcImVycm9yXCIsIC4uLnQpO1xuICB9XG4gIC8qKlxuICAgKiBQcmludHMgbG9nIG1lc3NhZ2UgaW50byBhIGNvbnNvbGUuXG4gICAqIEBwYXJhbSBhcmdzXG4gICAqL1xuICBsb2coLi4udCkge1xuICAgIHRoaXMucHJpbnQoXCJsb2dcIiwgLi4udCk7XG4gIH1cbn1cbmNvbnN0IGl0ID0gbmV3IHVlKFwiU0RLXCIsIHtcbiAgYmdDb2xvcjogXCJmb3Jlc3RncmVlblwiLFxuICB0ZXh0Q29sb3I6IFwid2hpdGVcIlxufSk7XG5sZXQgWCA9ICExO1xuY29uc3QgdnQgPSAoeyBuYW1lOiBlLCBwYXlsb2FkOiB0IH0pID0+IHtcbiAgaXQubG9nKFwiRXZlbnQgcmVjZWl2ZWQ6XCIsIHQgPyB7IG5hbWU6IGUsIHBheWxvYWQ6IHQgfSA6IHsgbmFtZTogZSB9KTtcbn07XG5mdW5jdGlvbiBsZShlKSB7XG4gIFggIT09IGUgJiYgKFggPSBlLCBlID8gcGUodnQpIDogQ3QodnQpKTtcbn1cbmZ1bmN0aW9uIGRlKC4uLmUpIHtcbiAgWCAmJiBpdC5sb2coLi4uZSk7XG59XG5jbGFzcyBEIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgYyh0aGlzLCBcImxpc3RlbmVyc1wiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKSwgYyh0aGlzLCBcImxpc3RlbmVyc0NvdW50XCIsIDApLCBjKHRoaXMsIFwic3Vic2NyaWJlTGlzdGVuZXJzXCIsIFtdKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgZXZlbnQgbGlzdGVuZXJzLlxuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMuY2xlYXIoKSwgdGhpcy5zdWJzY3JpYmVMaXN0ZW5lcnMgPSBbXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBjb3VudCBvZiBib3VuZCBsaXN0ZW5lcnMuXG4gICAqL1xuICBnZXQgY291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzQ291bnQgKyB0aGlzLnN1YnNjcmliZUxpc3RlbmVycy5sZW5ndGg7XG4gIH1cbiAgZW1pdCh0LCAuLi5zKSB7XG4gICAgdGhpcy5zdWJzY3JpYmVMaXN0ZW5lcnMuZm9yRWFjaCgobikgPT4gbih7XG4gICAgICBldmVudDogdCxcbiAgICAgIGFyZ3M6IHNcbiAgICB9KSksICh0aGlzLmxpc3RlbmVycy5nZXQodCkgfHwgW10pLmZvckVhY2goKFtuLCByXSkgPT4ge1xuICAgICAgbiguLi5zKSwgciAmJiB0aGlzLm9mZih0LCBuKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBuZXcgZXZlbnQgbGlzdGVuZXIuXG4gICAqIEBwYXJhbSBldmVudCAtIGV2ZW50IG5hbWUuXG4gICAqIEBwYXJhbSBsaXN0ZW5lciAtIGV2ZW50IGxpc3RlbmVyLlxuICAgKiBAcGFyYW0gb25jZSAtIHNob3VsZCBsaXN0ZW5lciBiZSBjYWxsZWQgb25seSBvbmNlLlxuICAgKiBAcmV0dXJucyBGdW5jdGlvbiB0byByZW1vdmUgYm91bmQgZXZlbnQgbGlzdGVuZXIuXG4gICAqL1xuICBvbih0LCBzLCBuKSB7XG4gICAgbGV0IHIgPSB0aGlzLmxpc3RlbmVycy5nZXQodCk7XG4gICAgcmV0dXJuIHIgfHwgdGhpcy5saXN0ZW5lcnMuc2V0KHQsIHIgPSBbXSksIHIucHVzaChbcywgbl0pLCB0aGlzLmxpc3RlbmVyc0NvdW50ICs9IDEsICgpID0+IHRoaXMub2ZmKHQsIHMpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVyLiBJbiBjYXNlLCBzcGVjaWZpZWQgbGlzdGVuZXIgd2FzIGJvdW5kIHNldmVyYWwgdGltZXMsIGl0IHJlbW92ZXNcbiAgICogb25seSBhIHNpbmdsZSBvbmUuXG4gICAqIEBwYXJhbSBldmVudCAtIGV2ZW50IG5hbWUuXG4gICAqIEBwYXJhbSBsaXN0ZW5lciAtIGV2ZW50IGxpc3RlbmVyLlxuICAgKi9cbiAgb2ZmKHQsIHMpIHtcbiAgICBjb25zdCBuID0gdGhpcy5saXN0ZW5lcnMuZ2V0KHQpIHx8IFtdO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgbi5sZW5ndGg7IHIgKz0gMSlcbiAgICAgIGlmIChzID09PSBuW3JdWzBdKSB7XG4gICAgICAgIG4uc3BsaWNlKHIsIDEpLCB0aGlzLmxpc3RlbmVyc0NvdW50IC09IDE7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgfVxuICAvKipcbiAgICogQWRkcyBhIG5ldyBldmVudCBsaXN0ZW5lciBmb3IgYWxsIGV2ZW50cy5cbiAgICogQHBhcmFtIGxpc3RlbmVyIC0gZXZlbnQgbGlzdGVuZXIuXG4gICAqIEByZXR1cm5zIEZ1bmN0aW9uIHRvIHJlbW92ZSBldmVudCBsaXN0ZW5lci5cbiAgICovXG4gIHN1YnNjcmliZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuc3Vic2NyaWJlTGlzdGVuZXJzLnB1c2godCksICgpID0+IHRoaXMudW5zdWJzY3JpYmUodCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgZ2xvYmFsIGV2ZW50IGxpc3RlbmVyLiBJbiBjYXNlLCBzcGVjaWZpZWQgbGlzdGVuZXIgd2FzIGJvdW5kIHNldmVyYWwgdGltZXMsIGl0IHJlbW92ZXNcbiAgICogb25seSBhIHNpbmdsZSBvbmUuXG4gICAqIEBwYXJhbSBsaXN0ZW5lciAtIGV2ZW50IGxpc3RlbmVyLlxuICAgKi9cbiAgdW5zdWJzY3JpYmUodCkge1xuICAgIGZvciAobGV0IHMgPSAwOyBzIDwgdGhpcy5zdWJzY3JpYmVMaXN0ZW5lcnMubGVuZ3RoOyBzICs9IDEpXG4gICAgICBpZiAodGhpcy5zdWJzY3JpYmVMaXN0ZW5lcnNbc10gPT09IHQpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVMaXN0ZW5lcnMuc3BsaWNlKHMsIDEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHR0KGUsIHQsIHMpIHtcbiAgcmV0dXJuIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGUsIHQsIHMpLCAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLCB0LCBzKTtcbn1cbmZ1bmN0aW9uIG90KC4uLmUpIHtcbiAgbGV0IHQgPSAhMTtcbiAgY29uc3QgcyA9IFsuLi5lXTtcbiAgcmV0dXJuIFtcbiAgICAobikgPT4gIXQgJiYgcy5wdXNoKG4pLFxuICAgICgpID0+IHtcbiAgICAgIHQgfHwgKHQgPSAhMCwgcy5mb3JFYWNoKChuKSA9PiBuKCkpKTtcbiAgICB9LFxuICAgIHRcbiAgXTtcbn1cbmNsYXNzIFcgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHQsIHMsIG4pIHtcbiAgICBzdXBlcihzLCB7IGNhdXNlOiBuIH0pLCB0aGlzLnR5cGUgPSB0LCBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgVy5wcm90b3R5cGUpO1xuICB9XG59XG5mdW5jdGlvbiBtKGUsIHQsIHMpIHtcbiAgcmV0dXJuIG5ldyBXKGUsIHQsIHMpO1xufVxuY29uc3QgX2UgPSBcIkVSUl9NRVRIT0RfVU5TVVBQT1JURURcIiwgd2UgPSBcIkVSUl9NRVRIT0RfUEFSQU1FVEVSX1VOU1VQUE9SVEVEXCIsIGdlID0gXCJFUlJfVU5LTk9XTl9FTlZcIiwgZmUgPSBcIkVSUl9JTlZPS0VfQ1VTVE9NX01FVEhPRF9SRVNQT05TRVwiLCBtZSA9IFwiRVJSX1RJTUVEX09VVFwiLCBiZSA9IFwiRVJSX1VORVhQRUNURURfVFlQRVwiLCBTdCA9IFwiRVJSX1BBUlNFXCIsIHZlID0gXCJFUlJfTkFWSUdBVElPTl9MSVNUX0VNUFRZXCIsIHllID0gXCJFUlJfTkFWSUdBVElPTl9DVVJTT1JfSU5WQUxJRFwiLCBkbiA9IFwiRVJSX05BVklHQVRJT05fSVRFTV9JTlZBTElEXCIsIF9uID0gXCJFUlJfU1NSX0lOSVRcIiwgRWUgPSBcIkVSUl9JTlZBTElEX1BBVEhfQkFTRVwiO1xuZnVuY3Rpb24gVCgpIHtcbiAgcmV0dXJuIG0oYmUsIFwiVmFsdWUgaGFzIHVuZXhwZWN0ZWQgdHlwZVwiKTtcbn1cbmNsYXNzIEcge1xuICBjb25zdHJ1Y3Rvcih0LCBzLCBuKSB7XG4gICAgdGhpcy5wYXJzZXIgPSB0LCB0aGlzLmlzT3B0aW9uYWwgPSBzLCB0aGlzLnR5cGUgPSBuO1xuICB9XG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBwYXJzZSBwYXNzZWQgdmFsdWVcbiAgICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gcGFyc2UuXG4gICAqIEB0aHJvd3Mge1NES0Vycm9yfSBFUlJfUEFSU0VcbiAgICogQHNlZSBFUlJfUEFSU0VcbiAgICovXG4gIHBhcnNlKHQpIHtcbiAgICBpZiAoISh0aGlzLmlzT3B0aW9uYWwgJiYgdCA9PT0gdm9pZCAwKSlcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlcih0KTtcbiAgICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgICAgdGhyb3cgbShcbiAgICAgICAgICBTdCxcbiAgICAgICAgICBgVW5hYmxlIHRvIHBhcnNlIHZhbHVlJHt0aGlzLnR5cGUgPyBgIGFzICR7dGhpcy50eXBlfWAgOiBcIlwifWAsXG4gICAgICAgICAgc1xuICAgICAgICApO1xuICAgICAgfVxuICB9XG4gIG9wdGlvbmFsKCkge1xuICAgIHJldHVybiB0aGlzLmlzT3B0aW9uYWwgPSAhMCwgdGhpcztcbiAgfVxufVxuZnVuY3Rpb24gQShlLCB0KSB7XG4gIHJldHVybiAoKSA9PiBuZXcgRyhlLCAhMSwgdCk7XG59XG5jb25zdCBFID0gQSgoZSkgPT4ge1xuICBpZiAodHlwZW9mIGUgPT0gXCJib29sZWFuXCIpXG4gICAgcmV0dXJuIGU7XG4gIGNvbnN0IHQgPSBTdHJpbmcoZSk7XG4gIGlmICh0ID09PSBcIjFcIiB8fCB0ID09PSBcInRydWVcIilcbiAgICByZXR1cm4gITA7XG4gIGlmICh0ID09PSBcIjBcIiB8fCB0ID09PSBcImZhbHNlXCIpXG4gICAgcmV0dXJuICExO1xuICB0aHJvdyBUKCk7XG59LCBcImJvb2xlYW5cIik7XG5mdW5jdGlvbiBUdChlLCB0KSB7XG4gIGNvbnN0IHMgPSB7fTtcbiAgZm9yIChjb25zdCBuIGluIGUpIHtcbiAgICBjb25zdCByID0gZVtuXTtcbiAgICBpZiAoIXIpXG4gICAgICBjb250aW51ZTtcbiAgICBsZXQgaSwgbztcbiAgICBpZiAodHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiIHx8IFwicGFyc2VcIiBpbiByKVxuICAgICAgaSA9IG4sIG8gPSB0eXBlb2YgciA9PSBcImZ1bmN0aW9uXCIgPyByIDogci5wYXJzZS5iaW5kKHIpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgeyB0eXBlOiBhIH0gPSByO1xuICAgICAgaSA9IHIuZnJvbSB8fCBuLCBvID0gdHlwZW9mIGEgPT0gXCJmdW5jdGlvblwiID8gYSA6IGEucGFyc2UuYmluZChhKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGEgPSBvKHQoaSkpO1xuICAgICAgYSAhPT0gdm9pZCAwICYmIChzW25dID0gYSk7XG4gICAgfSBjYXRjaCAoYSkge1xuICAgICAgdGhyb3cgbShTdCwgYFVuYWJsZSB0byBwYXJzZSBmaWVsZCBcIiR7bn1cImAsIGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIGF0KGUpIHtcbiAgbGV0IHQgPSBlO1xuICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIiAmJiAodCA9IEpTT04ucGFyc2UodCkpLCB0eXBlb2YgdCAhPSBcIm9iamVjdFwiIHx8IHQgPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheSh0KSlcbiAgICB0aHJvdyBUKCk7XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gdyhlLCB0KSB7XG4gIHJldHVybiBuZXcgRygocykgPT4ge1xuICAgIGNvbnN0IG4gPSBhdChzKTtcbiAgICByZXR1cm4gVHQoZSwgKHIpID0+IG5bcl0pO1xuICB9LCAhMSwgdCk7XG59XG5jb25zdCB4ID0gQSgoZSkgPT4ge1xuICBpZiAodHlwZW9mIGUgPT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4gZTtcbiAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCB0ID0gTnVtYmVyKGUpO1xuICAgIGlmICghTnVtYmVyLmlzTmFOKHQpKVxuICAgICAgcmV0dXJuIHQ7XG4gIH1cbiAgdGhyb3cgVCgpO1xufSwgXCJudW1iZXJcIik7XG5mdW5jdGlvbiBjdChlKSB7XG4gIHJldHVybiAvXiNbXFxkYS1mXXs2fSQvaS50ZXN0KGUpO1xufVxuZnVuY3Rpb24gUGUoZSkge1xuICByZXR1cm4gL14jW1xcZGEtZl17M30kL2kudGVzdChlKTtcbn1cbmZ1bmN0aW9uIEF0KGUpIHtcbiAgY29uc3QgdCA9IGUucmVwbGFjZSgvXFxzL2csIFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChjdCh0KSlcbiAgICByZXR1cm4gdDtcbiAgaWYgKFBlKHQpKSB7XG4gICAgbGV0IG4gPSBcIiNcIjtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IDM7IHIgKz0gMSlcbiAgICAgIG4gKz0gdFsxICsgcl0ucmVwZWF0KDIpO1xuICAgIHJldHVybiBuO1xuICB9XG4gIGNvbnN0IHMgPSB0Lm1hdGNoKC9ecmdiXFwoKFxcZHsxLDN9KSwoXFxkezEsM30pLChcXGR7MSwzfSlcXCkkLykgfHwgdC5tYXRjaCgvXnJnYmFcXCgoXFxkezEsM30pLChcXGR7MSwzfSksKFxcZHsxLDN9KSxcXGR7MSwzfVxcKSQvKTtcbiAgaWYgKCFzKVxuICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWUgXCIke2V9XCIgZG9lcyBub3Qgc2F0aXNmeSBhbnkgb2Yga25vd24gUkdCIGZvcm1hdHMuYCk7XG4gIHJldHVybiBzLnNsaWNlKDEpLnJlZHVjZSgobiwgcikgPT4ge1xuICAgIGNvbnN0IGkgPSBwYXJzZUludChyLCAxMCkudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBuICsgKGkubGVuZ3RoID09PSAxID8gXCIwXCIgOiBcIlwiKSArIGk7XG4gIH0sIFwiI1wiKTtcbn1cbmNvbnN0IGggPSBBKChlKSA9PiB7XG4gIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBlID09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIGUudG9TdHJpbmcoKTtcbiAgdGhyb3cgVCgpO1xufSwgXCJzdHJpbmdcIiksIEl0ID0gQSgoZSkgPT4gQXQoaCgpLnBhcnNlKGUpKSwgXCJyZ2JcIik7XG5mdW5jdGlvbiBrdChlKSB7XG4gIHJldHVybiB3KHtcbiAgICBldmVudFR5cGU6IGgoKSxcbiAgICBldmVudERhdGE6ICh0KSA9PiB0XG4gIH0pLnBhcnNlKGUpO1xufVxuZnVuY3Rpb24gUmUoKSB7XG4gIFtcIlRlbGVncmFtR2FtZVByb3h5X3JlY2VpdmVFdmVudFwiLCBcIlRlbGVncmFtR2FtZVByb3h5XCIsIFwiVGVsZWdyYW1cIl0uZm9yRWFjaCgoZSkgPT4ge1xuICAgIGRlbGV0ZSB3aW5kb3dbZV07XG4gIH0pO1xufVxuZnVuY3Rpb24gZXQoZSwgdCkge1xuICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgTWVzc2FnZUV2ZW50KFwibWVzc2FnZVwiLCB7XG4gICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoeyBldmVudFR5cGU6IGUsIGV2ZW50RGF0YTogdCB9KSxcbiAgICAvLyBXZSBzcGVjaWZ5IHdpbmRvdy5wYXJlbnQgdG8gaW1pdGF0ZSB0aGUgY2FzZSwgdGhlIHBhcmVudCBpZnJhbWUgc2VudCB1cyB0aGlzIGV2ZW50LlxuICAgIHNvdXJjZTogd2luZG93LnBhcmVudFxuICB9KSk7XG59XG5mdW5jdGlvbiB4ZSgpIHtcbiAgW1xuICAgIFtcIlRlbGVncmFtR2FtZVByb3h5X3JlY2VpdmVFdmVudFwiXSxcbiAgICAvLyBXaW5kb3dzIFBob25lLlxuICAgIFtcIlRlbGVncmFtR2FtZVByb3h5XCIsIFwicmVjZWl2ZUV2ZW50XCJdLFxuICAgIC8vIERlc2t0b3AuXG4gICAgW1wiVGVsZWdyYW1cIiwgXCJXZWJWaWV3XCIsIFwicmVjZWl2ZUV2ZW50XCJdXG4gICAgLy8gQW5kcm9pZCBhbmQgaU9TLlxuICBdLmZvckVhY2goKGUpID0+IHtcbiAgICBsZXQgdCA9IHdpbmRvdztcbiAgICBlLmZvckVhY2goKHMsIG4sIHIpID0+IHtcbiAgICAgIGlmIChuID09PSByLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdFtzXSA9IGV0O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzIGluIHQgfHwgKHRbc10gPSB7fSksIHQgPSB0W3NdO1xuICAgIH0pO1xuICB9KTtcbn1cbmNvbnN0IENlID0ge1xuICBjbGlwYm9hcmRfdGV4dF9yZWNlaXZlZDogdyh7XG4gICAgcmVxX2lkOiBoKCksXG4gICAgZGF0YTogKGUpID0+IGUgPT09IG51bGwgPyBlIDogaCgpLm9wdGlvbmFsKCkucGFyc2UoZSlcbiAgfSksXG4gIGN1c3RvbV9tZXRob2RfaW52b2tlZDogdyh7XG4gICAgcmVxX2lkOiBoKCksXG4gICAgcmVzdWx0OiAoZSkgPT4gZSxcbiAgICBlcnJvcjogaCgpLm9wdGlvbmFsKClcbiAgfSksXG4gIGludm9pY2VfY2xvc2VkOiB3KHsgc2x1ZzogaCgpLCBzdGF0dXM6IGgoKSB9KSxcbiAgcGhvbmVfcmVxdWVzdGVkOiB3KHsgc3RhdHVzOiBoKCkgfSksXG4gIHBvcHVwX2Nsb3NlZDoge1xuICAgIHBhcnNlKGUpIHtcbiAgICAgIHJldHVybiB3KHtcbiAgICAgICAgYnV0dG9uX2lkOiAodCkgPT4gdCA9PSBudWxsID8gdm9pZCAwIDogaCgpLnBhcnNlKHQpXG4gICAgICB9KS5wYXJzZShlID8/IHt9KTtcbiAgICB9XG4gIH0sXG4gIHFyX3RleHRfcmVjZWl2ZWQ6IHcoeyBkYXRhOiBoKCkub3B0aW9uYWwoKSB9KSxcbiAgdGhlbWVfY2hhbmdlZDogdyh7XG4gICAgdGhlbWVfcGFyYW1zOiAoZSkgPT4ge1xuICAgICAgY29uc3QgdCA9IEl0KCkub3B0aW9uYWwoKTtcbiAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhhdChlKSkucmVkdWNlKChzLCBbbiwgcl0pID0+IChzW25dID0gdC5wYXJzZShyKSwgcyksIHt9KTtcbiAgICB9XG4gIH0pLFxuICB2aWV3cG9ydF9jaGFuZ2VkOiB3KHtcbiAgICBoZWlnaHQ6IHgoKSxcbiAgICB3aWR0aDogKGUpID0+IGUgPT0gbnVsbCA/IHdpbmRvdy5pbm5lcldpZHRoIDogeCgpLnBhcnNlKGUpLFxuICAgIGlzX3N0YXRlX3N0YWJsZTogRSgpLFxuICAgIGlzX2V4cGFuZGVkOiBFKClcbiAgfSksXG4gIHdyaXRlX2FjY2Vzc19yZXF1ZXN0ZWQ6IHcoeyBzdGF0dXM6IGgoKSB9KVxufTtcbmZ1bmN0aW9uIFNlKCkge1xuICBjb25zdCBlID0gbmV3IEQoKSwgdCA9IG5ldyBEKCk7XG4gIHQuc3Vic2NyaWJlKChuKSA9PiB7XG4gICAgZS5lbWl0KFwiZXZlbnRcIiwgeyBuYW1lOiBuLmV2ZW50LCBwYXlsb2FkOiBuLmFyZ3NbMF0gfSk7XG4gIH0pLCB4ZSgpO1xuICBjb25zdCBbLCBzXSA9IG90KFxuICAgIC8vIERvbid0IGZvcmdldCB0byByZW1vdmUgY3JlYXRlZCBoYW5kbGVycy5cbiAgICBSZSxcbiAgICAvLyBBZGQgXCJyZXNpemVcIiBldmVudCBsaXN0ZW5lciB0byBtYWtlIHN1cmUsIHdlIGFsd2F5cyBoYXZlIGZyZXNoIHZpZXdwb3J0IGluZm9ybWF0aW9uLlxuICAgIC8vIERlc2t0b3AgdmVyc2lvbiBvZiBUZWxlZ3JhbSBpcyBzb21ldGltZXMgbm90IHNlbmRpbmcgdGhlIHZpZXdwb3J0X2NoYW5nZWRcbiAgICAvLyBldmVudC4gRm9yIGV4YW1wbGUsIHdoZW4gdGhlIE1haW5CdXR0b24gaXMgc2hvd24uIFRoYXQncyB3aHkgd2Ugc2hvdWxkXG4gICAgLy8gYWRkIG91ciBvd24gbGlzdGVuZXIgdG8gbWFrZSBzdXJlLCB2aWV3cG9ydCBpbmZvcm1hdGlvbiBpcyBhbHdheXMgZnJlc2guXG4gICAgLy8gSXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9UZWxlZ3JhbS1NaW5pLUFwcHMvdG1hLmpzL2lzc3Vlcy8xMFxuICAgIHR0KFwicmVzaXplXCIsICgpID0+IHtcbiAgICAgIHQuZW1pdChcInZpZXdwb3J0X2NoYW5nZWRcIiwge1xuICAgICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0LFxuICAgICAgICBpc19zdGF0ZV9zdGFibGU6ICEwLFxuICAgICAgICBpc19leHBhbmRlZDogITBcbiAgICAgIH0pO1xuICAgIH0pLFxuICAgIC8vIEFkZCBsaXN0ZW5lciwgd2hpY2ggaGFuZGxlcyBldmVudHMgc2VudCBmcm9tIHRoZSBUZWxlZ3JhbSB3ZWIgYXBwbGljYXRpb24gYW5kIGFsc28gZXZlbnRzXG4gICAgLy8gZ2VuZXJhdGVkIGJ5IHRoZSBsb2NhbCBlbWl0RXZlbnQgZnVuY3Rpb24uXG4gICAgdHQoXCJtZXNzYWdlXCIsIChuKSA9PiB7XG4gICAgICBpZiAobi5zb3VyY2UgIT09IHdpbmRvdy5wYXJlbnQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxldCByO1xuICAgICAgdHJ5IHtcbiAgICAgICAgciA9IGt0KG4uZGF0YSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBldmVudFR5cGU6IGksIGV2ZW50RGF0YTogbyB9ID0gciwgYSA9IENlW2ldO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcCA9IGEgPyBhLnBhcnNlKG8pIDogbztcbiAgICAgICAgdC5lbWl0KC4uLnAgPyBbaSwgcF0gOiBbaV0pO1xuICAgICAgfSBjYXRjaCAocCkge1xuICAgICAgICBpdC5lcnJvcihcbiAgICAgICAgICBgQW4gZXJyb3Igb2NjdXJyZWQgcHJvY2Vzc2luZyB0aGUgXCIke2l9XCIgZXZlbnQgZnJvbSB0aGUgVGVsZWdyYW0gYXBwbGljYXRpb24uIFBsZWFzZSwgZmlsZSBhbiBpc3N1ZSBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vVGVsZWdyYW0tTWluaS1BcHBzL3RtYS5qcy9pc3N1ZXMvbmV3L2Nob29zZWAsXG4gICAgICAgICAgcixcbiAgICAgICAgICBwXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSksXG4gICAgLy8gQ2xlYXIgZW1pdHRlcnMuXG4gICAgKCkgPT4gZS5jbGVhcigpLFxuICAgICgpID0+IHQuY2xlYXIoKVxuICApO1xuICByZXR1cm4gW3tcbiAgICBvbjogdC5vbi5iaW5kKHQpLFxuICAgIG9mZjogdC5vZmYuYmluZCh0KSxcbiAgICBzdWJzY3JpYmUobikge1xuICAgICAgcmV0dXJuIGUub24oXCJldmVudFwiLCBuKTtcbiAgICB9LFxuICAgIHVuc3Vic2NyaWJlKG4pIHtcbiAgICAgIGUub2ZmKFwiZXZlbnRcIiwgbik7XG4gICAgfSxcbiAgICBnZXQgY291bnQoKSB7XG4gICAgICByZXR1cm4gdC5jb3VudCArIGUuY291bnQ7XG4gICAgfVxuICB9LCBzXTtcbn1cbmNvbnN0IFtUZSwgQWVdID0geHQoXG4gIChlKSA9PiB7XG4gICAgY29uc3QgW3QsIHNdID0gU2UoKSwgbiA9IHQub2ZmLmJpbmQodCk7XG4gICAgcmV0dXJuIHQub2ZmID0gKHIsIGkpID0+IHtcbiAgICAgIGNvbnN0IHsgY291bnQ6IG8gfSA9IHQ7XG4gICAgICBuKHIsIGkpLCBvICYmICF0LmNvdW50ICYmIGUoKTtcbiAgICB9LCBbdCwgc107XG4gIH0sXG4gIChbLCBlXSkgPT4gZSgpXG4pO1xuZnVuY3Rpb24gaigpIHtcbiAgcmV0dXJuIFRlKClbMF07XG59XG5mdW5jdGlvbiB6KGUsIHQpIHtcbiAgaigpLm9mZihlLCB0KTtcbn1cbmZ1bmN0aW9uIHkoZSwgdCwgcykge1xuICByZXR1cm4gaigpLm9uKGUsIHQsIHMpO1xufVxuZnVuY3Rpb24gVihlKSB7XG4gIHJldHVybiB0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIGUgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkoZSk7XG59XG5mdW5jdGlvbiBJZShlLCB0KSB7XG4gIGNvbnN0IHMgPSBlLnNwbGl0KFwiLlwiKSwgbiA9IHQuc3BsaXQoXCIuXCIpLCByID0gTWF0aC5tYXgocy5sZW5ndGgsIG4ubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByOyBpICs9IDEpIHtcbiAgICBjb25zdCBvID0gcGFyc2VJbnQoc1tpXSB8fCBcIjBcIiwgMTApLCBhID0gcGFyc2VJbnQobltpXSB8fCBcIjBcIiwgMTApO1xuICAgIGlmIChvICE9PSBhKVxuICAgICAgcmV0dXJuIG8gPiBhID8gMSA6IC0xO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gdihlLCB0KSB7XG4gIHJldHVybiBJZShlLCB0KSA8PSAwO1xufVxuZnVuY3Rpb24gQyhlLCB0LCBzKSB7XG4gIGlmICh0eXBlb2YgcyA9PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKGUgPT09IFwid2ViX2FwcF9vcGVuX2xpbmtcIiAmJiB0ID09PSBcInRyeV9pbnN0YW50X3ZpZXdcIilcbiAgICAgIHJldHVybiB2KFwiNi40XCIsIHMpO1xuICAgIGlmIChlID09PSBcIndlYl9hcHBfc2V0X2hlYWRlcl9jb2xvclwiICYmIHQgPT09IFwiY29sb3JcIilcbiAgICAgIHJldHVybiB2KFwiNi45XCIsIHMpO1xuICB9XG4gIHN3aXRjaCAoZSkge1xuICAgIGNhc2UgXCJ3ZWJfYXBwX29wZW5fdGdfbGlua1wiOlxuICAgIGNhc2UgXCJ3ZWJfYXBwX29wZW5faW52b2ljZVwiOlxuICAgIGNhc2UgXCJ3ZWJfYXBwX3NldHVwX2JhY2tfYnV0dG9uXCI6XG4gICAgY2FzZSBcIndlYl9hcHBfc2V0X2JhY2tncm91bmRfY29sb3JcIjpcbiAgICBjYXNlIFwid2ViX2FwcF9zZXRfaGVhZGVyX2NvbG9yXCI6XG4gICAgY2FzZSBcIndlYl9hcHBfdHJpZ2dlcl9oYXB0aWNfZmVlZGJhY2tcIjpcbiAgICAgIHJldHVybiB2KFwiNi4xXCIsIHQpO1xuICAgIGNhc2UgXCJ3ZWJfYXBwX29wZW5fcG9wdXBcIjpcbiAgICAgIHJldHVybiB2KFwiNi4yXCIsIHQpO1xuICAgIGNhc2UgXCJ3ZWJfYXBwX2Nsb3NlX3NjYW5fcXJfcG9wdXBcIjpcbiAgICBjYXNlIFwid2ViX2FwcF9vcGVuX3NjYW5fcXJfcG9wdXBcIjpcbiAgICBjYXNlIFwid2ViX2FwcF9yZWFkX3RleHRfZnJvbV9jbGlwYm9hcmRcIjpcbiAgICAgIHJldHVybiB2KFwiNi40XCIsIHQpO1xuICAgIGNhc2UgXCJ3ZWJfYXBwX3N3aXRjaF9pbmxpbmVfcXVlcnlcIjpcbiAgICAgIHJldHVybiB2KFwiNi43XCIsIHQpO1xuICAgIGNhc2UgXCJ3ZWJfYXBwX2ludm9rZV9jdXN0b21fbWV0aG9kXCI6XG4gICAgY2FzZSBcIndlYl9hcHBfcmVxdWVzdF93cml0ZV9hY2Nlc3NcIjpcbiAgICBjYXNlIFwid2ViX2FwcF9yZXF1ZXN0X3Bob25lXCI6XG4gICAgICByZXR1cm4gdihcIjYuOVwiLCB0KTtcbiAgICBjYXNlIFwid2ViX2FwcF9zZXR1cF9zZXR0aW5nc19idXR0b25cIjpcbiAgICAgIHJldHVybiB2KFwiNi4xMFwiLCB0KTtcbiAgICBjYXNlIFwid2ViX2FwcF9iaW9tZXRyeV9nZXRfaW5mb1wiOlxuICAgIGNhc2UgXCJ3ZWJfYXBwX2Jpb21ldHJ5X29wZW5fc2V0dGluZ3NcIjpcbiAgICBjYXNlIFwid2ViX2FwcF9iaW9tZXRyeV9yZXF1ZXN0X2FjY2Vzc1wiOlxuICAgIGNhc2UgXCJ3ZWJfYXBwX2Jpb21ldHJ5X3JlcXVlc3RfYXV0aFwiOlxuICAgIGNhc2UgXCJ3ZWJfYXBwX2Jpb21ldHJ5X3VwZGF0ZV90b2tlblwiOlxuICAgICAgcmV0dXJuIHYoXCI3LjJcIiwgdCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBbXG4gICAgICAgIFwiaWZyYW1lX3JlYWR5XCIsXG4gICAgICAgIFwiaWZyYW1lX3dpbGxfcmVsb2FkXCIsXG4gICAgICAgIFwid2ViX2FwcF9jbG9zZVwiLFxuICAgICAgICBcIndlYl9hcHBfZGF0YV9zZW5kXCIsXG4gICAgICAgIFwid2ViX2FwcF9leHBhbmRcIixcbiAgICAgICAgXCJ3ZWJfYXBwX29wZW5fbGlua1wiLFxuICAgICAgICBcIndlYl9hcHBfcmVhZHlcIixcbiAgICAgICAgXCJ3ZWJfYXBwX3JlcXVlc3RfdGhlbWVcIixcbiAgICAgICAgXCJ3ZWJfYXBwX3JlcXVlc3Rfdmlld3BvcnRcIixcbiAgICAgICAgXCJ3ZWJfYXBwX3NldHVwX21haW5fYnV0dG9uXCIsXG4gICAgICAgIFwid2ViX2FwcF9zZXR1cF9jbG9zaW5nX2JlaGF2aW9yXCJcbiAgICAgIF0uaW5jbHVkZXMoZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHF0KGUpIHtcbiAgcmV0dXJuIFwiZXh0ZXJuYWxcIiBpbiBlICYmIFYoZS5leHRlcm5hbCkgJiYgXCJub3RpZnlcIiBpbiBlLmV4dGVybmFsICYmIHR5cGVvZiBlLmV4dGVybmFsLm5vdGlmeSA9PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBPdChlKSB7XG4gIHJldHVybiBcIlRlbGVncmFtV2Vidmlld1Byb3h5XCIgaW4gZSAmJiBWKGUuVGVsZWdyYW1XZWJ2aWV3UHJveHkpICYmIFwicG9zdEV2ZW50XCIgaW4gZS5UZWxlZ3JhbVdlYnZpZXdQcm94eSAmJiB0eXBlb2YgZS5UZWxlZ3JhbVdlYnZpZXdQcm94eS5wb3N0RXZlbnQgPT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gaHQoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5zZWxmICE9PSB3aW5kb3cudG9wO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbn1cbmxldCBOdCA9IFwiaHR0cHM6Ly93ZWIudGVsZWdyYW0ub3JnXCI7XG5mdW5jdGlvbiB3bihlKSB7XG4gIE50ID0gZTtcbn1cbmZ1bmN0aW9uIGtlKCkge1xuICByZXR1cm4gTnQ7XG59XG5mdW5jdGlvbiBCKGUsIHQsIHMpIHtcbiAgbGV0IG4gPSB7fSwgcjtcbiAgdCA9PT0gdm9pZCAwICYmIHMgPT09IHZvaWQgMCA/IG4gPSB7fSA6IHQgIT09IHZvaWQgMCAmJiBzICE9PSB2b2lkIDAgPyAobiA9IHMsIHIgPSB0KSA6IHQgIT09IHZvaWQgMCAmJiAoXCJ0YXJnZXRPcmlnaW5cIiBpbiB0ID8gbiA9IHQgOiByID0gdCk7XG4gIGNvbnN0IHsgdGFyZ2V0T3JpZ2luOiBpID0ga2UoKSB9ID0gbjtcbiAgaWYgKGRlKFwiUG9zdGluZyBldmVudDpcIiwgciA/IHsgZXZlbnQ6IGUsIGRhdGE6IHIgfSA6IHsgZXZlbnQ6IGUgfSksIGh0KCkpIHtcbiAgICB3aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHsgZXZlbnRUeXBlOiBlLCBldmVudERhdGE6IHIgfSksIGkpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocXQod2luZG93KSkge1xuICAgIHdpbmRvdy5leHRlcm5hbC5ub3RpZnkoSlNPTi5zdHJpbmdpZnkoeyBldmVudFR5cGU6IGUsIGV2ZW50RGF0YTogciB9KSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChPdCh3aW5kb3cpKSB7XG4gICAgd2luZG93LlRlbGVncmFtV2Vidmlld1Byb3h5LnBvc3RFdmVudChlLCBKU09OLnN0cmluZ2lmeShyKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRocm93IG0oXG4gICAgZ2UsXG4gICAgXCJVbmFibGUgdG8gZGV0ZXJtaW5lIGN1cnJlbnQgZW52aXJvbm1lbnQgYW5kIHBvc3NpYmxlIHdheSB0byBzZW5kIGV2ZW50LiBZb3UgYXJlIHByb2JhYmx5IHRyeWluZyB0byB1c2UgTWluaSBBcHBzIG1ldGhvZCBvdXRzaWRlIG9mIFRlbGVncmFtIGFwcGxpY2F0aW9uIGVudmlyb25tZW50LlwiXG4gICk7XG59XG5mdW5jdGlvbiBxZShlKSB7XG4gIHJldHVybiAodCwgcykgPT4ge1xuICAgIGlmICghQyh0LCBlKSlcbiAgICAgIHRocm93IG0oX2UsIGBNZXRob2QgXCIke3R9XCIgaXMgdW5zdXBwb3J0ZWQgaW4gTWluaSBBcHBzIHZlcnNpb24gJHtlfWApO1xuICAgIGlmIChWKHMpKSB7XG4gICAgICBsZXQgbjtcbiAgICAgIGlmICh0ID09PSBcIndlYl9hcHBfb3Blbl9saW5rXCIgJiYgXCJ0cnlfaW5zdGFudF92aWV3XCIgaW4gcyA/IG4gPSBcInRyeV9pbnN0YW50X3ZpZXdcIiA6IHQgPT09IFwid2ViX2FwcF9zZXRfaGVhZGVyX2NvbG9yXCIgJiYgXCJjb2xvclwiIGluIHMgJiYgKG4gPSBcImNvbG9yXCIpLCBuICYmICFDKHQsIG4sIGUpKVxuICAgICAgICB0aHJvdyBtKFxuICAgICAgICAgIHdlLFxuICAgICAgICAgIGBQYXJhbWV0ZXIgXCIke259XCIgb2YgXCIke3R9XCIgbWV0aG9kIGlzIHVuc3VwcG9ydGVkIGluIE1pbmkgQXBwcyB2ZXJzaW9uICR7ZX1gXG4gICAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBCKHQsIHMpO1xuICB9O1xufVxuZnVuY3Rpb24gRHQoZSkge1xuICByZXR1cm4gKHsgcmVxX2lkOiB0IH0pID0+IHQgPT09IGU7XG59XG5mdW5jdGlvbiBCdChlKSB7XG4gIHJldHVybiBtKG1lLCBgVGltZW91dCByZWFjaGVkOiAke2V9bXNgKTtcbn1cbmZ1bmN0aW9uIE10KGUsIHQpIHtcbiAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiID8gZSgpIDogZSxcbiAgICBuZXcgUHJvbWlzZSgocywgbikgPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIG4oQnQodCkpO1xuICAgICAgfSwgdCk7XG4gICAgfSlcbiAgXSk7XG59XG5hc3luYyBmdW5jdGlvbiBnKGUpIHtcbiAgbGV0IHQ7XG4gIGNvbnN0IHMgPSBuZXcgUHJvbWlzZSgoYSkgPT4ge1xuICAgIHQgPSBhO1xuICB9KSwgeyBldmVudDogbiwgY2FwdHVyZTogciwgdGltZW91dDogaSB9ID0gZSwgWywgb10gPSBvdChcbiAgICAuLi4oQXJyYXkuaXNBcnJheShuKSA/IG4gOiBbbl0pLm1hcChcbiAgICAgIChhKSA9PiB5KGEsIChwKSA9PiAoIXIgfHwgcihwKSkgJiYgdChwKSlcbiAgICApXG4gICk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIChlLnBvc3RFdmVudCB8fCBCKShlLm1ldGhvZCwgZS5wYXJhbXMpLCBhd2FpdCAoaSA/IE10KHMsIGkpIDogcyk7XG4gIH0gZmluYWxseSB7XG4gICAgbygpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBPKGUsIHQsIHMsIG4gPSB7fSkge1xuICBjb25zdCB7XG4gICAgcmVzdWx0OiByLFxuICAgIGVycm9yOiBpXG4gIH0gPSBhd2FpdCBnKHtcbiAgICAuLi5uLFxuICAgIG1ldGhvZDogXCJ3ZWJfYXBwX2ludm9rZV9jdXN0b21fbWV0aG9kXCIsXG4gICAgZXZlbnQ6IFwiY3VzdG9tX21ldGhvZF9pbnZva2VkXCIsXG4gICAgcGFyYW1zOiB7XG4gICAgICBtZXRob2Q6IGUsXG4gICAgICBwYXJhbXM6IHQsXG4gICAgICByZXFfaWQ6IHNcbiAgICB9LFxuICAgIGNhcHR1cmU6IER0KHMpXG4gIH0pO1xuICBpZiAoaSlcbiAgICB0aHJvdyBtKGZlLCBpKTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBzdCguLi5lKSB7XG4gIHJldHVybiBlLm1hcCgodCkgPT4ge1xuICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIHQ7XG4gICAgaWYgKFYodCkpXG4gICAgICByZXR1cm4gc3QoT2JqZWN0LmVudHJpZXModCkubWFwKChzKSA9PiBzWzFdICYmIHNbMF0pKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSlcbiAgICAgIHJldHVybiBzdCguLi50KTtcbiAgfSkuZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpO1xufVxuZnVuY3Rpb24gZ24oLi4uZSkge1xuICByZXR1cm4gZS5yZWR1Y2UoKHQsIHMpID0+IChWKHMpICYmIE9iamVjdC5lbnRyaWVzKHMpLmZvckVhY2goKFtuLCByXSkgPT4ge1xuICAgIGNvbnN0IGkgPSBzdCh0W25dLCByKTtcbiAgICBpLmxlbmd0aCAmJiAodFtuXSA9IGkpO1xuICB9KSwgdCksIHt9KTtcbn1cbmZ1bmN0aW9uIFZ0KGUpIHtcbiAgY29uc3QgdCA9IEF0KGUpO1xuICByZXR1cm4gTWF0aC5zcXJ0KFxuICAgIFswLjI5OSwgMC41ODcsIDAuMTE0XS5yZWR1Y2UoKHMsIG4sIHIpID0+IHtcbiAgICAgIGNvbnN0IGkgPSBwYXJzZUludCh0LnNsaWNlKDEgKyByICogMiwgMSArIChyICsgMSkgKiAyKSwgMTYpO1xuICAgICAgcmV0dXJuIHMgKyBpICogaSAqIG47XG4gICAgfSwgMClcbiAgKSA8IDEyMDtcbn1cbmNsYXNzIE9lIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIGModGhpcywgXCJlZVwiLCBuZXcgRCgpKSwgYyh0aGlzLCBcIm9uXCIsIHRoaXMuZWUub24uYmluZCh0aGlzLmVlKSksIGModGhpcywgXCJvZmZcIiwgdGhpcy5lZS5vZmYuYmluZCh0aGlzLmVlKSksIHRoaXMuc3RhdGUgPSB0O1xuICB9XG4gIC8qKlxuICAgKiBDbG9uZXMgY3VycmVudCBzdGF0ZSBhbmQgcmV0dXJucyBpdHMgY29weS5cbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiB7IC4uLnRoaXMuc3RhdGUgfTtcbiAgfVxuICBzZXQodCwgcykge1xuICAgIE9iamVjdC5lbnRyaWVzKHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyB7IFt0XTogcyB9IDogdCkucmVkdWNlKChuLCBbciwgaV0pID0+IHRoaXMuc3RhdGVbcl0gPT09IGkgfHwgaSA9PT0gdm9pZCAwID8gbiA6ICh0aGlzLnN0YXRlW3JdID0gaSwgdGhpcy5lZS5lbWl0KGBjaGFuZ2U6JHtyfWAsIGkpLCAhMCksICExKSAmJiB0aGlzLmVlLmVtaXQoXCJjaGFuZ2VcIiwgdGhpcy5zdGF0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdmFsdWUgYnkgc3BlY2lmaWVkIGtleS5cbiAgICogQHBhcmFtIGtleSAtIHN0YXRlIGtleS5cbiAgICovXG4gIGdldCh0KSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVbdF07XG4gIH1cbn1cbmNsYXNzIHB0IHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIGModGhpcywgXCJzdGF0ZVwiKSwgYyh0aGlzLCBcImdldFwiKSwgYyh0aGlzLCBcInNldFwiKSwgYyh0aGlzLCBcImNsb25lXCIpLCB0aGlzLnN0YXRlID0gbmV3IE9lKHQpLCB0aGlzLnNldCA9IHRoaXMuc3RhdGUuc2V0LmJpbmQodGhpcy5zdGF0ZSksIHRoaXMuZ2V0ID0gdGhpcy5zdGF0ZS5nZXQuYmluZCh0aGlzLnN0YXRlKSwgdGhpcy5jbG9uZSA9IHRoaXMuc3RhdGUuY2xvbmUuYmluZCh0aGlzLnN0YXRlKTtcbiAgfVxufVxuZnVuY3Rpb24gTHQoZSwgdCkge1xuICByZXR1cm4gKHMpID0+IEModFtzXSwgZSk7XG59XG5jbGFzcyB1dCBleHRlbmRzIHB0IHtcbiAgY29uc3RydWN0b3IodCwgcywgbikge1xuICAgIHN1cGVyKHQpLCBjKHRoaXMsIFwic3VwcG9ydHNcIiksIHRoaXMuc3VwcG9ydHMgPSBMdChzLCBuKTtcbiAgfVxufVxuY2xhc3MgTmUgZXh0ZW5kcyB1dCB7XG4gIGNvbnN0cnVjdG9yKHQsIHMsIG4pIHtcbiAgICBzdXBlcih7IGlzVmlzaWJsZTogdCB9LCBzLCB7XG4gICAgICBzaG93OiBcIndlYl9hcHBfc2V0dXBfYmFja19idXR0b25cIixcbiAgICAgIGhpZGU6IFwid2ViX2FwcF9zZXR1cF9iYWNrX2J1dHRvblwiXG4gICAgfSksIGModGhpcywgXCJvblwiLCAociwgaSkgPT4gciA9PT0gXCJjbGlja1wiID8geShcImJhY2tfYnV0dG9uX3ByZXNzZWRcIiwgaSkgOiB0aGlzLnN0YXRlLm9uKHIsIGkpKSwgYyh0aGlzLCBcIm9mZlwiLCAociwgaSkgPT4gciA9PT0gXCJjbGlja1wiID8geihcImJhY2tfYnV0dG9uX3ByZXNzZWRcIiwgaSkgOiB0aGlzLnN0YXRlLm9mZihyLCBpKSksIHRoaXMucG9zdEV2ZW50ID0gbjtcbiAgfVxuICBzZXQgaXNWaXNpYmxlKHQpIHtcbiAgICB0aGlzLnNldChcImlzVmlzaWJsZVwiLCB0KSwgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX3NldHVwX2JhY2tfYnV0dG9uXCIsIHsgaXNfdmlzaWJsZTogdCB9KTtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiBCYWNrQnV0dG9uIGlzIGN1cnJlbnRseSB2aXNpYmxlLlxuICAgKi9cbiAgZ2V0IGlzVmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJpc1Zpc2libGVcIik7XG4gIH1cbiAgLyoqXG4gICAqIEhpZGVzIHRoZSBCYWNrQnV0dG9uLlxuICAgKi9cbiAgaGlkZSgpIHtcbiAgICB0aGlzLmlzVmlzaWJsZSA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBTaG93cyB0aGUgQmFja0J1dHRvbi5cbiAgICovXG4gIHNob3coKSB7XG4gICAgdGhpcy5pc1Zpc2libGUgPSAhMDtcbiAgfVxufVxuY29uc3QgJHQgPSBBKChlKSA9PiBlIGluc3RhbmNlb2YgRGF0ZSA/IGUgOiBuZXcgRGF0ZSh4KCkucGFyc2UoZSkgKiAxZTMpLCBcIkRhdGVcIik7XG5mdW5jdGlvbiBsdChlLCB0KSB7XG4gIHJldHVybiBuZXcgRygocykgPT4ge1xuICAgIGlmICh0eXBlb2YgcyAhPSBcInN0cmluZ1wiICYmICEocyBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykpXG4gICAgICB0aHJvdyBUKCk7XG4gICAgY29uc3QgbiA9IHR5cGVvZiBzID09IFwic3RyaW5nXCIgPyBuZXcgVVJMU2VhcmNoUGFyYW1zKHMpIDogcztcbiAgICByZXR1cm4gVHQoZSwgKHIpID0+IHtcbiAgICAgIGNvbnN0IGkgPSBuLmdldChyKTtcbiAgICAgIHJldHVybiBpID09PSBudWxsID8gdm9pZCAwIDogaTtcbiAgICB9KTtcbiAgfSwgITEsIHQpO1xufVxuY29uc3QgRGUgPSB3KHtcbiAgaWQ6IHgoKSxcbiAgdHlwZTogaCgpLFxuICB0aXRsZTogaCgpLFxuICBwaG90b1VybDoge1xuICAgIHR5cGU6IGgoKS5vcHRpb25hbCgpLFxuICAgIGZyb206IFwicGhvdG9fdXJsXCJcbiAgfSxcbiAgdXNlcm5hbWU6IGgoKS5vcHRpb25hbCgpXG59LCBcIkNoYXRcIikub3B0aW9uYWwoKSwgeXQgPSB3KHtcbiAgYWRkZWRUb0F0dGFjaG1lbnRNZW51OiB7XG4gICAgdHlwZTogRSgpLm9wdGlvbmFsKCksXG4gICAgZnJvbTogXCJhZGRlZF90b19hdHRhY2htZW50X21lbnVcIlxuICB9LFxuICBhbGxvd3NXcml0ZVRvUG06IHtcbiAgICB0eXBlOiBFKCkub3B0aW9uYWwoKSxcbiAgICBmcm9tOiBcImFsbG93c193cml0ZV90b19wbVwiXG4gIH0sXG4gIGZpcnN0TmFtZToge1xuICAgIHR5cGU6IGgoKSxcbiAgICBmcm9tOiBcImZpcnN0X25hbWVcIlxuICB9LFxuICBpZDogeCgpLFxuICBpc0JvdDoge1xuICAgIHR5cGU6IEUoKS5vcHRpb25hbCgpLFxuICAgIGZyb206IFwiaXNfYm90XCJcbiAgfSxcbiAgaXNQcmVtaXVtOiB7XG4gICAgdHlwZTogRSgpLm9wdGlvbmFsKCksXG4gICAgZnJvbTogXCJpc19wcmVtaXVtXCJcbiAgfSxcbiAgbGFuZ3VhZ2VDb2RlOiB7XG4gICAgdHlwZTogaCgpLm9wdGlvbmFsKCksXG4gICAgZnJvbTogXCJsYW5ndWFnZV9jb2RlXCJcbiAgfSxcbiAgbGFzdE5hbWU6IHtcbiAgICB0eXBlOiBoKCkub3B0aW9uYWwoKSxcbiAgICBmcm9tOiBcImxhc3RfbmFtZVwiXG4gIH0sXG4gIHBob3RvVXJsOiB7XG4gICAgdHlwZTogaCgpLm9wdGlvbmFsKCksXG4gICAgZnJvbTogXCJwaG90b191cmxcIlxuICB9LFxuICB1c2VybmFtZTogaCgpLm9wdGlvbmFsKClcbn0sIFwiVXNlclwiKS5vcHRpb25hbCgpO1xuZnVuY3Rpb24gVXQoKSB7XG4gIHJldHVybiBsdCh7XG4gICAgYXV0aERhdGU6IHtcbiAgICAgIHR5cGU6ICR0KCksXG4gICAgICBmcm9tOiBcImF1dGhfZGF0ZVwiXG4gICAgfSxcbiAgICBjYW5TZW5kQWZ0ZXI6IHtcbiAgICAgIHR5cGU6IHgoKS5vcHRpb25hbCgpLFxuICAgICAgZnJvbTogXCJjYW5fc2VuZF9hZnRlclwiXG4gICAgfSxcbiAgICBjaGF0OiBEZSxcbiAgICBjaGF0SW5zdGFuY2U6IHtcbiAgICAgIHR5cGU6IGgoKS5vcHRpb25hbCgpLFxuICAgICAgZnJvbTogXCJjaGF0X2luc3RhbmNlXCJcbiAgICB9LFxuICAgIGNoYXRUeXBlOiB7XG4gICAgICB0eXBlOiBoKCkub3B0aW9uYWwoKSxcbiAgICAgIGZyb206IFwiY2hhdF90eXBlXCJcbiAgICB9LFxuICAgIGhhc2g6IGgoKSxcbiAgICBxdWVyeUlkOiB7XG4gICAgICB0eXBlOiBoKCkub3B0aW9uYWwoKSxcbiAgICAgIGZyb206IFwicXVlcnlfaWRcIlxuICAgIH0sXG4gICAgcmVjZWl2ZXI6IHl0LFxuICAgIHN0YXJ0UGFyYW06IHtcbiAgICAgIHR5cGU6IGgoKS5vcHRpb25hbCgpLFxuICAgICAgZnJvbTogXCJzdGFydF9wYXJhbVwiXG4gICAgfSxcbiAgICB1c2VyOiB5dFxuICB9LCBcIkluaXREYXRhXCIpO1xufVxuZnVuY3Rpb24gQmUoZSkge1xuICByZXR1cm4gZS5yZXBsYWNlKC9fW2Etel0vZywgKHQpID0+IHRbMV0udG9VcHBlckNhc2UoKSk7XG59XG5mdW5jdGlvbiBNZShlKSB7XG4gIHJldHVybiBlLnJlcGxhY2UoL1tBLVpdL2csICh0KSA9PiBgXyR7dC50b0xvd2VyQ2FzZSgpfWApO1xufVxuY29uc3QgSHQgPSBBKFxuICAoZSkgPT4ge1xuICAgIGNvbnN0IHQgPSBJdCgpLm9wdGlvbmFsKCk7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGF0KGUpKS5yZWR1Y2UoKHMsIFtuLCByXSkgPT4gKHNbQmUobildID0gdC5wYXJzZShyKSwgcyksIHt9KTtcbiAgfSxcbiAgXCJUaGVtZVBhcmFtc1wiXG4pO1xuZnVuY3Rpb24gZHQoZSkge1xuICByZXR1cm4gbHQoe1xuICAgIGJvdElubGluZToge1xuICAgICAgdHlwZTogRSgpLm9wdGlvbmFsKCksXG4gICAgICBmcm9tOiBcInRnV2ViQXBwQm90SW5saW5lXCJcbiAgICB9LFxuICAgIGluaXREYXRhOiB7XG4gICAgICB0eXBlOiBVdCgpLm9wdGlvbmFsKCksXG4gICAgICBmcm9tOiBcInRnV2ViQXBwRGF0YVwiXG4gICAgfSxcbiAgICBpbml0RGF0YVJhdzoge1xuICAgICAgdHlwZTogaCgpLm9wdGlvbmFsKCksXG4gICAgICBmcm9tOiBcInRnV2ViQXBwRGF0YVwiXG4gICAgfSxcbiAgICBwbGF0Zm9ybToge1xuICAgICAgdHlwZTogaCgpLFxuICAgICAgZnJvbTogXCJ0Z1dlYkFwcFBsYXRmb3JtXCJcbiAgICB9LFxuICAgIHNob3dTZXR0aW5nczoge1xuICAgICAgdHlwZTogRSgpLm9wdGlvbmFsKCksXG4gICAgICBmcm9tOiBcInRnV2ViQXBwU2hvd1NldHRpbmdzXCJcbiAgICB9LFxuICAgIHN0YXJ0UGFyYW06IHtcbiAgICAgIHR5cGU6IGgoKS5vcHRpb25hbCgpLFxuICAgICAgZnJvbTogXCJ0Z1dlYkFwcFN0YXJ0UGFyYW1cIlxuICAgIH0sXG4gICAgdGhlbWVQYXJhbXM6IHtcbiAgICAgIHR5cGU6IEh0KCksXG4gICAgICBmcm9tOiBcInRnV2ViQXBwVGhlbWVQYXJhbXNcIlxuICAgIH0sXG4gICAgdmVyc2lvbjoge1xuICAgICAgdHlwZTogaCgpLFxuICAgICAgZnJvbTogXCJ0Z1dlYkFwcFZlcnNpb25cIlxuICAgIH1cbiAgfSkucGFyc2UoZSk7XG59XG5mdW5jdGlvbiBXdChlKSB7XG4gIHJldHVybiBkdChcbiAgICBlLnJlcGxhY2UoL15bXj8jXSpbPyNdLywgXCJcIikucmVwbGFjZSgvWz8jXS9nLCBcIiZcIilcbiAgKTtcbn1cbmZ1bmN0aW9uIFZlKCkge1xuICByZXR1cm4gV3Qod2luZG93LmxvY2F0aW9uLmhyZWYpO1xufVxuZnVuY3Rpb24gR3QoKSB7XG4gIHJldHVybiBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlUeXBlKFwibmF2aWdhdGlvblwiKVswXTtcbn1cbmZ1bmN0aW9uIExlKCkge1xuICBjb25zdCBlID0gR3QoKTtcbiAgaWYgKCFlKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBnZXQgZmlyc3QgbmF2aWdhdGlvbiBlbnRyeS5cIik7XG4gIHJldHVybiBXdChlLm5hbWUpO1xufVxuZnVuY3Rpb24ganQoZSkge1xuICByZXR1cm4gYHRtYS5qcy8ke2UucmVwbGFjZSgvW0EtWl0vZywgKHQpID0+IGAtJHt0LnRvTG93ZXJDYXNlKCl9YCl9YDtcbn1cbmZ1bmN0aW9uIHp0KGUsIHQpIHtcbiAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShqdChlKSwgSlNPTi5zdHJpbmdpZnkodCkpO1xufVxuZnVuY3Rpb24gS3QoZSkge1xuICBjb25zdCB0ID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShqdChlKSk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHQgPyBKU09OLnBhcnNlKHQpIDogdm9pZCAwO1xuICB9IGNhdGNoIHtcbiAgfVxufVxuZnVuY3Rpb24gJGUoKSB7XG4gIHJldHVybiBkdChLdChcImxhdW5jaFBhcmFtc1wiKSB8fCBcIlwiKTtcbn1cbmZ1bmN0aW9uIEp0KGUpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFxuICAgIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIE9iamVjdC5lbnRyaWVzKGUpLm1hcCgoW3QsIHNdKSA9PiBbTWUodCksIHNdKVxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIFVlKGUpIHtcbiAgY29uc3Qge1xuICAgIGluaXREYXRhUmF3OiB0LFxuICAgIHRoZW1lUGFyYW1zOiBzLFxuICAgIHBsYXRmb3JtOiBuLFxuICAgIHZlcnNpb246IHIsXG4gICAgc2hvd1NldHRpbmdzOiBpLFxuICAgIHN0YXJ0UGFyYW06IG8sXG4gICAgYm90SW5saW5lOiBhXG4gIH0gPSBlLCBwID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICByZXR1cm4gcC5zZXQoXCJ0Z1dlYkFwcFBsYXRmb3JtXCIsIG4pLCBwLnNldChcInRnV2ViQXBwVGhlbWVQYXJhbXNcIiwgSnQocykpLCBwLnNldChcInRnV2ViQXBwVmVyc2lvblwiLCByKSwgdCAmJiBwLnNldChcInRnV2ViQXBwRGF0YVwiLCB0KSwgbyAmJiBwLnNldChcInRnV2ViQXBwU3RhcnRQYXJhbVwiLCBvKSwgdHlwZW9mIGkgPT0gXCJib29sZWFuXCIgJiYgcC5zZXQoXCJ0Z1dlYkFwcFNob3dTZXR0aW5nc1wiLCBpID8gXCIxXCIgOiBcIjBcIiksIHR5cGVvZiBhID09IFwiYm9vbGVhblwiICYmIHAuc2V0KFwidGdXZWJBcHBCb3RJbmxpbmVcIiwgYSA/IFwiMVwiIDogXCIwXCIpLCBwLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBGdChlKSB7XG4gIHp0KFwibGF1bmNoUGFyYW1zXCIsIFVlKGUpKTtcbn1cbmZ1bmN0aW9uIG50KCkge1xuICBmb3IgKGNvbnN0IGUgb2YgW1xuICAgIC8vIFRyeSB0byByZXRyaWV2ZSBsYXVuY2ggcGFyYW1ldGVycyBmcm9tIHRoZSBjdXJyZW50IGxvY2F0aW9uLiBUaGlzIG1ldGhvZCBjYW4gcmV0dXJuXG4gICAgLy8gbm90aGluZyBpbiBjYXNlLCBsb2NhdGlvbiB3YXMgY2hhbmdlZCBhbmQgdGhlbiBwYWdlIHdhcyByZWxvYWRlZC5cbiAgICBWZSxcbiAgICAvLyBUaGVuLCB0cnkgdXNpbmcgdGhlIGxvd2VyIGxldmVsIEFQSSAtIHdpbmRvdy5wZXJmb3JtYW5jZS5cbiAgICBMZSxcbiAgICAvLyBGaW5hbGx5LCB0cnkgdG8gZXh0cmFjdCBsYXVuY2ggcGFyYW1ldGVycyBmcm9tIHRoZSBzZXNzaW9uIHN0b3JhZ2UuXG4gICAgJGVcbiAgXSlcbiAgICB0cnkge1xuICAgICAgY29uc3QgdCA9IGUoKTtcbiAgICAgIHJldHVybiBGdCh0KSwgdDtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byByZXRyaWV2ZSBsYXVuY2ggcGFyYW1ldGVycyBmcm9tIGFueSBrbm93biBzb3VyY2UuXCIpO1xufVxuZnVuY3Rpb24gUXQoKSB7XG4gIGNvbnN0IGUgPSBHdCgpO1xuICByZXR1cm4gISEoZSAmJiBlLnR5cGUgPT09IFwicmVsb2FkXCIpO1xufVxuZnVuY3Rpb24gSGUoKSB7XG4gIGxldCBlID0gMDtcbiAgcmV0dXJuICgpID0+IChlICs9IDEpLnRvU3RyaW5nKCk7XG59XG5jb25zdCBbV2VdID0geHQoSGUpO1xuZnVuY3Rpb24gbChlLCB0KSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgY29uc3QgcyA9IG50KCksIG4gPSB7XG4gICAgICAuLi5zLFxuICAgICAgcG9zdEV2ZW50OiBxZShzLnZlcnNpb24pLFxuICAgICAgY3JlYXRlUmVxdWVzdElkOiBXZSgpXG4gICAgfTtcbiAgICBpZiAodHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgcmV0dXJuIGUobik7XG4gICAgY29uc3QgW3IsIGksIG9dID0gb3QoKSwgYSA9IHQoe1xuICAgICAgLi4ubixcbiAgICAgIC8vIFN0YXRlIHNob3VsZCBvbmx5IGJlIHBhc3NlZCBvbmx5IGluIGNhc2UsIGN1cnJlbnQgcGFnZSB3YXMgcmVsb2FkZWQuIElmIHdlIGRvbid0IGFkZFxuICAgICAgLy8gdGhpcyBjaGVjaywgc3RhdGUgcmVzdG9yYXRpb24gd2lsbCB3b3JrIGltcHJvcGVybHkgaW4gdGhlIHdlYiB2ZXJzaW9uIG9mIFRlbGVncmFtLFxuICAgICAgLy8gd2hlbiB3ZSBhcmUgYWx3YXlzIHdvcmtpbmcgaW4gdGhlIHNhbWUgXCJzZXNzaW9uXCIgKHRhYikuXG4gICAgICBzdGF0ZTogUXQoKSA/IEt0KGUpIDogdm9pZCAwLFxuICAgICAgYWRkQ2xlYW51cDogclxuICAgIH0pLCBwID0gKHUpID0+IChvIHx8IHIoXG4gICAgICB1Lm9uKFwiY2hhbmdlXCIsIChTKSA9PiB7XG4gICAgICAgIHp0KGUsIFMpO1xuICAgICAgfSlcbiAgICApLCB1KTtcbiAgICByZXR1cm4gW1xuICAgICAgYSBpbnN0YW5jZW9mIFByb21pc2UgPyBhLnRoZW4ocCkgOiBwKGEpLFxuICAgICAgaVxuICAgIF07XG4gIH07XG59XG5jb25zdCBHZSA9IGwoXCJiYWNrQnV0dG9uXCIsICh7XG4gIHBvc3RFdmVudDogZSxcbiAgdmVyc2lvbjogdCxcbiAgc3RhdGU6IHMgPSB7IGlzVmlzaWJsZTogITEgfVxufSkgPT4gbmV3IE5lKHMuaXNWaXNpYmxlLCB0LCBlKSk7XG5jbGFzcyBMIGV4dGVuZHMgdXQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCBjKHRoaXMsIFwib25cIiwgdGhpcy5zdGF0ZS5vbi5iaW5kKHRoaXMuc3RhdGUpKSwgYyh0aGlzLCBcIm9mZlwiLCB0aGlzLnN0YXRlLm9mZi5iaW5kKHRoaXMuc3RhdGUpKTtcbiAgfVxufVxuZnVuY3Rpb24gWXQoZSkge1xuICBjb25zdCB0ID0gZS5hdmFpbGFibGUgPyBlIDoge1xuICAgIGF2YWlsYWJsZTogITEsXG4gICAgZGV2aWNlX2lkOiBcIlwiLFxuICAgIHRva2VuX3NhdmVkOiAhMSxcbiAgICBhY2Nlc3NfcmVxdWVzdGVkOiAhMSxcbiAgICBhY2Nlc3NfZ3JhbnRlZDogITEsXG4gICAgdHlwZTogXCJcIlxuICB9O1xuICByZXR1cm4ge1xuICAgIGF2YWlsYWJsZTogITAsXG4gICAgdHlwZTogdC50eXBlLFxuICAgIGRldmljZUlkOiB0LmRldmljZV9pZCxcbiAgICB0b2tlblNhdmVkOiB0LnRva2VuX3NhdmVkLFxuICAgIGFjY2Vzc1JlcXVlc3RlZDogdC5hY2Nlc3NfcmVxdWVzdGVkLFxuICAgIGFjY2Vzc0dyYW50ZWQ6IHQuYWNjZXNzX2dyYW50ZWRcbiAgfTtcbn1cbmNsYXNzIGplIGV4dGVuZHMgTCB7XG4gIGNvbnN0cnVjdG9yKHsgcG9zdEV2ZW50OiB0LCB2ZXJzaW9uOiBzLCAuLi5uIH0pIHtcbiAgICBzdXBlcihuLCBzLCB7XG4gICAgICBhdXRoOiBcIndlYl9hcHBfYmlvbWV0cnlfcmVxdWVzdF9hdXRoXCIsXG4gICAgICBvcGVuU2V0dGluZ3M6IFwid2ViX2FwcF9iaW9tZXRyeV9vcGVuX3NldHRpbmdzXCIsXG4gICAgICByZXF1ZXN0QWNjZXNzOiBcIndlYl9hcHBfYmlvbWV0cnlfcmVxdWVzdF9hY2Nlc3NcIixcbiAgICAgIHVwZGF0ZVRva2VuOiBcIndlYl9hcHBfYmlvbWV0cnlfdXBkYXRlX3Rva2VuXCJcbiAgICB9KSwgYyh0aGlzLCBcInBvc3RFdmVudFwiKSwgYyh0aGlzLCBcImF1dGhQcm9taXNlXCIpLCBjKHRoaXMsIFwiYWNjZXNzUHJvbWlzZVwiKSwgdGhpcy5wb3N0RXZlbnQgPSB0O1xuICB9XG4gIC8qKlxuICAgKiBTaG93cyB3aGV0aGVyIGJpb21ldHJ5IGlzIGF2YWlsYWJsZS5cbiAgICovXG4gIGdldCBhdmFpbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiYXZhaWxhYmxlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTaG93cyB3aGV0aGVyIHBlcm1pc3Npb24gdG8gdXNlIGJpb21ldHJpY3MgaGFzIGJlZW4gZ3JhbnRlZC5cbiAgICovXG4gIGdldCBhY2Nlc3NHcmFudGVkKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImFjY2Vzc0dyYW50ZWRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNob3dzIHdoZXRoZXIgaWYgcGVybWlzc2lvbiB0byB1c2UgYmlvbWV0cmljcyBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gICAqL1xuICBnZXQgYWNjZXNzUmVxdWVzdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImFjY2Vzc1JlcXVlc3RlZFwiKTtcbiAgfVxuICAvKipcbiAgICogQXV0aGVudGljYXRlcyB0aGUgdXNlciB1c2luZyBiaW9tZXRyaWNzLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIG1ldGhvZCBvcHRpb25zLlxuICAgKiBAc2luY2UgNy4yXG4gICAqIEByZXR1cm5zIFRva2VuIGZyb20gdGhlIGxvY2FsIHNlY3VyZSBzdG9yYWdlLCBpZiBhdXRoZW50aWNhdGlvbiB3YXMgc3VjY2Vzc2Z1bC5cbiAgICovXG4gIGFzeW5jIGF1dGhlbnRpY2F0ZSh7XG4gICAgcmVhc29uOiB0LFxuICAgIC4uLnNcbiAgfSkge1xuICAgIHJldHVybiB0aGlzLmF1dGhQcm9taXNlIHx8ICh0aGlzLmF1dGhQcm9taXNlID0gZyh7XG4gICAgICAuLi5zLFxuICAgICAgbWV0aG9kOiBcIndlYl9hcHBfYmlvbWV0cnlfcmVxdWVzdF9hdXRoXCIsXG4gICAgICBldmVudDogXCJiaW9tZXRyeV9hdXRoX3JlcXVlc3RlZFwiLFxuICAgICAgcG9zdEV2ZW50OiB0aGlzLnBvc3RFdmVudCxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICAvLyBUT0RPOiBDaGVjayBpZiByZWFzb24gaXMgZW1wdHkgd29ya3MgZmluZS5cbiAgICAgICAgcmVhc29uOiAodCB8fCBcIlwiKS50cmltKClcbiAgICAgIH1cbiAgICB9KS50aGVuKCh7IHRva2VuOiBuIH0pID0+IG4pLmZpbmFsbHkoKCkgPT4gdGhpcy5hdXRoUHJvbWlzZSA9IHZvaWQgMCkpLCB0aGlzLmF1dGhQcm9taXNlO1xuICB9XG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBkZXZpY2UgaWRlbnRpZmllciB0aGF0IGNhbiBiZSB1c2VkIHRvIG1hdGNoIHRoZSB0b2tlbiB0byB0aGUgZGV2aWNlLlxuICAgKi9cbiAgZ2V0IGRldmljZUlkKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImRldmljZUlkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBPcGVucyB0aGUgYmlvbWV0cmljIGFjY2VzcyBzZXR0aW5ncyBmb3IgYm90cy4gVXNlZnVsIHdoZW4geW91IG5lZWQgdG8gcmVxdWVzdCBiaW9tZXRyaWNzXG4gICAqIGFjY2VzcyB0byB1c2VycyB3aG8gaGF2ZW4ndCBncmFudGVkIGl0IHlldC5cbiAgICpcbiAgICogX05vdGUgdGhhdCB0aGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIG9ubHkgaW4gcmVzcG9uc2UgdG8gdXNlciBpbnRlcmFjdGlvbiB3aXRoIHRoZSBNaW5pIEFwcFxuICAgKiBpbnRlcmZhY2UgKGUuZy4gYSBjbGljayBpbnNpZGUgdGhlIE1pbmkgQXBwIG9yIG9uIHRoZSBtYWluIGJ1dHRvbilfLlxuICAgKiBAc2luY2UgNy4yXG4gICAqL1xuICBvcGVuU2V0dGluZ3MoKSB7XG4gICAgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX2Jpb21ldHJ5X29wZW5fc2V0dGluZ3NcIik7XG4gIH1cbiAgLyoqXG4gICAqIFJlcXVlc3RzIHBlcm1pc3Npb24gdG8gdXNlIGJpb21ldHJpY3MuXG4gICAqIEBzaW5jZSA3LjJcbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHRydWUsIGlmIGFjY2VzcyB3YXMgZ3JhbnRlZC5cbiAgICovXG4gIHJlcXVlc3RBY2Nlc3MoeyByZWFzb246IHQsIC4uLnMgfSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuYWNjZXNzUHJvbWlzZSB8fCAodGhpcy5hY2Nlc3NQcm9taXNlID0gZyh7XG4gICAgICAuLi5zLFxuICAgICAgcG9zdEV2ZW50OiB0aGlzLnBvc3RFdmVudCxcbiAgICAgIG1ldGhvZDogXCJ3ZWJfYXBwX2Jpb21ldHJ5X3JlcXVlc3RfYWNjZXNzXCIsXG4gICAgICBldmVudDogXCJiaW9tZXRyeV9pbmZvX3JlY2VpdmVkXCIsXG4gICAgICBwYXJhbXM6IHsgcmVhc29uOiB0IHx8IFwiXCIgfVxuICAgIH0pLnRoZW4oKG4pID0+IHtcbiAgICAgIGNvbnN0IHIgPSBZdChuKTtcbiAgICAgIHJldHVybiB0aGlzLnNldChyKSwgci5hY2Nlc3NHcmFudGVkO1xuICAgIH0pLmZpbmFsbHkoKCkgPT4gdGhpcy5hY2Nlc3NQcm9taXNlID0gdm9pZCAwKSksIHRoaXMuYWNjZXNzUHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgYmlvbWV0cmljcyBjdXJyZW50bHkgYXZhaWxhYmxlIG9uIHRoZSBkZXZpY2UuXG4gICAqL1xuICBnZXQgYmlvbWV0cnlUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImJpb21ldHJ5VHlwZVwiKTtcbiAgfVxuICAvKipcbiAgICogU2hvd3Mgd2hldGhlciB0b2tlbiB3YXMgc2F2ZWQgcHJldmlvdXNseSBpbiB0aGUgbG9jYWwgc2VjdXJlIHN0b3JhZ2UuXG4gICAqL1xuICBnZXQgdG9rZW5TYXZlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJ0b2tlblNhdmVkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBiaW9tZXRyaWMgdG9rZW4gaW4gYSBzZWN1cmUgc3RvcmFnZSBvbiB0aGUgZGV2aWNlLlxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggYHRydWVgLCBpZiB0b2tlbiB3YXMgdXBkYXRlZC5cbiAgICovXG4gIGFzeW5jIHVwZGF0ZVRva2VuKHsgdG9rZW46IHQsIC4uLnMgfSA9IHt9KSB7XG4gICAgcmV0dXJuIFtcInJlbW92ZWRcIiwgXCJ1cGRhdGVkXCJdLmluY2x1ZGVzKFxuICAgICAgKGF3YWl0IGcoe1xuICAgICAgICAuLi5zLFxuICAgICAgICBwb3N0RXZlbnQ6IHRoaXMucG9zdEV2ZW50LFxuICAgICAgICBtZXRob2Q6IFwid2ViX2FwcF9iaW9tZXRyeV91cGRhdGVfdG9rZW5cIixcbiAgICAgICAgZXZlbnQ6IFwiYmlvbWV0cnlfdG9rZW5fdXBkYXRlZFwiLFxuICAgICAgICBwYXJhbXM6IHsgdG9rZW46IHQgfHwgXCJcIiB9XG4gICAgICB9KSkuc3RhdHVzXG4gICAgKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gemUoZSkge1xuICByZXR1cm4gWXQoXG4gICAgYXdhaXQgZyh7XG4gICAgICAuLi5lIHx8IHt9LFxuICAgICAgbWV0aG9kOiBcIndlYl9hcHBfYmlvbWV0cnlfZ2V0X2luZm9cIixcbiAgICAgIGV2ZW50OiBcImJpb21ldHJ5X2luZm9fcmVjZWl2ZWRcIlxuICAgIH0pXG4gICk7XG59XG5jb25zdCBLZSA9IGwoXG4gIFwiYmlvbWV0cnlNYW5hZ2VyXCIsXG4gIGFzeW5jICh7IHBvc3RFdmVudDogZSwgdmVyc2lvbjogdCwgc3RhdGU6IHMgfSkgPT4gbmV3IGplKHtcbiAgICAuLi5zIHx8IEMoXCJ3ZWJfYXBwX2Jpb21ldHJ5X2dldF9pbmZvXCIsIHQpID8gcyB8fCBhd2FpdCB6ZSh7IHRpbWVvdXQ6IDFlMyB9KSA6IHtcbiAgICAgIGF2YWlsYWJsZTogITEsXG4gICAgICBhY2Nlc3NHcmFudGVkOiAhMSxcbiAgICAgIGFjY2Vzc1JlcXVlc3RlZDogITEsXG4gICAgICB0b2tlblNhdmVkOiAhMSxcbiAgICAgIGRldmljZUlkOiBcIlwiXG4gICAgfSxcbiAgICB2ZXJzaW9uOiB0LFxuICAgIHBvc3RFdmVudDogZVxuICB9KVxuKTtcbmNsYXNzIF90IGV4dGVuZHMgcHQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCBjKHRoaXMsIFwib25cIiwgdGhpcy5zdGF0ZS5vbi5iaW5kKHRoaXMuc3RhdGUpKSwgYyh0aGlzLCBcIm9mZlwiLCB0aGlzLnN0YXRlLm9mZi5iaW5kKHRoaXMuc3RhdGUpKTtcbiAgfVxufVxuY2xhc3MgSmUgZXh0ZW5kcyBfdCB7XG4gIGNvbnN0cnVjdG9yKHQsIHMpIHtcbiAgICBzdXBlcih7IGlzQ29uZmlybWF0aW9uTmVlZGVkOiB0IH0pLCB0aGlzLnBvc3RFdmVudCA9IHM7XG4gIH1cbiAgc2V0IGlzQ29uZmlybWF0aW9uTmVlZGVkKHQpIHtcbiAgICB0aGlzLnNldChcImlzQ29uZmlybWF0aW9uTmVlZGVkXCIsIHQpLCB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfc2V0dXBfY2xvc2luZ19iZWhhdmlvclwiLCB7IG5lZWRfY29uZmlybWF0aW9uOiB0IH0pO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlLCBpZiB0aGUgY29uZmlybWF0aW9uIGRpYWxvZyBzaG91bGQgYmUgc2hvd24gd2hpbGUgdGhlIHVzZXIgaXMgdHJ5aW5nIHRvIGNsb3NlXG4gICAqIHRoZSBNaW5pIEFwcC5cbiAgICovXG4gIGdldCBpc0NvbmZpcm1hdGlvbk5lZWRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJpc0NvbmZpcm1hdGlvbk5lZWRlZFwiKTtcbiAgfVxuICAvKipcbiAgICogRGlzYWJsZXMgdGhlIGNvbmZpcm1hdGlvbiBkaWFsb2cgd2hlbiBjbG9zaW5nIHRoZSBNaW5pIEFwcC5cbiAgICovXG4gIGRpc2FibGVDb25maXJtYXRpb24oKSB7XG4gICAgdGhpcy5pc0NvbmZpcm1hdGlvbk5lZWRlZCA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIHRoZSBjb25maXJtYXRpb24gZGlhbG9nIHdoZW4gY2xvc2luZyB0aGUgTWluaSBBcHAuXG4gICAqL1xuICBlbmFibGVDb25maXJtYXRpb24oKSB7XG4gICAgdGhpcy5pc0NvbmZpcm1hdGlvbk5lZWRlZCA9ICEwO1xuICB9XG59XG5jb25zdCBGZSA9IGwoXG4gIFwiY2xvc2luZ0JlaGF2aW9yXCIsXG4gICh7XG4gICAgcG9zdEV2ZW50OiBlLFxuICAgIHN0YXRlOiB0ID0geyBpc0NvbmZpcm1hdGlvbk5lZWRlZDogITEgfVxuICB9KSA9PiBuZXcgSmUodC5pc0NvbmZpcm1hdGlvbk5lZWRlZCwgZSlcbik7XG5jbGFzcyB3dCB7XG4gIGNvbnN0cnVjdG9yKHQsIHMpIHtcbiAgICBjKHRoaXMsIFwic3VwcG9ydHNcIiksIHRoaXMuc3VwcG9ydHMgPSBMdCh0LCBzKTtcbiAgfVxufVxuZnVuY3Rpb24gUWUoZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShlKSlcbiAgICByZXR1cm4gZTtcbiAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHQgPSBKU09OLnBhcnNlKGUpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpXG4gICAgICAgIHJldHVybiB0O1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgdGhyb3cgVCgpO1xufVxuY2xhc3MgWWUgZXh0ZW5kcyBHIHtcbiAgY29uc3RydWN0b3IodCwgcywgbikge1xuICAgIHN1cGVyKFFlLCBzLCBuKSwgYyh0aGlzLCBcIml0ZW1QYXJzZXJcIiksIHRoaXMuaXRlbVBhcnNlciA9IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IHQgOiB0LnBhcnNlLmJpbmQodCk7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIHBhcnNlIHBhc3NlZCB2YWx1ZVxuICAgKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSB0byBwYXJzZS5cbiAgICogQHRocm93cyB7U0RLRXJyb3J9IEVSUl9QQVJTRVxuICAgKiBAc2VlIEVSUl9QQVJTRVxuICAgKi9cbiAgcGFyc2UodCkge1xuICAgIGNvbnN0IHMgPSBzdXBlci5wYXJzZSh0KTtcbiAgICByZXR1cm4gcyA9PT0gdm9pZCAwID8gcyA6IHMubWFwKHRoaXMuaXRlbVBhcnNlcik7XG4gIH1cbiAgb2YodCkge1xuICAgIHJldHVybiB0aGlzLml0ZW1QYXJzZXIgPSB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyB0IDogdC5wYXJzZS5iaW5kKHQpLCB0aGlzO1xuICB9XG59XG5mdW5jdGlvbiBaZShlKSB7XG4gIHJldHVybiBuZXcgWWUoKHQpID0+IHQsICExLCBlKTtcbn1cbmZ1bmN0aW9uIEV0KGUsIHQpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhlLm1hcCgocykgPT4gW3MsIHRdKSk7XG59XG5jbGFzcyBYZSBleHRlbmRzIHd0IHtcbiAgY29uc3RydWN0b3IodCwgcywgbikge1xuICAgIHN1cGVyKHQsIHtcbiAgICAgIGRlbGV0ZTogXCJ3ZWJfYXBwX2ludm9rZV9jdXN0b21fbWV0aG9kXCIsXG4gICAgICBnZXQ6IFwid2ViX2FwcF9pbnZva2VfY3VzdG9tX21ldGhvZFwiLFxuICAgICAgZ2V0S2V5czogXCJ3ZWJfYXBwX2ludm9rZV9jdXN0b21fbWV0aG9kXCIsXG4gICAgICBzZXQ6IFwid2ViX2FwcF9pbnZva2VfY3VzdG9tX21ldGhvZFwiXG4gICAgfSksIHRoaXMuY3JlYXRlUmVxdWVzdElkID0gcywgdGhpcy5wb3N0RXZlbnQgPSBuO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIHNwZWNpZmllZCBrZXkgb3Iga2V5cyBmcm9tIHRoZSBjbG91ZCBzdG9yYWdlLlxuICAgKiBAcGFyYW0ga2V5T3JLZXlzIC0ga2V5IG9yIGtleXMgdG8gZGVsZXRlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHJlcXVlc3QgZXhlY3V0aW9uIG9wdGlvbnMuXG4gICAqL1xuICBhc3luYyBkZWxldGUodCwgcyA9IHt9KSB7XG4gICAgY29uc3QgbiA9IEFycmF5LmlzQXJyYXkodCkgPyB0IDogW3RdO1xuICAgIG4ubGVuZ3RoICYmIGF3YWl0IE8oXG4gICAgICBcImRlbGV0ZVN0b3JhZ2VWYWx1ZXNcIixcbiAgICAgIHsga2V5czogbiB9LFxuICAgICAgdGhpcy5jcmVhdGVSZXF1ZXN0SWQoKSxcbiAgICAgIHsgLi4ucywgcG9zdEV2ZW50OiB0aGlzLnBvc3RFdmVudCB9XG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBsaXN0IG9mIGFsbCBrZXlzIHByZXNlbnRlZCBpbiB0aGUgY2xvdWQgc3RvcmFnZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSByZXF1ZXN0IGV4ZWN1dGlvbiBvcHRpb25zLlxuICAgKi9cbiAgYXN5bmMgZ2V0S2V5cyh0ID0ge30pIHtcbiAgICByZXR1cm4gWmUoKS5vZihoKCkpLnBhcnNlKFxuICAgICAgYXdhaXQgTyhcbiAgICAgICAgXCJnZXRTdG9yYWdlS2V5c1wiLFxuICAgICAgICB7fSxcbiAgICAgICAgdGhpcy5jcmVhdGVSZXF1ZXN0SWQoKSxcbiAgICAgICAgeyAuLi50LCBwb3N0RXZlbnQ6IHRoaXMucG9zdEV2ZW50IH1cbiAgICAgIClcbiAgICApO1xuICB9XG4gIGFzeW5jIGdldCh0LCBzID0ge30pIHtcbiAgICBjb25zdCBuID0gQXJyYXkuaXNBcnJheSh0KSA/IHQgOiBbdF07XG4gICAgaWYgKCFuLmxlbmd0aClcbiAgICAgIHJldHVybiBFdChuLCBcIlwiKTtcbiAgICBjb25zdCByID0gYXdhaXQgTyhcbiAgICAgIFwiZ2V0U3RvcmFnZVZhbHVlc1wiLFxuICAgICAgeyBrZXlzOiBuIH0sXG4gICAgICB0aGlzLmNyZWF0ZVJlcXVlc3RJZCgpLFxuICAgICAgeyAuLi5zLCBwb3N0RXZlbnQ6IHRoaXMucG9zdEV2ZW50IH1cbiAgICApLCBpID0gdyhFdChuLCBoKCkpLCBcIkNsb3VkU3RvcmFnZURhdGFcIikucGFyc2Uocik7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodCkgPyBpIDogaVt0XTtcbiAgfVxuICAvKipcbiAgICogU2F2ZXMgc3BlY2lmaWVkIHZhbHVlIGJ5IGtleS5cbiAgICogQHBhcmFtIGtleSAtIHN0b3JhZ2Uga2V5LlxuICAgKiBAcGFyYW0gdmFsdWUgLSBzdG9yYWdlIHZhbHVlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHJlcXVlc3QgZXhlY3V0aW9uIG9wdGlvbnMuXG4gICAqL1xuICBhc3luYyBzZXQodCwgcywgbiA9IHt9KSB7XG4gICAgYXdhaXQgTyhcbiAgICAgIFwic2F2ZVN0b3JhZ2VWYWx1ZVwiLFxuICAgICAgeyBrZXk6IHQsIHZhbHVlOiBzIH0sXG4gICAgICB0aGlzLmNyZWF0ZVJlcXVlc3RJZCgpLFxuICAgICAgeyAuLi5uLCBwb3N0RXZlbnQ6IHRoaXMucG9zdEV2ZW50IH1cbiAgICApO1xuICB9XG59XG5jb25zdCB0cyA9IGwoXG4gICh7IGNyZWF0ZVJlcXVlc3RJZDogZSwgcG9zdEV2ZW50OiB0LCB2ZXJzaW9uOiBzIH0pID0+IG5ldyBYZShzLCBlLCB0KVxuKTtcbmNsYXNzIGVzIGV4dGVuZHMgd3Qge1xuICBjb25zdHJ1Y3Rvcih0LCBzKSB7XG4gICAgc3VwZXIodCwge1xuICAgICAgaW1wYWN0T2NjdXJyZWQ6IFwid2ViX2FwcF90cmlnZ2VyX2hhcHRpY19mZWVkYmFja1wiLFxuICAgICAgbm90aWZpY2F0aW9uT2NjdXJyZWQ6IFwid2ViX2FwcF90cmlnZ2VyX2hhcHRpY19mZWVkYmFja1wiLFxuICAgICAgc2VsZWN0aW9uQ2hhbmdlZDogXCJ3ZWJfYXBwX3RyaWdnZXJfaGFwdGljX2ZlZWRiYWNrXCJcbiAgICB9KSwgdGhpcy5wb3N0RXZlbnQgPSBzO1xuICB9XG4gIC8qKlxuICAgKiBBIG1ldGhvZCB0ZWxscyB0aGF0IGFuIGltcGFjdCBvY2N1cnJlZC4gVGhlIFRlbGVncmFtIGFwcCBtYXkgcGxheSB0aGVcbiAgICogYXBwcm9wcmlhdGUgaGFwdGljcyBiYXNlZCBvbiBzdHlsZSB2YWx1ZSBwYXNzZWQuXG4gICAqIEBwYXJhbSBzdHlsZSAtIGltcGFjdCBzdHlsZS5cbiAgICovXG4gIGltcGFjdE9jY3VycmVkKHQpIHtcbiAgICB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfdHJpZ2dlcl9oYXB0aWNfZmVlZGJhY2tcIiwge1xuICAgICAgdHlwZTogXCJpbXBhY3RcIixcbiAgICAgIGltcGFjdF9zdHlsZTogdFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBIG1ldGhvZCB0ZWxscyB0aGF0IGEgdGFzayBvciBhY3Rpb24gaGFzIHN1Y2NlZWRlZCwgZmFpbGVkLCBvciBwcm9kdWNlZFxuICAgKiBhIHdhcm5pbmcuIFRoZSBUZWxlZ3JhbSBhcHAgbWF5IHBsYXkgdGhlIGFwcHJvcHJpYXRlIGhhcHRpY3MgYmFzZWQgb25cbiAgICogdHlwZSB2YWx1ZSBwYXNzZWQuXG4gICAqIEBwYXJhbSB0eXBlIC0gbm90aWZpY2F0aW9uIHR5cGUuXG4gICAqL1xuICBub3RpZmljYXRpb25PY2N1cnJlZCh0KSB7XG4gICAgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX3RyaWdnZXJfaGFwdGljX2ZlZWRiYWNrXCIsIHtcbiAgICAgIHR5cGU6IFwibm90aWZpY2F0aW9uXCIsXG4gICAgICBub3RpZmljYXRpb25fdHlwZTogdFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBIG1ldGhvZCB0ZWxscyB0aGF0IHRoZSB1c2VyIGhhcyBjaGFuZ2VkIGEgc2VsZWN0aW9uLiBUaGUgVGVsZWdyYW0gYXBwXG4gICAqIG1heSBwbGF5IHRoZSBhcHByb3ByaWF0ZSBoYXB0aWNzLlxuICAgKlxuICAgKiBEbyBub3QgdXNlIHRoaXMgZmVlZGJhY2sgd2hlbiB0aGUgdXNlciBtYWtlcyBvciBjb25maXJtcyBhIHNlbGVjdGlvbjtcbiAgICogdXNlIGl0IG9ubHkgd2hlbiB0aGUgc2VsZWN0aW9uIGNoYW5nZXMuXG4gICAqL1xuICBzZWxlY3Rpb25DaGFuZ2VkKCkge1xuICAgIHRoaXMucG9zdEV2ZW50KFwid2ViX2FwcF90cmlnZ2VyX2hhcHRpY19mZWVkYmFja1wiLCB7IHR5cGU6IFwic2VsZWN0aW9uX2NoYW5nZVwiIH0pO1xuICB9XG59XG5jb25zdCBzcyA9IGwoXG4gICh7IHZlcnNpb246IGUsIHBvc3RFdmVudDogdCB9KSA9PiBuZXcgZXMoZSwgdClcbik7XG5jbGFzcyBucyB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICB0aGlzLmluaXREYXRhID0gdDtcbiAgfVxuICAvKipcbiAgICogQHNlZSBJbml0RGF0YVBhcnNlZC5hdXRoRGF0ZVxuICAgKi9cbiAgZ2V0IGF1dGhEYXRlKCkge1xuICAgIHJldHVybiB0aGlzLmluaXREYXRhLmF1dGhEYXRlO1xuICB9XG4gIC8qKlxuICAgKiBAc2VlIEluaXREYXRhUGFyc2VkLmNhblNlbmRBZnRlclxuICAgKi9cbiAgZ2V0IGNhblNlbmRBZnRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pbml0RGF0YS5jYW5TZW5kQWZ0ZXI7XG4gIH1cbiAgLyoqXG4gICAqIERhdGUgYWZ0ZXIgd2hpY2ggaXQgaXMgYWxsb3dlZCB0byBjYWxsXG4gICAqIHRoZSBbYW5zd2VyV2ViQXBwUXVlcnldKGh0dHBzOi8vY29yZS50ZWxlZ3JhbS5vcmcvYm90cy9hcGkjYW5zd2Vyd2ViYXBwcXVlcnkpIG1ldGhvZC5cbiAgICovXG4gIGdldCBjYW5TZW5kQWZ0ZXJEYXRlKCkge1xuICAgIGNvbnN0IHsgY2FuU2VuZEFmdGVyOiB0IH0gPSB0aGlzO1xuICAgIHJldHVybiB0ID8gbmV3IERhdGUodGhpcy5hdXRoRGF0ZS5nZXRUaW1lKCkgKyB0ICogMWUzKSA6IHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogQHNlZSBJbml0RGF0YVBhcnNlZC5jaGF0XG4gICAqL1xuICBnZXQgY2hhdCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbml0RGF0YS5jaGF0O1xuICB9XG4gIC8qKlxuICAgKiBAc2VlIEluaXREYXRhUGFyc2VkLmNoYXRUeXBlXG4gICAqL1xuICBnZXQgY2hhdFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdERhdGEuY2hhdFR5cGU7XG4gIH1cbiAgLyoqXG4gICAqIEBzZWUgSW5pdERhdGFQYXJzZWQuY2hhdEluc3RhbmNlXG4gICAqL1xuICBnZXQgY2hhdEluc3RhbmNlKCkge1xuICAgIHJldHVybiB0aGlzLmluaXREYXRhLmNoYXRJbnN0YW5jZTtcbiAgfVxuICAvKipcbiAgICogQHNlZSBJbml0RGF0YVBhcnNlZC5oYXNoXG4gICAqL1xuICBnZXQgaGFzaCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbml0RGF0YS5oYXNoO1xuICB9XG4gIC8qKlxuICAgKiBAc2VlIEluaXREYXRhUGFyc2VkLnF1ZXJ5SWRcbiAgICovXG4gIGdldCBxdWVyeUlkKCkge1xuICAgIHJldHVybiB0aGlzLmluaXREYXRhLnF1ZXJ5SWQ7XG4gIH1cbiAgLyoqXG4gICAqIEBzZWUgSW5pdERhdGFQYXJzZWQucmVjZWl2ZXJcbiAgICovXG4gIGdldCByZWNlaXZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pbml0RGF0YS5yZWNlaXZlcjtcbiAgfVxuICAvKipcbiAgICogQHNlZSBJbml0RGF0YVBhcnNlZC5zdGFydFBhcmFtXG4gICAqL1xuICBnZXQgc3RhcnRQYXJhbSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbml0RGF0YS5zdGFydFBhcmFtO1xuICB9XG4gIC8qKlxuICAgKiBAc2VlIEluaXREYXRhUGFyc2VkLnVzZXJcbiAgICovXG4gIGdldCB1c2VyKCkge1xuICAgIHJldHVybiB0aGlzLmluaXREYXRhLnVzZXI7XG4gIH1cbn1cbmNvbnN0IHJzID0gbChcbiAgKHsgaW5pdERhdGE6IGUgfSkgPT4gZSA/IG5ldyBucyhlKSA6IHZvaWQgMFxuKTtcbmZ1bmN0aW9uIGZuKGUpIHtcbiAgcmV0dXJuIFV0KCkucGFyc2UoZSk7XG59XG5jbGFzcyBpcyBleHRlbmRzIEwge1xuICBjb25zdHJ1Y3Rvcih0LCBzLCBuKSB7XG4gICAgc3VwZXIoeyBpc09wZW5lZDogdCB9LCBzLCB7IG9wZW46IFwid2ViX2FwcF9vcGVuX2ludm9pY2VcIiB9KSwgdGhpcy5wb3N0RXZlbnQgPSBuO1xuICB9XG4gIHNldCBpc09wZW5lZCh0KSB7XG4gICAgdGhpcy5zZXQoXCJpc09wZW5lZFwiLCB0KTtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiBpbnZvaWNlIGlzIGN1cnJlbnRseSBvcGVuZWQuXG4gICAqL1xuICBnZXQgaXNPcGVuZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiaXNPcGVuZWRcIik7XG4gIH1cbiAgYXN5bmMgb3Blbih0LCBzKSB7XG4gICAgaWYgKHRoaXMuaXNPcGVuZWQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZvaWNlIGlzIGFscmVhZHkgb3BlbmVkXCIpO1xuICAgIGxldCBuO1xuICAgIGlmICghcylcbiAgICAgIG4gPSB0O1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgeyBob3N0bmFtZTogciwgcGF0aG5hbWU6IGkgfSA9IG5ldyBVUkwodCwgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgaWYgKHIgIT09IFwidC5tZVwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluY29ycmVjdCBob3N0bmFtZTogJHtyfWApO1xuICAgICAgY29uc3QgbyA9IGkubWF0Y2goL15cXC8oXFwkfGludm9pY2VcXC8pKFtBLVphLXowLTlcXC1fPV0rKSQvKTtcbiAgICAgIGlmICghbylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMaW5rIHBhdGhuYW1lIGhhcyBpbmNvcnJlY3QgZm9ybWF0LiBFeHBlY3RlZCB0byByZWNlaXZlIFwiL2ludm9pY2Uve3NsdWd9XCIgb3IgXCIvJHtzbHVnfVwiJyk7XG4gICAgICBbLCAsIG5dID0gbztcbiAgICB9XG4gICAgdGhpcy5pc09wZW5lZCA9ICEwO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGF3YWl0IGcoe1xuICAgICAgICBtZXRob2Q6IFwid2ViX2FwcF9vcGVuX2ludm9pY2VcIixcbiAgICAgICAgZXZlbnQ6IFwiaW52b2ljZV9jbG9zZWRcIixcbiAgICAgICAgcGFyYW1zOiB7IHNsdWc6IG4gfSxcbiAgICAgICAgcG9zdEV2ZW50OiB0aGlzLnBvc3RFdmVudCxcbiAgICAgICAgY2FwdHVyZShyKSB7XG4gICAgICAgICAgcmV0dXJuIG4gPT09IHIuc2x1ZztcbiAgICAgICAgfVxuICAgICAgfSkpLnN0YXR1cztcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5pc09wZW5lZCA9ICExO1xuICAgIH1cbiAgfVxufVxuY29uc3Qgb3MgPSBsKFxuICAoeyB2ZXJzaW9uOiBlLCBwb3N0RXZlbnQ6IHQgfSkgPT4gbmV3IGlzKCExLCBlLCB0KVxuKTtcbmNsYXNzIGFzIGV4dGVuZHMgcHQge1xuICBjb25zdHJ1Y3Rvcih7IHBvc3RFdmVudDogdCwgLi4ucyB9KSB7XG4gICAgc3VwZXIocyksIGModGhpcywgXCJwb3N0RXZlbnRcIiksIGModGhpcywgXCJvblwiLCAobiwgcikgPT4gbiA9PT0gXCJjbGlja1wiID8geShcIm1haW5fYnV0dG9uX3ByZXNzZWRcIiwgcikgOiB0aGlzLnN0YXRlLm9uKG4sIHIpKSwgYyh0aGlzLCBcIm9mZlwiLCAobiwgcikgPT4gbiA9PT0gXCJjbGlja1wiID8geihcIm1haW5fYnV0dG9uX3ByZXNzZWRcIiwgcikgOiB0aGlzLnN0YXRlLm9mZihuLCByKSksIHRoaXMucG9zdEV2ZW50ID0gdDtcbiAgfVxuICAvKipcbiAgICogVGhlIE1haW5CdXR0b24gYmFja2dyb3VuZCBjb2xvci5cbiAgICovXG4gIGdldCBiZ0NvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImJnQ29sb3JcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNlbmRzIGN1cnJlbnQgbG9jYWwgc3RhdGUgdG8gdGhlIFRlbGVncmFtIGFwcGxpY2F0aW9uLlxuICAgKi9cbiAgY29tbWl0KCkge1xuICAgIHRoaXMudGV4dCAhPT0gXCJcIiAmJiB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfc2V0dXBfbWFpbl9idXR0b25cIiwge1xuICAgICAgaXNfdmlzaWJsZTogdGhpcy5pc1Zpc2libGUsXG4gICAgICBpc19hY3RpdmU6IHRoaXMuaXNFbmFibGVkLFxuICAgICAgaXNfcHJvZ3Jlc3NfdmlzaWJsZTogdGhpcy5pc0xvYWRlclZpc2libGUsXG4gICAgICB0ZXh0OiB0aGlzLnRleHQsXG4gICAgICBjb2xvcjogdGhpcy5iZ0NvbG9yLFxuICAgICAgdGV4dF9jb2xvcjogdGhpcy50ZXh0Q29sb3JcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRGlzYWJsZXMgdGhlIE1haW5CdXR0b24uXG4gICAqIEBzZWUgRG9lcyBub3Qgd29yayBvbiBBbmRyb2lkOiBodHRwczovL2dpdGh1Yi5jb20vVGVsZWdyYW0tTWluaS1BcHBzL2lzc3Vlcy9pc3N1ZXMvMVxuICAgKi9cbiAgZGlzYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0VuYWJsZWQgPSAhMSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyB0aGUgTWFpbkJ1dHRvbi5cbiAgICovXG4gIGVuYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0VuYWJsZWQgPSAhMCwgdGhpcztcbiAgfVxuICAvKipcbiAgICogSGlkZXMgdGhlIE1haW5CdXR0b24uXG4gICAqL1xuICBoaWRlKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmlzaWJsZSA9ICExLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBIaWRlcyB0aGUgTWFpbkJ1dHRvbiBsb2FkaW5nIGluZGljYXRvci5cbiAgICovXG4gIGhpZGVMb2FkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNMb2FkZXJWaXNpYmxlID0gITEsIHRoaXM7XG4gIH1cbiAgc2V0IGlzRW5hYmxlZCh0KSB7XG4gICAgdGhpcy5zZXRQYXJhbXMoeyBpc0VuYWJsZWQ6IHQgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgdGhlIE1haW5CdXR0b24gaXMgZW5hYmxlZC5cbiAgICovXG4gIGdldCBpc0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiaXNFbmFibGVkXCIpO1xuICB9XG4gIHNldCBpc0xvYWRlclZpc2libGUodCkge1xuICAgIHRoaXMuc2V0UGFyYW1zKHsgaXNMb2FkZXJWaXNpYmxlOiB0IH0pO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIHRoZSBNYWluQnV0dG9uIGxvYWRlciBpcyB2aXNpYmxlLlxuICAgKi9cbiAgZ2V0IGlzTG9hZGVyVmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJpc0xvYWRlclZpc2libGVcIik7XG4gIH1cbiAgc2V0IGlzVmlzaWJsZSh0KSB7XG4gICAgdGhpcy5zZXRQYXJhbXMoeyBpc1Zpc2libGU6IHQgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgdGhlIE1haW5CdXR0b24gaXMgdmlzaWJsZS5cbiAgICovXG4gIGdldCBpc1Zpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiaXNWaXNpYmxlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTaG93cyB0aGUgTWFpbkJ1dHRvbi5cbiAgICpcbiAgICogTm90ZSB0aGF0IG9wZW5pbmcgdGhlIE1pbmkgQXBwIGZyb20gdGhlIGF0dGFjaG1lbnQgbWVudSBoaWRlcyB0aGUgbWFpbiBidXR0b24gdW50aWwgdGhlXG4gICAqIHVzZXIgaW50ZXJhY3RzIHdpdGggdGhlIE1pbmkgQXBwIGludGVyZmFjZS5cbiAgICovXG4gIHNob3coKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWaXNpYmxlID0gITAsIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFNob3dzIGEgbG9hZGluZyBpbmRpY2F0b3Igb24gdGhlIE1haW4gQnV0dG9uLlxuICAgKi9cbiAgc2hvd0xvYWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc0xvYWRlclZpc2libGUgPSAhMCwgdGhpcztcbiAgfVxuICAvKipcbiAgICogU2V0cyBhIG5ldyBNYWluQnV0dG9uIHRleHQuIE1pbmltYWwgbGVuZ3RoIGZvciB0aGUgdGV4dCBpcyAxIHN5bWJvbCwgYW5kIG1heGltdW0gaXMgNjQgc3ltYm9scy5cbiAgICogQHBhcmFtIHRleHQgLSBhIG5ldyB0ZXh0LlxuICAgKi9cbiAgc2V0VGV4dCh0KSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0UGFyYW1zKHsgdGV4dDogdCB9KTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBhIG5ldyBNYWluIEJ1dHRvbiB0ZXh0IGNvbG9yLlxuICAgKiBAcGFyYW0gdGV4dENvbG9yIC0gbmV3IHRleHQgY29sb3IuXG4gICAqL1xuICBzZXRUZXh0Q29sb3IodCkge1xuICAgIHJldHVybiB0aGlzLnNldFBhcmFtcyh7IHRleHRDb2xvcjogdCB9KTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyBjdXJyZW50IE1haW4gQnV0dG9uIGNvbG9yLlxuICAgKiBAcGFyYW0gYmdDb2xvciAtIGNvbG9yIHRvIHNldC5cbiAgICovXG4gIHNldEJnQ29sb3IodCkge1xuICAgIHJldHVybiB0aGlzLnNldFBhcmFtcyh7IGJnQ29sb3I6IHQgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFsbG93cyBzZXR0aW5nIG11bHRpcGxlIE1haW4gQnV0dG9uIHBhcmFtZXRlcnMuXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBNYWluIEJ1dHRvbiBwYXJhbWV0ZXJzLlxuICAgKi9cbiAgc2V0UGFyYW1zKHQpIHtcbiAgICByZXR1cm4gdGhpcy5zZXQodCksIHRoaXMuY29tbWl0KCksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBNYWluQnV0dG9uIHRleHQuXG4gICAqL1xuICBnZXQgdGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJ0ZXh0XCIpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgTWFpbkJ1dHRvbiB0ZXh0IGNvbG9yLlxuICAgKi9cbiAgZ2V0IHRleHRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJ0ZXh0Q29sb3JcIik7XG4gIH1cbn1cbmNvbnN0IGNzID0gbChcbiAgXCJtYWluQnV0dG9uXCIsXG4gICh7XG4gICAgcG9zdEV2ZW50OiBlLFxuICAgIHRoZW1lUGFyYW1zOiB0LFxuICAgIHN0YXRlOiBzID0ge1xuICAgICAgaXNWaXNpYmxlOiAhMSxcbiAgICAgIGlzRW5hYmxlZDogITEsXG4gICAgICB0ZXh0OiBcIlwiLFxuICAgICAgaXNMb2FkZXJWaXNpYmxlOiAhMSxcbiAgICAgIHRleHRDb2xvcjogdC5idXR0b25UZXh0Q29sb3IgfHwgXCIjZmZmZmZmXCIsXG4gICAgICBiZ0NvbG9yOiB0LmJ1dHRvbkNvbG9yIHx8IFwiIzAwMDAwMFwiXG4gICAgfVxuICB9KSA9PiBuZXcgYXMoeyAuLi5zLCBwb3N0RXZlbnQ6IGUgfSlcbik7XG5mdW5jdGlvbiBocygpIHtcbiAgcmV0dXJuIGx0KHtcbiAgICBjb250YWN0OiB3KHtcbiAgICAgIHVzZXJJZDoge1xuICAgICAgICB0eXBlOiB4KCksXG4gICAgICAgIGZyb206IFwidXNlcl9pZFwiXG4gICAgICB9LFxuICAgICAgcGhvbmVOdW1iZXI6IHtcbiAgICAgICAgdHlwZTogaCgpLFxuICAgICAgICBmcm9tOiBcInBob25lX251bWJlclwiXG4gICAgICB9LFxuICAgICAgZmlyc3ROYW1lOiB7XG4gICAgICAgIHR5cGU6IGgoKSxcbiAgICAgICAgZnJvbTogXCJmaXJzdF9uYW1lXCJcbiAgICAgIH0sXG4gICAgICBsYXN0TmFtZToge1xuICAgICAgICB0eXBlOiBoKCkub3B0aW9uYWwoKSxcbiAgICAgICAgZnJvbTogXCJsYXN0X25hbWVcIlxuICAgICAgfVxuICAgIH0pLFxuICAgIGF1dGhEYXRlOiB7XG4gICAgICB0eXBlOiAkdCgpLFxuICAgICAgZnJvbTogXCJhdXRoX2RhdGVcIlxuICAgIH0sXG4gICAgaGFzaDogaCgpXG4gIH0sIFwiUmVxdWVzdGVkQ29udGFjdFwiKTtcbn1cbmZ1bmN0aW9uIFp0KGUsIHQpIHtcbiAgcmV0dXJuIChzKSA9PiB7XG4gICAgY29uc3QgW24sIHJdID0gdFtzXTtcbiAgICByZXR1cm4gQyhuLCByLCBlKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHBzKGUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKCh0KSA9PiB7XG4gICAgc2V0VGltZW91dCh0LCBlKTtcbiAgfSk7XG59XG5jbGFzcyB1cyBleHRlbmRzIEwge1xuICBjb25zdHJ1Y3Rvcih7IHBvc3RFdmVudDogdCwgY3JlYXRlUmVxdWVzdElkOiBzLCB2ZXJzaW9uOiBuLCBib3RJbmxpbmU6IHIsIC4uLmkgfSkge1xuICAgIHN1cGVyKGksIG4sIHtcbiAgICAgIHJlcXVlc3RQaG9uZUFjY2VzczogXCJ3ZWJfYXBwX3JlcXVlc3RfcGhvbmVcIixcbiAgICAgIHJlcXVlc3RXcml0ZUFjY2VzczogXCJ3ZWJfYXBwX3JlcXVlc3Rfd3JpdGVfYWNjZXNzXCIsXG4gICAgICBzd2l0Y2hJbmxpbmVRdWVyeTogXCJ3ZWJfYXBwX3N3aXRjaF9pbmxpbmVfcXVlcnlcIixcbiAgICAgIHNldEhlYWRlckNvbG9yOiBcIndlYl9hcHBfc2V0X2hlYWRlcl9jb2xvclwiLFxuICAgICAgc2V0QmFja2dyb3VuZENvbG9yOiBcIndlYl9hcHBfc2V0X2JhY2tncm91bmRfY29sb3JcIlxuICAgIH0pLCBjKHRoaXMsIFwiYm90SW5saW5lXCIpLCBjKHRoaXMsIFwicG9zdEV2ZW50XCIpLCBjKHRoaXMsIFwiY3JlYXRlUmVxdWVzdElkXCIpLCBjKHRoaXMsIFwicmVxdWVzdFBob25lQWNjZXNzUHJvbWlzZVwiKSwgYyh0aGlzLCBcInJlcXVlc3RXcml0ZUFjY2Vzc1Byb21pc2VcIiksIGModGhpcywgXCJzdXBwb3J0c1BhcmFtXCIpLCB0aGlzLmNyZWF0ZVJlcXVlc3RJZCA9IHMsIHRoaXMucG9zdEV2ZW50ID0gdCwgdGhpcy5ib3RJbmxpbmUgPSByO1xuICAgIGNvbnN0IG8gPSB0aGlzLnN1cHBvcnRzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zdXBwb3J0cyA9IChhKSA9PiBvKGEpID8gYSAhPT0gXCJzd2l0Y2hJbmxpbmVRdWVyeVwiIHx8IHIgOiAhMSwgdGhpcy5zdXBwb3J0c1BhcmFtID0gWnQobiwge1xuICAgICAgXCJzZXRIZWFkZXJDb2xvci5jb2xvclwiOiBbXCJ3ZWJfYXBwX3NldF9oZWFkZXJfY29sb3JcIiwgXCJjb2xvclwiXVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBnZXQgcmVxdWVzdGVkIGNvbnRhY3QuXG4gICAqIEBwYXJhbSB0aW1lb3V0IC0gcmVxdWVzdCB0aW1lb3V0LlxuICAgKi9cbiAgYXN5bmMgZ2V0UmVxdWVzdGVkQ29udGFjdCh7XG4gICAgdGltZW91dDogdCA9IDFlNFxuICB9ID0ge30pIHtcbiAgICByZXR1cm4gaHMoKS5wYXJzZShcbiAgICAgIGF3YWl0IE8oXG4gICAgICAgIFwiZ2V0UmVxdWVzdGVkQ29udGFjdFwiLFxuICAgICAgICB7fSxcbiAgICAgICAgdGhpcy5jcmVhdGVSZXF1ZXN0SWQoKSxcbiAgICAgICAgeyBwb3N0RXZlbnQ6IHRoaXMucG9zdEV2ZW50LCB0aW1lb3V0OiB0IH1cbiAgICAgIClcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgTWluaSBBcHAgYmFja2dyb3VuZCBjb2xvci5cbiAgICogQGV4YW1wbGUgXCIjZmZhYWJiXCJcbiAgICovXG4gIGdldCBiZ0NvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImJnQ29sb3JcIik7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgTWluaSBBcHAuXG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfY2xvc2VcIik7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBNaW5pIEFwcCBoZWFkZXIgY29sb3IuXG4gICAqIEBleGFtcGxlIFwiI2ZmYWFiYlwiXG4gICAqIEBleGFtcGxlIFwiYmdfY29sb3JcIlxuICAgKi9cbiAgZ2V0IGhlYWRlckNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImhlYWRlckNvbG9yXCIpO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIHRoZSBNaW5pIEFwcCBpcyBjdXJyZW50bHkgbGF1bmNoZWQgaW4gYm90IGlubGluZSBtb2RlLlxuICAgKi9cbiAgZ2V0IGlzQm90SW5saW5lKCkge1xuICAgIHJldHVybiB0aGlzLmJvdElubGluZTtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiBjdXJyZW50IE1pbmkgQXBwIGJhY2tncm91bmQgY29sb3IgaXMgcmVjb2duaXplZCBhcyBkYXJrLlxuICAgKi9cbiAgZ2V0IGlzRGFyaygpIHtcbiAgICByZXR1cm4gVnQodGhpcy5iZ0NvbG9yKTtcbiAgfVxuICAvKipcbiAgICogSW5mb3JtcyB0aGUgVGVsZWdyYW0gYXBwIHRoYXQgdGhlIE1pbmkgQXBwIGlzIHJlYWR5IHRvIGJlIGRpc3BsYXllZC5cbiAgICpcbiAgICogSXQgaXMgcmVjb21tZW5kZWQgdG8gY2FsbCB0aGlzIG1ldGhvZCBhcyBlYXJseSBhcyBwb3NzaWJsZSwgYXMgc29vbiBhcyBhbGwgZXNzZW50aWFsXG4gICAqIGludGVyZmFjZSBlbGVtZW50cyBsb2FkZWQuIE9uY2UgdGhpcyBtZXRob2QgY2FsbGVkLCB0aGUgbG9hZGluZyBwbGFjZWhvbGRlciBpcyBoaWRkZW5cbiAgICogYW5kIHRoZSBNaW5pIEFwcCBzaG93bi5cbiAgICpcbiAgICogSWYgdGhlIG1ldGhvZCBub3QgY2FsbGVkLCB0aGUgcGxhY2Vob2xkZXIgd2lsbCBiZSBoaWRkZW4gb25seSB3aGVuIHRoZSBwYWdlIGZ1bGx5IGxvYWRlZC5cbiAgICovXG4gIHJlYWR5KCkge1xuICAgIHRoaXMucG9zdEV2ZW50KFwid2ViX2FwcF9yZWFkeVwiKTtcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdHMgY3VycmVudCB1c2VyIGNvbnRhY3QgaW5mb3JtYXRpb24uIEluIGNvbnRyYXJ5IHRvIHJlcXVlc3RQaG9uZUFjY2VzcywgdGhpcyBtZXRob2RcbiAgICogcmV0dXJucyBwcm9taXNlIHdpdGggY29udGFjdCBpbmZvcm1hdGlvbiB0aGF0IHJlamVjdHMgaW4gY2FzZSwgdXNlciBkZW5pZWQgYWNjZXNzLCBvciByZXF1ZXN0XG4gICAqIGZhaWxlZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBhZGRpdGlvbmFsIG9wdGlvbnMuXG4gICAqL1xuICBhc3luYyByZXF1ZXN0Q29udGFjdCh7IHRpbWVvdXQ6IHQgPSA1ZTMgfSA9IHt9KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFJlcXVlc3RlZENvbnRhY3QoKTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gICAgaWYgKGF3YWl0IHRoaXMucmVxdWVzdFBob25lQWNjZXNzKCkgIT09IFwic2VudFwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWNjZXNzIGRlbmllZC5cIik7XG4gICAgY29uc3QgcyA9IERhdGUubm93KCkgKyB0O1xuICAgIGxldCBuID0gNTA7XG4gICAgcmV0dXJuIE10KGFzeW5jICgpID0+IHtcbiAgICAgIGZvciAoOyBEYXRlLm5vdygpIDwgczsgKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0UmVxdWVzdGVkQ29udGFjdCgpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBwcyhuKSwgbiArPSA1MDtcbiAgICAgIH1cbiAgICAgIHRocm93IEJ0KHQpO1xuICAgIH0sIHQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXF1ZXN0cyBjdXJyZW50IHVzZXIgcGhvbmUgYWNjZXNzLiBNZXRob2QgcmV0dXJucyBwcm9taXNlLCB3aGljaCByZXNvbHZlc1xuICAgKiBzdGF0dXMgb2YgdGhlIHJlcXVlc3QuIEluIGNhc2UsIHVzZXIgYWNjZXB0ZWQgdGhlIHJlcXVlc3QsIE1pbmkgQXBwIGJvdCB3aWxsIHJlY2VpdmVcbiAgICogdGhlIGFjY29yZGluZyBub3RpZmljYXRpb24uXG4gICAqXG4gICAqIFRvIG9idGFpbiB0aGUgcmV0cmlldmVkIGluZm9ybWF0aW9uIGluc3RlYWQsIHV0aWxpemUgdGhlIGByZXF1ZXN0Q29udGFjdGAgbWV0aG9kLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIGFkZGl0aW9uYWwgb3B0aW9ucy5cbiAgICogQHNlZSByZXF1ZXN0Q29udGFjdFxuICAgKi9cbiAgYXN5bmMgcmVxdWVzdFBob25lQWNjZXNzKHQgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RQaG9uZUFjY2Vzc1Byb21pc2UgfHwgKHRoaXMucmVxdWVzdFBob25lQWNjZXNzUHJvbWlzZSA9IGcoe1xuICAgICAgLi4udCxcbiAgICAgIG1ldGhvZDogXCJ3ZWJfYXBwX3JlcXVlc3RfcGhvbmVcIixcbiAgICAgIGV2ZW50OiBcInBob25lX3JlcXVlc3RlZFwiLFxuICAgICAgcG9zdEV2ZW50OiB0aGlzLnBvc3RFdmVudFxuICAgIH0pLnRoZW4oKHsgc3RhdHVzOiBzIH0pID0+IHMpLmZpbmFsbHkoKCkgPT4gdGhpcy5yZXF1ZXN0UGhvbmVBY2Nlc3NQcm9taXNlID0gdm9pZCAwKSksIHRoaXMucmVxdWVzdFBob25lQWNjZXNzUHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdHMgd3JpdGUgbWVzc2FnZSBhY2Nlc3MgdG8gY3VycmVudCB1c2VyLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIGFkZGl0aW9uYWwgb3B0aW9ucy5cbiAgICovXG4gIGFzeW5jIHJlcXVlc3RXcml0ZUFjY2Vzcyh0ID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0V3JpdGVBY2Nlc3NQcm9taXNlIHx8ICh0aGlzLnJlcXVlc3RXcml0ZUFjY2Vzc1Byb21pc2UgPSBnKHtcbiAgICAgIC4uLnQsXG4gICAgICBtZXRob2Q6IFwid2ViX2FwcF9yZXF1ZXN0X3dyaXRlX2FjY2Vzc1wiLFxuICAgICAgZXZlbnQ6IFwid3JpdGVfYWNjZXNzX3JlcXVlc3RlZFwiLFxuICAgICAgcG9zdEV2ZW50OiB0aGlzLnBvc3RFdmVudFxuICAgIH0pLnRoZW4oKHsgc3RhdHVzOiBzIH0pID0+IHMpLmZpbmFsbHkoKCkgPT4gdGhpcy5yZXF1ZXN0V3JpdGVBY2Nlc3NQcm9taXNlID0gdm9pZCAwKSksIHRoaXMucmVxdWVzdFdyaXRlQWNjZXNzUHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogQSBtZXRob2QgdXNlZCB0byBzZW5kIGRhdGEgdG8gdGhlIGJvdC4gV2hlbiB0aGlzIG1ldGhvZCBjYWxsZWQsIGEgc2VydmljZSBtZXNzYWdlIHNlbnQgdG9cbiAgICogdGhlIGJvdCBjb250YWluaW5nIHRoZSBkYXRhIG9mIHRoZSBsZW5ndGggdXAgdG8gNDA5NiBieXRlcywgYW5kIHRoZSBNaW5pIEFwcCBjbG9zZWQuIFNlZSB0aGVcbiAgICogZmllbGQgYHdlYl9hcHBfZGF0YWAgaW4gdGhlIGNsYXNzIFtNZXNzYWdlXShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpI21lc3NhZ2UpLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBvbmx5IGF2YWlsYWJsZSBmb3IgTWluaSBBcHBzIGxhdW5jaGVkIHZpYSBhIEtleWJvYXJkIGJ1dHRvbi5cbiAgICogQHBhcmFtIGRhdGEgLSBkYXRhIHRvIHNlbmQgdG8gYm90LlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gZGF0YSBoYXMgaW5jb3JyZWN0IHNpemUuXG4gICAqL1xuICBzZW5kRGF0YSh0KSB7XG4gICAgY29uc3QgeyBzaXplOiBzIH0gPSBuZXcgQmxvYihbdF0pO1xuICAgIGlmICghcyB8fCBzID4gNDA5NilcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUGFzc2VkIGRhdGEgaGFzIGluY29ycmVjdCBzaXplOiAke3N9YCk7XG4gICAgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX2RhdGFfc2VuZFwiLCB7IGRhdGE6IHQgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgY3VycmVudCBNaW5pIEFwcCBoZWFkZXIgY29sb3IuXG4gICAqXG4gICAqIEBzZWUgTm8gZWZmZWN0IG9uIGRlc2t0b3A6IGh0dHBzOi8vZ2l0aHViLmNvbS9UZWxlZ3JhbS1NaW5pLUFwcHMvdG1hLmpzL2lzc3Vlcy85XG4gICAqIEBzZWUgV29ya3MgaW5jb3JyZWN0bHkgaW4gQW5kcm9pZDogaHR0cHM6Ly9naXRodWIuY29tL1RlbGVncmFtLU1pbmktQXBwcy90bWEuanMvaXNzdWVzLzhcbiAgICogQHBhcmFtIGNvbG9yIC0gY29sb3Iga2V5IG9yIFJHQiBjb2xvci5cbiAgICovXG4gIHNldEhlYWRlckNvbG9yKHQpIHtcbiAgICB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfc2V0X2hlYWRlcl9jb2xvclwiLCBjdCh0KSA/IHsgY29sb3I6IHQgfSA6IHsgY29sb3Jfa2V5OiB0IH0pLCB0aGlzLnNldChcImhlYWRlckNvbG9yXCIsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIGN1cnJlbnQgTWluaSBBcHAgYmFja2dyb3VuZCBjb2xvci5cbiAgICpcbiAgICogQHNlZSBObyBlZmZlY3Qgb24gZGVza3RvcDogaHR0cHM6Ly9naXRodWIuY29tL1RlbGVncmFtLU1pbmktQXBwcy90bWEuanMvaXNzdWVzLzlcbiAgICogQHNlZSBXb3JrcyBpbmNvcnJlY3RseSBpbiBBbmRyb2lkOiBodHRwczovL2dpdGh1Yi5jb20vVGVsZWdyYW0tTWluaS1BcHBzL3RtYS5qcy9pc3N1ZXMvOFxuICAgKiBAcGFyYW0gY29sb3IgLSBSR0IgY29sb3IuXG4gICAqL1xuICBzZXRCZ0NvbG9yKHQpIHtcbiAgICB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfc2V0X2JhY2tncm91bmRfY29sb3JcIiwgeyBjb2xvcjogdCB9KSwgdGhpcy5zZXQoXCJiZ0NvbG9yXCIsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnRzIHRoZSBib3QncyB1c2VybmFtZSBhbmQgdGhlIHNwZWNpZmllZCBpbmxpbmUgcXVlcnkgaW4gdGhlIGN1cnJlbnQgY2hhdCdzIGlucHV0IGZpZWxkLlxuICAgKiBRdWVyeSBtYXkgYmUgZW1wdHksIGluIHdoaWNoIGNhc2Ugb25seSB0aGUgYm90J3MgdXNlcm5hbWUgd2lsbCBiZSBpbnNlcnRlZC4gVGhlIGNsaWVudCBwcm9tcHRzXG4gICAqIHRoZSB1c2VyIHRvIGNob29zZSBhIHNwZWNpZmljIGNoYXQsIHRoZW4gb3BlbnMgdGhhdCBjaGF0IGFuZCBpbnNlcnRzIHRoZSBib3QncyB1c2VybmFtZSBhbmRcbiAgICogdGhlIHNwZWNpZmllZCBpbmxpbmUgcXVlcnkgaW4gdGhlIGlucHV0IGZpZWxkLlxuICAgKiBAcGFyYW0gdGV4dCAtIHRleHQgd2hpY2ggc2hvdWxkIGJlIGluc2VydGVkIGluIHRoZSBpbnB1dCBhZnRlciB0aGUgY3VycmVudCBib3QgbmFtZS4gTWF4XG4gICAqIGxlbmd0aCBpcyAyNTYgc3ltYm9scy5cbiAgICogQHBhcmFtIGNoYXRUeXBlcyAtIExpc3Qgb2YgY2hhdCB0eXBlcyB3aGljaCBjb3VsZCBiZSBjaG9zZW4gdG8gc2VuZCB0aGUgbWVzc2FnZS4gQ291bGQgYmVcbiAgICogZW1wdHkgbGlzdC5cbiAgICovXG4gIHN3aXRjaElubGluZVF1ZXJ5KHQsIHMgPSBbXSkge1xuICAgIGlmICghdGhpcy5zdXBwb3J0cyhcInN3aXRjaElubGluZVF1ZXJ5XCIpICYmICF0aGlzLmlzQm90SW5saW5lKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIGlzIHVuc3VwcG9ydGVkIGJlY2F1c2UgTWluaSBBcHAgc2hvdWxkIGJlIGxhdW5jaGVkIGluIGlubGluZSBtb2RlLlwiKTtcbiAgICB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfc3dpdGNoX2lubGluZV9xdWVyeVwiLCB7IHF1ZXJ5OiB0LCBjaGF0X3R5cGVzOiBzIH0pO1xuICB9XG59XG5jb25zdCBscyA9IGwoXG4gIFwibWluaUFwcFwiLFxuICAoe1xuICAgIHRoZW1lUGFyYW1zOiBlLFxuICAgIGJvdElubGluZTogdCA9ICExLFxuICAgIHN0YXRlOiBzID0ge1xuICAgICAgYmdDb2xvcjogZS5iZ0NvbG9yIHx8IFwiI2ZmZmZmZlwiLFxuICAgICAgaGVhZGVyQ29sb3I6IGUuaGVhZGVyQmdDb2xvciB8fCBcIiMwMDAwMDBcIlxuICAgIH0sXG4gICAgLi4ublxuICB9KSA9PiBuZXcgdXMoeyAuLi5uLCAuLi5zLCBib3RJbmxpbmU6IHQgfSlcbik7XG5mdW5jdGlvbiBkcyhlKSB7XG4gIGNvbnN0IHQgPSBlLm1lc3NhZ2UudHJpbSgpLCBzID0gKGUudGl0bGUgfHwgXCJcIikudHJpbSgpLCBuID0gZS5idXR0b25zIHx8IFtdO1xuICBsZXQgcjtcbiAgaWYgKHMubGVuZ3RoID4gNjQpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaXRsZSBoYXMgaW5jb3JyZWN0IHNpemU6ICR7cy5sZW5ndGh9YCk7XG4gIGlmICghdC5sZW5ndGggfHwgdC5sZW5ndGggPiAyNTYpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBNZXNzYWdlIGhhcyBpbmNvcnJlY3Qgc2l6ZTogJHt0Lmxlbmd0aH1gKTtcbiAgaWYgKG4ubGVuZ3RoID4gMylcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEJ1dHRvbnMgaGF2ZSBpbmNvcnJlY3Qgc2l6ZTogJHtuLmxlbmd0aH1gKTtcbiAgcmV0dXJuIG4ubGVuZ3RoID8gciA9IG4ubWFwKChpKSA9PiB7XG4gICAgY29uc3QgeyBpZDogbyA9IFwiXCIgfSA9IGk7XG4gICAgaWYgKG8ubGVuZ3RoID4gNjQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEJ1dHRvbiBJRCBoYXMgaW5jb3JyZWN0IHNpemU6ICR7b31gKTtcbiAgICBpZiAoIWkudHlwZSB8fCBpLnR5cGUgPT09IFwiZGVmYXVsdFwiIHx8IGkudHlwZSA9PT0gXCJkZXN0cnVjdGl2ZVwiKSB7XG4gICAgICBjb25zdCBhID0gaS50ZXh0LnRyaW0oKTtcbiAgICAgIGlmICghYS5sZW5ndGggfHwgYS5sZW5ndGggPiA2NCkge1xuICAgICAgICBjb25zdCBwID0gaS50eXBlIHx8IFwiZGVmYXVsdFwiO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJ1dHRvbiB0ZXh0IHdpdGggdHlwZSBcIiR7cH1cIiBoYXMgaW5jb3JyZWN0IHNpemU6ICR7aS50ZXh0Lmxlbmd0aH1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IC4uLmksIHRleHQ6IGEsIGlkOiBvIH07XG4gICAgfVxuICAgIHJldHVybiB7IC4uLmksIGlkOiBvIH07XG4gIH0pIDogciA9IFt7IHR5cGU6IFwiY2xvc2VcIiwgaWQ6IFwiXCIgfV0sIHsgdGl0bGU6IHMsIG1lc3NhZ2U6IHQsIGJ1dHRvbnM6IHIgfTtcbn1cbmNsYXNzIF9zIGV4dGVuZHMgTCB7XG4gIGNvbnN0cnVjdG9yKHQsIHMsIG4pIHtcbiAgICBzdXBlcih7IGlzT3BlbmVkOiB0IH0sIHMsIHsgb3BlbjogXCJ3ZWJfYXBwX29wZW5fcG9wdXBcIiB9KSwgdGhpcy5wb3N0RXZlbnQgPSBuO1xuICB9XG4gIHNldCBpc09wZW5lZCh0KSB7XG4gICAgdGhpcy5zZXQoXCJpc09wZW5lZFwiLCB0KTtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiB0aGUgUG9wdXAgaXMgb3BlbmVkLlxuICAgKi9cbiAgZ2V0IGlzT3BlbmVkKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImlzT3BlbmVkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBBIG1ldGhvZCB0aGF0IHNob3dzIGEgbmF0aXZlIHBvcHVwIGRlc2NyaWJlZCBieSB0aGUgYHBhcmFtc2AgYXJndW1lbnQuXG4gICAqIFByb21pc2Ugd2lsbCBiZSByZXNvbHZlZCB3aGVuIHBvcHVwIGlzIGNsb3NlZC4gUmVzb2x2ZWQgdmFsdWUgd2lsbCBoYXZlXG4gICAqIGFuIGlkZW50aWZpZXIgb2YgcHJlc3NlZCBidXR0b24uXG4gICAqXG4gICAqIEluIGNhc2UsIHVzZXIgY2xpY2tlZCBvdXRzaWRlIHRoZSBwb3B1cCBvciBjbGlja2VkIHRvcCByaWdodCBwb3B1cCBjbG9zZVxuICAgKiBidXR0b24sIG51bGwgd2lsbCBiZSByZXR1cm5lZC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBwb3B1cCBwYXJhbWV0ZXJzLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gUG9wdXAgaXMgYWxyZWFkeSBvcGVuZWQuXG4gICAqL1xuICBhc3luYyBvcGVuKHQpIHtcbiAgICBpZiAodGhpcy5pc09wZW5lZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvcHVwIGlzIGFscmVhZHkgb3BlbmVkLlwiKTtcbiAgICB0aGlzLmlzT3BlbmVkID0gITA7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgYnV0dG9uX2lkOiBzID0gbnVsbCB9ID0gYXdhaXQgZyh7XG4gICAgICAgIGV2ZW50OiBcInBvcHVwX2Nsb3NlZFwiLFxuICAgICAgICBtZXRob2Q6IFwid2ViX2FwcF9vcGVuX3BvcHVwXCIsXG4gICAgICAgIHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnQsXG4gICAgICAgIHBhcmFtczogZHModClcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHM7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuaXNPcGVuZWQgPSAhMTtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IHdzID0gbChcbiAgKHsgcG9zdEV2ZW50OiBlLCB2ZXJzaW9uOiB0IH0pID0+IG5ldyBfcyghMSwgdCwgZSlcbik7XG5jbGFzcyBncyBleHRlbmRzIEwge1xuICBjb25zdHJ1Y3Rvcih0LCBzLCBuKSB7XG4gICAgc3VwZXIoeyBpc09wZW5lZDogdCB9LCBzLCB7XG4gICAgICBjbG9zZTogXCJ3ZWJfYXBwX2Nsb3NlX3NjYW5fcXJfcG9wdXBcIixcbiAgICAgIG9wZW46IFwid2ViX2FwcF9vcGVuX3NjYW5fcXJfcG9wdXBcIlxuICAgIH0pLCB0aGlzLnBvc3RFdmVudCA9IG47XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlcyBzY2FubmVyLlxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX2Nsb3NlX3NjYW5fcXJfcG9wdXBcIiksIHRoaXMuaXNPcGVuZWQgPSAhMTtcbiAgfVxuICBzZXQgaXNPcGVuZWQodCkge1xuICAgIHRoaXMuc2V0KFwiaXNPcGVuZWRcIiwgdCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpbiBjYXNlLCBRUiBzY2FubmVyIGlzIGN1cnJlbnRseSBvcGVuZWQuXG4gICAqL1xuICBnZXQgaXNPcGVuZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiaXNPcGVuZWRcIik7XG4gIH1cbiAgYXN5bmMgb3Blbih0KSB7XG4gICAgaWYgKHRoaXMuaXNPcGVuZWQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJRUiBzY2FubmVyIGlzIGFscmVhZHkgb3BlbmVkLlwiKTtcbiAgICBjb25zdCB7IHRleHQ6IHMsIGNhcHR1cmU6IG4gfSA9ICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiID8geyB0ZXh0OiB0IH0gOiB0KSB8fCB7fTtcbiAgICB0aGlzLmlzT3BlbmVkID0gITA7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHIgPSAoYXdhaXQgZyh7XG4gICAgICAgIG1ldGhvZDogXCJ3ZWJfYXBwX29wZW5fc2Nhbl9xcl9wb3B1cFwiLFxuICAgICAgICBldmVudDogW1wicXJfdGV4dF9yZWNlaXZlZFwiLCBcInNjYW5fcXJfcG9wdXBfY2xvc2VkXCJdLFxuICAgICAgICBwb3N0RXZlbnQ6IHRoaXMucG9zdEV2ZW50LFxuICAgICAgICBwYXJhbXM6IHsgdGV4dDogcyB9LFxuICAgICAgICBjYXB0dXJlKGkpIHtcbiAgICAgICAgICByZXR1cm4gaS5ldmVudCA9PT0gXCJzY2FuX3FyX3BvcHVwX2Nsb3NlZFwiIHx8ICFuIHx8IG4oaS5wYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgfSkgfHwge30pLmRhdGEgfHwgbnVsbDtcbiAgICAgIHJldHVybiByICYmIHRoaXMuY2xvc2UoKSwgcjtcbiAgICB9IGNhdGNoIChyKSB7XG4gICAgICB0aHJvdyB0aGlzLmlzT3BlbmVkID0gITEsIHI7XG4gICAgfVxuICB9XG59XG5jb25zdCBmcyA9IGwoXG4gICh7IHZlcnNpb246IGUsIHBvc3RFdmVudDogdCB9KSA9PiBuZXcgZ3MoITEsIGUsIHQpXG4pO1xuY2xhc3MgbXMgZXh0ZW5kcyB1dCB7XG4gIGNvbnN0cnVjdG9yKHQsIHMsIG4pIHtcbiAgICBzdXBlcih7IGlzVmlzaWJsZTogdCB9LCBzLCB7XG4gICAgICBzaG93OiBcIndlYl9hcHBfc2V0dXBfc2V0dGluZ3NfYnV0dG9uXCIsXG4gICAgICBoaWRlOiBcIndlYl9hcHBfc2V0dXBfc2V0dGluZ3NfYnV0dG9uXCJcbiAgICB9KSwgYyh0aGlzLCBcIm9uXCIsIChyLCBpKSA9PiByID09PSBcImNsaWNrXCIgPyB5KFwic2V0dGluZ3NfYnV0dG9uX3ByZXNzZWRcIiwgaSkgOiB0aGlzLnN0YXRlLm9uKHIsIGkpKSwgYyh0aGlzLCBcIm9mZlwiLCAociwgaSkgPT4gciA9PT0gXCJjbGlja1wiID8geihcInNldHRpbmdzX2J1dHRvbl9wcmVzc2VkXCIsIGkpIDogdGhpcy5zdGF0ZS5vZmYociwgaSkpLCB0aGlzLnBvc3RFdmVudCA9IG47XG4gIH1cbiAgc2V0IGlzVmlzaWJsZSh0KSB7XG4gICAgdGhpcy5zZXQoXCJpc1Zpc2libGVcIiwgdCksIHRoaXMucG9zdEV2ZW50KFwid2ViX2FwcF9zZXR1cF9zZXR0aW5nc19idXR0b25cIiwgeyBpc192aXNpYmxlOiB0IH0pO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIHRoZSBTZXR0aW5nc0J1dHRvbiBpcyB2aXNpYmxlLlxuICAgKi9cbiAgZ2V0IGlzVmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJpc1Zpc2libGVcIik7XG4gIH1cbiAgLyoqXG4gICAqIEhpZGVzIHRoZSBTZXR0aW5nc0J1dHRvbi5cbiAgICovXG4gIGhpZGUoKSB7XG4gICAgdGhpcy5pc1Zpc2libGUgPSAhMTtcbiAgfVxuICAvKipcbiAgICogU2hvd3MgdGhlIFNldHRpbmdzQnV0dG9uLlxuICAgKi9cbiAgc2hvdygpIHtcbiAgICB0aGlzLmlzVmlzaWJsZSA9ICEwO1xuICB9XG59XG5jb25zdCBicyA9IGwoXG4gIFwic2V0dGluZ3NCdXR0b25cIixcbiAgKHtcbiAgICB2ZXJzaW9uOiBlLFxuICAgIHBvc3RFdmVudDogdCxcbiAgICBzdGF0ZTogcyA9IHsgaXNWaXNpYmxlOiAhMSB9XG4gIH0pID0+IG5ldyBtcyhzLmlzVmlzaWJsZSwgZSwgdClcbik7XG5mdW5jdGlvbiBYdChlKSB7XG4gIHJldHVybiBIdCgpLnBhcnNlKGUpO1xufVxuY2xhc3MgdnMgZXh0ZW5kcyBfdCB7XG4gIC8qKlxuICAgKiBAc2luY2UgdjYuMTBcbiAgICovXG4gIGdldCBhY2NlbnRUZXh0Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiYWNjZW50VGV4dENvbG9yXCIpO1xuICB9XG4gIGdldCBiZ0NvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImJnQ29sb3JcIik7XG4gIH1cbiAgZ2V0IGJ1dHRvbkNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImJ1dHRvbkNvbG9yXCIpO1xuICB9XG4gIGdldCBidXR0b25UZXh0Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiYnV0dG9uVGV4dENvbG9yXCIpO1xuICB9XG4gIGdldCBkZXN0cnVjdGl2ZVRleHRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJkZXN0cnVjdGl2ZVRleHRDb2xvclwiKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29weSBvZiB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgdGhlIGN1cnJlbnQgY29tcG9uZW50IGluc3RhbmNlLlxuICAgKi9cbiAgZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgfVxuICAvKipcbiAgICogQHNpbmNlIHY2LjEwXG4gICAqL1xuICBnZXQgaGVhZGVyQmdDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJoZWFkZXJCZ0NvbG9yXCIpO1xuICB9XG4gIGdldCBoaW50Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwiaGludENvbG9yXCIpO1xuICB9XG4gIC8qKlxuICAgKiBAcmV0dXJucyBUcnVlIGluIGNhc2UsIGN1cnJlbnQgY29sb3Igc2NoZW1lIGlzIHJlY29nbml6ZWQgYXMgZGFyay4gVGhpc1xuICAgKiB2YWx1ZSBpcyBjYWxjdWxhdGVkIGFjY29yZGluZyB0byB0aGVtZSBiZyBjb2xvci5cbiAgICovXG4gIGdldCBpc0RhcmsoKSB7XG4gICAgcmV0dXJuICF0aGlzLmJnQ29sb3IgfHwgVnQodGhpcy5iZ0NvbG9yKTtcbiAgfVxuICBnZXQgbGlua0NvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldChcImxpbmtDb2xvclwiKTtcbiAgfVxuICBnZXQgc2Vjb25kYXJ5QmdDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJzZWNvbmRhcnlCZ0NvbG9yXCIpO1xuICB9XG4gIC8qKlxuICAgKiBAc2luY2UgdjYuMTBcbiAgICovXG4gIGdldCBzZWN0aW9uQmdDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJzZWN0aW9uQmdDb2xvclwiKTtcbiAgfVxuICAvKipcbiAgICogQHNpbmNlIHY2LjEwXG4gICAqL1xuICBnZXQgc2VjdGlvbkhlYWRlclRleHRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJzZWN0aW9uSGVhZGVyVGV4dENvbG9yXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydHMgbGlzdGVuaW5nIHRvIHRoZSBleHRlcm5hbCB0aGVtZSBjaGFuZ2VzIGFuZCBhcHBsaWVzIHRoZW0uXG4gICAqIEByZXR1cm5zIEZ1bmN0aW9uIHRvIHN0b3AgbGlzdGVuaW5nLlxuICAgKi9cbiAgbGlzdGVuKCkge1xuICAgIHJldHVybiB5KFwidGhlbWVfY2hhbmdlZFwiLCAodCkgPT4ge1xuICAgICAgdGhpcy5zZXQoWHQodC50aGVtZV9wYXJhbXMpKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQHNpbmNlIHY2LjEwXG4gICAqL1xuICBnZXQgc3VidGl0bGVUZXh0Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwic3VidGl0bGVUZXh0Q29sb3JcIik7XG4gIH1cbiAgZ2V0IHRleHRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJ0ZXh0Q29sb3JcIik7XG4gIH1cbn1cbmNvbnN0IHlzID0gbChcbiAgXCJ0aGVtZVBhcmFtc1wiLFxuICAoeyB0aGVtZVBhcmFtczogZSwgc3RhdGU6IHQgPSBlLCBhZGRDbGVhbnVwOiBzIH0pID0+IHtcbiAgICBjb25zdCBuID0gbmV3IHZzKHQpO1xuICAgIHJldHVybiBzKG4ubGlzdGVuKCkpLCBuO1xuICB9XG4pO1xuZnVuY3Rpb24gbW4oZSA9IHt9KSB7XG4gIHJldHVybiBnKHtcbiAgICAuLi5lLFxuICAgIG1ldGhvZDogXCJ3ZWJfYXBwX3JlcXVlc3RfdGhlbWVcIixcbiAgICBldmVudDogXCJ0aGVtZV9jaGFuZ2VkXCJcbiAgfSkudGhlbihYdCk7XG59XG5jbGFzcyBFcyBleHRlbmRzIHd0IHtcbiAgY29uc3RydWN0b3IodCwgcywgbikge1xuICAgIHN1cGVyKHQsIHsgcmVhZFRleHRGcm9tQ2xpcGJvYXJkOiBcIndlYl9hcHBfcmVhZF90ZXh0X2Zyb21fY2xpcGJvYXJkXCIgfSksIGModGhpcywgXCJzdXBwb3J0c1BhcmFtXCIpLCB0aGlzLnZlcnNpb24gPSB0LCB0aGlzLmNyZWF0ZVJlcXVlc3RJZCA9IHMsIHRoaXMucG9zdEV2ZW50ID0gbiwgdGhpcy5zdXBwb3J0c1BhcmFtID0gWnQodCwge1xuICAgICAgXCJvcGVuTGluay50cnlJbnN0YW50Vmlld1wiOiBbXCJ3ZWJfYXBwX29wZW5fbGlua1wiLCBcInRyeV9pbnN0YW50X3ZpZXdcIl1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogT3BlbnMgYSBsaW5rIGluIGFuIGV4dGVybmFsIGJyb3dzZXIuIFRoZSBNaW5pIEFwcCB3aWxsIG5vdCBiZSBjbG9zZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIG9ubHkgaW4gcmVzcG9uc2UgdG8gdGhlIHVzZXJcbiAgICogaW50ZXJhY3Rpb24gd2l0aCB0aGUgTWluaSBBcHAgaW50ZXJmYWNlIChlLmcuIGNsaWNrIGluc2lkZSB0aGUgTWluaSBBcHBcbiAgICogb3Igb24gdGhlIG1haW4gYnV0dG9uKS5cbiAgICogQHBhcmFtIHVybCAtIFVSTCB0byBiZSBvcGVuZWQuXG4gICAqIEBwYXJhbSB0cnlJbnN0YW50Vmlld1xuICAgKi9cbiAgb3BlbkxpbmsodCwgcykge1xuICAgIGNvbnN0IG4gPSBuZXcgVVJMKHQsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKS50b1N0cmluZygpO1xuICAgIGlmICghQyhcIndlYl9hcHBfb3Blbl9saW5rXCIsIHRoaXMudmVyc2lvbikpIHtcbiAgICAgIHdpbmRvdy5vcGVuKG4sIFwiX2JsYW5rXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfb3Blbl9saW5rXCIsIHtcbiAgICAgIHVybDogbixcbiAgICAgIC4uLnR5cGVvZiBzID09IFwiYm9vbGVhblwiID8geyB0cnlfaW5zdGFudF92aWV3OiBzIH0gOiB7fVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBPcGVucyBhIFRlbGVncmFtIGxpbmsgaW5zaWRlIFRlbGVncmFtIGFwcC4gVGhlIE1pbmkgQXBwIHdpbGwgYmUgY2xvc2VkLiBJdCBleHBlY3RzIHBhc3NpbmdcbiAgICogbGluayBpbiBmdWxsIGZvcm1hdCwgd2l0aCBob3N0bmFtZSBcInQubWVcIi5cbiAgICogQHBhcmFtIHVybCAtIFVSTCB0byBiZSBvcGVuZWQuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBVUkwgaGFzIG5vdCBhbGxvd2VkIGhvc3RuYW1lLlxuICAgKi9cbiAgb3BlblRlbGVncmFtTGluayh0KSB7XG4gICAgY29uc3QgeyBob3N0bmFtZTogcywgcGF0aG5hbWU6IG4sIHNlYXJjaDogciB9ID0gbmV3IFVSTCh0LCBcImh0dHBzOi8vdC5tZVwiKTtcbiAgICBpZiAocyAhPT0gXCJ0Lm1lXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVSTCBoYXMgbm90IGFsbG93ZWQgaG9zdG5hbWU6ICR7c30uIE9ubHkgXCJ0Lm1lXCIgaXMgYWxsb3dlZGApO1xuICAgIGlmICghQyhcIndlYl9hcHBfb3Blbl90Z19saW5rXCIsIHRoaXMudmVyc2lvbikpIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX29wZW5fdGdfbGlua1wiLCB7IHBhdGhfZnVsbDogbiArIHIgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWRzIHRleHQgZnJvbSBjbGlwYm9hcmQgYW5kIHJldHVybnMgc3RyaW5nIG9yIG51bGwuIG51bGwgaXMgcmV0dXJuZWRcbiAgICogaW4gY2FzZXM6XG4gICAqIC0gVmFsdWUgaW4gY2xpcGJvYXJkIGlzIG5vdCB0ZXh0XG4gICAqIC0gQWNjZXNzIHRvIGNsaXBib2FyZCBpcyBub3QgYWxsb3dlZFxuICAgKi9cbiAgYXN5bmMgcmVhZFRleHRGcm9tQ2xpcGJvYXJkKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmNyZWF0ZVJlcXVlc3RJZCgpLCB7XG4gICAgICBkYXRhOiBzID0gbnVsbFxuICAgIH0gPSBhd2FpdCBnKHtcbiAgICAgIG1ldGhvZDogXCJ3ZWJfYXBwX3JlYWRfdGV4dF9mcm9tX2NsaXBib2FyZFwiLFxuICAgICAgZXZlbnQ6IFwiY2xpcGJvYXJkX3RleHRfcmVjZWl2ZWRcIixcbiAgICAgIHBvc3RFdmVudDogdGhpcy5wb3N0RXZlbnQsXG4gICAgICBwYXJhbXM6IHsgcmVxX2lkOiB0IH0sXG4gICAgICBjYXB0dXJlOiBEdCh0KVxuICAgIH0pO1xuICAgIHJldHVybiBzO1xuICB9XG4gIC8qKlxuICAgKiBTaGFyZXMgc3BlY2lmaWVkIFVSTCB3aXRoIHRoZSBwYXNzZWQgdG8gdGhlIGNoYXRzLCBzZWxlY3RlZCBieSB1c2VyLiBBZnRlciBiZWluZyBjYWxsZWQsXG4gICAqIGl0IGNsb3NlcyB0aGUgbWluaSBhcHBsaWNhdGlvbi5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgdXNlcyBUZWxlZ3JhbSdzIFNoYXJlIExpbmtzLlxuICAgKiBAcGFyYW0gdXJsIC0gVVJMIHRvIHNoYXJlLlxuICAgKiBAcGFyYW0gdGV4dCAtIHRleHQgdG8gYXBwZW5kIGFmdGVyIHRoZSBVUkwuXG4gICAqIEBzZWUgaHR0cHM6Ly9jb3JlLnRlbGVncmFtLm9yZy9hcGkvbGlua3Mjc2hhcmUtbGlua3NcbiAgICogQHNlZSBodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL3dpZGdldHMvc2hhcmUjY3VzdG9tLWJ1dHRvbnNcbiAgICovXG4gIHNoYXJlVVJMKHQsIHMpIHtcbiAgICB0aGlzLm9wZW5UZWxlZ3JhbUxpbmsoXG4gICAgICBcImh0dHBzOi8vdC5tZS9zaGFyZS91cmw/XCIgKyBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgdXJsOiB0LCB0ZXh0OiBzIHx8IFwiXCIgfSkudG9TdHJpbmcoKVxuICAgICk7XG4gIH1cbn1cbmNvbnN0IFBzID0gbChcbiAgKHsgdmVyc2lvbjogZSwgcG9zdEV2ZW50OiB0LCBjcmVhdGVSZXF1ZXN0SWQ6IHMgfSkgPT4gbmV3IEVzKGUsIHMsIHQpXG4pO1xuYXN5bmMgZnVuY3Rpb24gdGUoZSA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBpc19leHBhbmRlZDogdCxcbiAgICBpc19zdGF0ZV9zdGFibGU6IHMsXG4gICAgLi4ublxuICB9ID0gYXdhaXQgZyh7XG4gICAgLi4uZSxcbiAgICBtZXRob2Q6IFwid2ViX2FwcF9yZXF1ZXN0X3ZpZXdwb3J0XCIsXG4gICAgZXZlbnQ6IFwidmlld3BvcnRfY2hhbmdlZFwiXG4gIH0pO1xuICByZXR1cm4geyAuLi5uLCBpc0V4cGFuZGVkOiB0LCBpc1N0YXRlU3RhYmxlOiBzIH07XG59XG5mdW5jdGlvbiBxKGUpIHtcbiAgcmV0dXJuIGUgPCAwID8gMCA6IGU7XG59XG5jbGFzcyBScyBleHRlbmRzIF90IHtcbiAgY29uc3RydWN0b3IoeyBwb3N0RXZlbnQ6IHQsIHN0YWJsZUhlaWdodDogcywgaGVpZ2h0OiBuLCB3aWR0aDogciwgaXNFeHBhbmRlZDogaSB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgaGVpZ2h0OiBxKG4pLFxuICAgICAgaXNFeHBhbmRlZDogaSxcbiAgICAgIHN0YWJsZUhlaWdodDogcShzKSxcbiAgICAgIHdpZHRoOiBxKHIpXG4gICAgfSksIGModGhpcywgXCJwb3N0RXZlbnRcIiksIHRoaXMucG9zdEV2ZW50ID0gdDtcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdHMgdmlld3BvcnQgaW5mb3JtYXRpb24gZnJvbSB0aGUgVGVsZWdyYW0gYXBwbGljYXRpb24gYW5kIHVwZGF0ZXMgY3VycmVudCBWaWV3cG9ydFxuICAgKiBpbnN0YW5jZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBvcHRpb25zIHRvIHJlcXVlc3QgZnJlc2ggZGF0YS5cbiAgICovXG4gIGFzeW5jIHN5bmModCkge1xuICAgIGNvbnN0IHsgaXNTdGF0ZVN0YWJsZTogcywgLi4ubiB9ID0gYXdhaXQgdGUodCk7XG4gICAgdGhpcy5zZXQoe1xuICAgICAgLi4ubixcbiAgICAgIHN0YWJsZUhlaWdodDogcyA/IG4uaGVpZ2h0IDogdGhpcy5nZXQoXCJzdGFibGVIZWlnaHRcIilcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgaGVpZ2h0IG9mIHRoZSAqKnZpc2libGUgYXJlYSoqIG9mIHRoZSBNaW5pIEFwcC5cbiAgICpcbiAgICogVGhlIGFwcGxpY2F0aW9uIGNhbiBkaXNwbGF5IGp1c3QgdGhlIHRvcCBwYXJ0IG9mIHRoZSBNaW5pIEFwcCwgd2l0aCBpdHMgbG93ZXIgcGFydCByZW1haW5pbmdcbiAgICogb3V0c2lkZSB0aGUgc2NyZWVuIGFyZWEuIEZyb20gdGhpcyBwb3NpdGlvbiwgdGhlIHVzZXIgY2FuIFwicHVsbFwiIHRoZSBNaW5pIEFwcCB0byBpdHNcbiAgICogbWF4aW11bSBoZWlnaHQsIHdoaWxlIHRoZSBib3QgY2FuIGRvIHRoZSBzYW1lIGJ5IGNhbGxpbmcgYGV4cGFuZGAgbWV0aG9kLiBBcyB0aGUgcG9zaXRpb24gb2ZcbiAgICogdGhlIE1pbmkgQXBwIGNoYW5nZXMsIHRoZSBjdXJyZW50IGhlaWdodCB2YWx1ZSBvZiB0aGUgdmlzaWJsZSBhcmVhIHdpbGwgYmUgdXBkYXRlZCAgaW4gcmVhbFxuICAgKiB0aW1lLlxuICAgKlxuICAgKiBQbGVhc2Ugbm90ZSB0aGF0IHRoZSByZWZyZXNoIHJhdGUgb2YgdGhpcyB2YWx1ZSBpcyBub3Qgc3VmZmljaWVudCB0byBzbW9vdGhseSBmb2xsb3cgdGhlXG4gICAqIGxvd2VyIGJvcmRlciBvZiB0aGUgd2luZG93LiBJdCBzaG91bGQgbm90IGJlIHVzZWQgdG8gcGluIGludGVyZmFjZSBlbGVtZW50cyB0byB0aGUgYm90dG9tXG4gICAqIG9mIHRoZSB2aXNpYmxlIGFyZWEuIEl0J3MgbW9yZSBhcHByb3ByaWF0ZSB0byB1c2UgdGhlIHZhbHVlIG9mIHRoZSBgc3RhYmxlSGVpZ2h0YFxuICAgKiBmaWVsZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgKlxuICAgKiBAc2VlIHN0YWJsZUhlaWdodFxuICAgKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJoZWlnaHRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBoZWlnaHQgb2YgdGhlIHZpc2libGUgYXJlYSBvZiB0aGUgTWluaSBBcHAgaW4gaXRzIGxhc3Qgc3RhYmxlIHN0YXRlLlxuICAgKlxuICAgKiBUaGUgYXBwbGljYXRpb24gY2FuIGRpc3BsYXkganVzdCB0aGUgdG9wIHBhcnQgb2YgdGhlIE1pbmkgQXBwLCB3aXRoIGl0cyBsb3dlciBwYXJ0IHJlbWFpbmluZ1xuICAgKiBvdXRzaWRlIHRoZSBzY3JlZW4gYXJlYS4gRnJvbSB0aGlzIHBvc2l0aW9uLCB0aGUgdXNlciBjYW4gXCJwdWxsXCIgdGhlIE1pbmkgQXBwIHRvIGl0c1xuICAgKiBtYXhpbXVtIGhlaWdodCwgd2hpbGUgdGhlIGFwcGxpY2F0aW9uIGNhbiBkbyB0aGUgc2FtZSBieSBjYWxsaW5nIGBleHBhbmRgIG1ldGhvZC5cbiAgICpcbiAgICogVW5saWtlIHRoZSB2YWx1ZSBvZiBgaGVpZ2h0YCwgdGhlIHZhbHVlIG9mIGBzdGFibGVIZWlnaHRgIGRvZXMgbm90IGNoYW5nZSBhcyB0aGUgcG9zaXRpb25cbiAgICogb2YgdGhlIE1pbmkgQXBwIGNoYW5nZXMgd2l0aCB1c2VyIGdlc3R1cmVzIG9yIGR1cmluZyBhbmltYXRpb25zLiBUaGUgdmFsdWUgb2YgYHN0YWJsZUhlaWdodGBcbiAgICogd2lsbCBiZSB1cGRhdGVkIGFmdGVyIGFsbCBnZXN0dXJlcyBhbmQgYW5pbWF0aW9ucyBhcmUgY29tcGxldGVkIGFuZFxuICAgKiB0aGUgTWluaSBBcHAgcmVhY2hlcyBpdHMgZmluYWwgc2l6ZS5cbiAgICpcbiAgICogQHNlZSBoZWlnaHRcbiAgICovXG4gIGdldCBzdGFibGVIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwic3RhYmxlSGVpZ2h0XCIpO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydHMgbGlzdGVuaW5nIHRvIHZpZXdwb3J0IGNoYW5nZXMgYW5kIGFwcGxpZXMgdGhlbS5cbiAgICogQHJldHVybnMgRnVuY3Rpb24gdG8gc3RvcCBsaXN0ZW5pbmcuXG4gICAqL1xuICBsaXN0ZW4oKSB7XG4gICAgcmV0dXJuIHkoXCJ2aWV3cG9ydF9jaGFuZ2VkXCIsICh0KSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGhlaWdodDogcyxcbiAgICAgICAgd2lkdGg6IG4sXG4gICAgICAgIGlzX2V4cGFuZGVkOiByLFxuICAgICAgICBpc19zdGF0ZV9zdGFibGU6IGlcbiAgICAgIH0gPSB0LCBvID0gcShzKTtcbiAgICAgIHRoaXMuc2V0KHtcbiAgICAgICAgaGVpZ2h0OiBvLFxuICAgICAgICBpc0V4cGFuZGVkOiByLFxuICAgICAgICB3aWR0aDogcShuKSxcbiAgICAgICAgLi4uaSA/IHsgc3RhYmxlSGVpZ2h0OiBvIH0gOiB7fVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgdGhlIE1pbmkgQXBwIGlzIGV4cGFuZGVkIHRvIHRoZSBtYXhpbXVtIGF2YWlsYWJsZSBoZWlnaHQuIE90aGVyd2lzZSwgaWZcbiAgICogdGhlIE1pbmkgQXBwIG9jY3VwaWVzIHBhcnQgb2YgdGhlIHNjcmVlbiBhbmQgY2FuIGJlIGV4cGFuZGVkIHRvIHRoZSBmdWxsIGhlaWdodCB1c2luZ1xuICAgKiBgZXhwYW5kYCBtZXRob2QuXG4gICAqIEBzZWUgZXhwYW5kXG4gICAqL1xuICBnZXQgaXNFeHBhbmRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJpc0V4cGFuZGVkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBDdXJyZW50IHZpc2libGUgYXJlYSB3aWR0aC5cbiAgICovXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoXCJ3aWR0aFwiKTtcbiAgfVxuICAvKipcbiAgICogQSBtZXRob2QgdGhhdCBleHBhbmRzIHRoZSBNaW5pIEFwcCB0byB0aGUgbWF4aW11bSBhdmFpbGFibGUgaGVpZ2h0LiBUbyBmaW5kIG91dCBpZiB0aGUgTWluaVxuICAgKiBBcHAgaXMgZXhwYW5kZWQgdG8gdGhlIG1heGltdW0gaGVpZ2h0LCByZWZlciB0byB0aGUgdmFsdWUgb2YgdGhlIGBpc0V4cGFuZGVkYC5cbiAgICogQHNlZSBpc0V4cGFuZGVkXG4gICAqL1xuICBleHBhbmQoKSB7XG4gICAgdGhpcy5wb3N0RXZlbnQoXCJ3ZWJfYXBwX2V4cGFuZFwiKSwgdGhpcy5zZXQoXCJpc0V4cGFuZGVkXCIsICEwKTtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiB0aGUgY3VycmVudCB2aWV3cG9ydCBoZWlnaHQgaXMgc3RhYmxlIGFuZCBpcyBub3QgZ29pbmcgdG8gY2hhbmdlIGluIHRoZSBuZXh0IG1vbWVudC5cbiAgICovXG4gIGdldCBpc1N0YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFibGVIZWlnaHQgPT09IHRoaXMuaGVpZ2h0O1xuICB9XG59XG5jb25zdCB4cyA9IGwoXG4gIFwidmlld3BvcnRcIixcbiAgYXN5bmMgKHsgc3RhdGU6IGUsIHBsYXRmb3JtOiB0LCBwb3N0RXZlbnQ6IHMsIGFkZENsZWFudXA6IG4gfSkgPT4ge1xuICAgIGxldCByID0gITEsIGkgPSAwLCBvID0gMCwgYSA9IDA7XG4gICAgaWYgKGUpXG4gICAgICByID0gZS5pc0V4cGFuZGVkLCBpID0gZS5oZWlnaHQsIG8gPSBlLndpZHRoLCBhID0gZS5zdGFibGVIZWlnaHQ7XG4gICAgZWxzZSBpZiAoW1wibWFjb3NcIiwgXCJ0ZGVza3RvcFwiLCBcInVuaWdyYW1cIiwgXCJ3ZWJrXCIsIFwid2ViYVwiLCBcIndlYlwiXS5pbmNsdWRlcyh0KSlcbiAgICAgIHIgPSAhMCwgaSA9IHdpbmRvdy5pbm5lckhlaWdodCwgbyA9IHdpbmRvdy5pbm5lcldpZHRoLCBhID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgdSA9IGF3YWl0IHRlKHsgdGltZW91dDogMWUzLCBwb3N0RXZlbnQ6IHMgfSk7XG4gICAgICByID0gdS5pc0V4cGFuZGVkLCBpID0gdS5oZWlnaHQsIG8gPSB1LndpZHRoLCBhID0gdS5pc1N0YXRlU3RhYmxlID8gaSA6IDA7XG4gICAgfVxuICAgIGNvbnN0IHAgPSBuZXcgUnMoe1xuICAgICAgcG9zdEV2ZW50OiBzLFxuICAgICAgaGVpZ2h0OiBpLFxuICAgICAgd2lkdGg6IG8sXG4gICAgICBzdGFibGVIZWlnaHQ6IGEsXG4gICAgICBpc0V4cGFuZGVkOiByXG4gICAgfSk7XG4gICAgcmV0dXJuIG4ocC5saXN0ZW4oKSksIHA7XG4gIH1cbik7XG5mdW5jdGlvbiBQKGUsIHQpIHtcbiAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KGUsIHQpO1xufVxuZnVuY3Rpb24gYm4oZSwgdCwgcykge1xuICBzIHx8IChzID0gKGEpID0+IGAtLXRnLSR7YX0tY29sb3JgKTtcbiAgY29uc3QgbiA9IHMoXCJoZWFkZXJcIiksIHIgPSBzKFwiYmdcIiksIGkgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBoZWFkZXJDb2xvcjogYSB9ID0gZTtcbiAgICBpZiAoY3QoYSkpXG4gICAgICBQKG4sIGEpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgeyBiZ0NvbG9yOiBwLCBzZWNvbmRhcnlCZ0NvbG9yOiB1IH0gPSB0O1xuICAgICAgYSA9PT0gXCJiZ19jb2xvclwiICYmIHAgPyBQKG4sIHApIDogYSA9PT0gXCJzZWNvbmRhcnlfYmdfY29sb3JcIiAmJiB1ICYmIFAobiwgdSk7XG4gICAgfVxuICAgIFAociwgZS5iZ0NvbG9yKTtcbiAgfSwgbyA9IFtcbiAgICB0Lm9uKFwiY2hhbmdlXCIsIGkpLFxuICAgIGUub24oXCJjaGFuZ2VcIiwgaSlcbiAgXTtcbiAgcmV0dXJuIGkoKSwgKCkgPT4gby5mb3JFYWNoKChhKSA9PiBhKCkpO1xufVxuZnVuY3Rpb24gdm4oZSwgdCkge1xuICB0IHx8ICh0ID0gKG4pID0+IGAtLXRnLXRoZW1lLSR7bi5yZXBsYWNlKC9bQS1aXS9nLCAocikgPT4gYC0ke3IudG9Mb3dlckNhc2UoKX1gKX1gKTtcbiAgY29uc3QgcyA9ICgpID0+IHtcbiAgICBPYmplY3QuZW50cmllcyhlLmdldFN0YXRlKCkpLmZvckVhY2goKFtuLCByXSkgPT4ge1xuICAgICAgciAmJiBQKHQobiksIHIpO1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4gcygpLCBlLm9uKFwiY2hhbmdlXCIsIHMpO1xufVxuZnVuY3Rpb24geW4oZSwgdCkge1xuICB0IHx8ICh0ID0gKHUpID0+IGAtLXRnLXZpZXdwb3J0LSR7dX1gKTtcbiAgY29uc3QgW1xuICAgIHMsXG4gICAgbixcbiAgICByXG4gIF0gPSBbXCJoZWlnaHRcIiwgXCJ3aWR0aFwiLCBcInN0YWJsZS1oZWlnaHRcIl0ubWFwKCh1KSA9PiB0KHUpKSwgaSA9ICgpID0+IFAocywgYCR7ZS5oZWlnaHR9cHhgKSwgbyA9ICgpID0+IFAobiwgYCR7ZS53aWR0aH1weGApLCBhID0gKCkgPT4gUChyLCBgJHtlLnN0YWJsZUhlaWdodH1weGApLCBwID0gW1xuICAgIGUub24oXCJjaGFuZ2U6aGVpZ2h0XCIsIGkpLFxuICAgIGUub24oXCJjaGFuZ2U6d2lkdGhcIiwgbyksXG4gICAgZS5vbihcImNoYW5nZTpzdGFibGVIZWlnaHRcIiwgYSlcbiAgXTtcbiAgcmV0dXJuIGkoKSwgbygpLCBhKCksICgpID0+IHAuZm9yRWFjaCgodSkgPT4gdSgpKTtcbn1cbmZ1bmN0aW9uIENzKGUgPSAhMCkge1xuICBjb25zdCB0ID0gW1xuICAgIHkoXCJyZWxvYWRfaWZyYW1lXCIsICgpID0+IHtcbiAgICAgIEIoXCJpZnJhbWVfd2lsbF9yZWxvYWRcIiksIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICB9KVxuICBdLCBzID0gKCkgPT4gdC5mb3JFYWNoKChuKSA9PiBuKCkpO1xuICBpZiAoZSkge1xuICAgIGNvbnN0IG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgbi5pZCA9IFwidGVsZWdyYW0tY3VzdG9tLXN0eWxlc1wiLCBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKG4pLCB0LnB1c2goXG4gICAgICB5KFwic2V0X2N1c3RvbV9zdHlsZVwiLCAocikgPT4ge1xuICAgICAgICBuLmlubmVySFRNTCA9IHI7XG4gICAgICB9KSxcbiAgICAgICgpID0+IGRvY3VtZW50LmhlYWQucmVtb3ZlQ2hpbGQobilcbiAgICApO1xuICB9XG4gIHJldHVybiBCKFwiaWZyYW1lX3JlYWR5XCIsIHsgcmVsb2FkX3N1cHBvcnRlZDogITAgfSksIHM7XG59XG5mdW5jdGlvbiBTcygpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPiBcInVcIjtcbn1cbmFzeW5jIGZ1bmN0aW9uIEVuKCkge1xuICBpZiAoT3Qod2luZG93KSlcbiAgICByZXR1cm4gITA7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGcoeyBtZXRob2Q6IFwid2ViX2FwcF9yZXF1ZXN0X3RoZW1lXCIsIGV2ZW50OiBcInRoZW1lX2NoYW5nZWRcIiwgdGltZW91dDogMTAwIH0pLCAhMDtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5mdW5jdGlvbiBQbihlKSB7XG4gIGNvbnN0IHQgPSB0eXBlb2YgZSA9PSBcInN0cmluZ1wiID8gZHQoZSkgOiBlO1xuICBGdCh0KTtcbiAgZnVuY3Rpb24gcyhyKSB7XG4gICAgaWYgKHR5cGVvZiByID09IFwic3RyaW5nXCIpXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGV2ZW50VHlwZTogaSB9ID0ga3Qocik7XG4gICAgICAgIGkgPT09IFwid2ViX2FwcF9yZXF1ZXN0X3RoZW1lXCIgJiYgZXQoXCJ0aGVtZV9jaGFuZ2VkXCIsIHtcbiAgICAgICAgICB0aGVtZV9wYXJhbXM6IEpTT04ucGFyc2UoSnQodC50aGVtZVBhcmFtcykpXG4gICAgICAgIH0pLCBpID09PSBcIndlYl9hcHBfcmVxdWVzdF92aWV3cG9ydFwiICYmIGV0KFwidmlld3BvcnRfY2hhbmdlZFwiLCB7XG4gICAgICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0LFxuICAgICAgICAgIGlzX3N0YXRlX3N0YWJsZTogITAsXG4gICAgICAgICAgaXNfZXhwYW5kZWQ6ICEwXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gIH1cbiAgaWYgKGh0KCkpIHtcbiAgICBjb25zdCByID0gd2luZG93LnBhcmVudC5wb3N0TWVzc2FnZS5iaW5kKHdpbmRvdy5wYXJlbnQpO1xuICAgIHdpbmRvdy5wYXJlbnQucG9zdE1lc3NhZ2UgPSAoaSkgPT4ge1xuICAgICAgcyhpKSwgcihpKTtcbiAgICB9O1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocXQod2luZG93KSkge1xuICAgIGNvbnN0IHIgPSB3aW5kb3cuZXh0ZXJuYWwubm90aWZ5LmJpbmQod2luZG93LmV4dGVybmFsKTtcbiAgICB3aW5kb3cuZXh0ZXJuYWwubm90aWZ5ID0gKGkpID0+IHtcbiAgICAgIHMoaSksIHIoaSk7XG4gICAgfTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbiA9IHdpbmRvdy5UZWxlZ3JhbVdlYnZpZXdQcm94eTtcbiAgd2luZG93LlRlbGVncmFtV2Vidmlld1Byb3h5ID0ge1xuICAgIC4uLm4gfHwge30sXG4gICAgcG9zdEV2ZW50KC4uLnIpIHtcbiAgICAgIHMoSlNPTi5zdHJpbmdpZnkoeyBldmVudFR5cGU6IHJbMF0sIGV2ZW50RGF0YTogclsxXSB9KSksIG4gJiYgbi5wb3N0RXZlbnQoLi4ucik7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gVHMoZSkge1xuICByZXR1cm4gZSBpbnN0YW5jZW9mIFc7XG59XG5mdW5jdGlvbiBSbihlLCB0KSB7XG4gIHJldHVybiBUcyhlKSAmJiBlLnR5cGUgPT09IHQ7XG59XG5mdW5jdGlvbiBKKGUsIHQpIHtcbiAgbGV0IHMsIG4sIHI7XG4gIHJldHVybiB0eXBlb2YgZSA9PSBcInN0cmluZ1wiID8gcyA9IGUgOiAocyA9IGUucGF0aG5hbWUgPT09IHZvaWQgMCA/IHQgOiBlLnBhdGhuYW1lLCBuID0gZS5wYXJhbXMsIHIgPSBlLmlkKSwgT2JqZWN0LmZyZWV6ZSh7XG4gICAgaWQ6IHIgfHwgKE1hdGgucmFuZG9tKCkgKiAyICoqIDE0IHwgMCkudG9TdHJpbmcoMTYpLFxuICAgIHBhdGhuYW1lOiBzLFxuICAgIHBhcmFtczogblxuICB9KTtcbn1cbmNsYXNzIEFzIHtcbiAgY29uc3RydWN0b3IodCwgcywgbiA9IEIpIHtcbiAgICBpZiAoYyh0aGlzLCBcImhpc3RvcnlcIiksIGModGhpcywgXCJlZVwiLCBuZXcgRCgpKSwgYyh0aGlzLCBcImF0dGFjaGVkXCIsICExKSwgYyh0aGlzLCBcImJhY2tcIiwgKCkgPT4gdGhpcy5nbygtMSkpLCBjKHRoaXMsIFwib25cIiwgdGhpcy5lZS5vbi5iaW5kKHRoaXMuZWUpKSwgYyh0aGlzLCBcIm9mZlwiLCB0aGlzLmVlLm9mZi5iaW5kKHRoaXMuZWUpKSwgdGhpcy5faW5kZXggPSBzLCB0aGlzLnBvc3RFdmVudCA9IG4sIHQubGVuZ3RoID09PSAwKVxuICAgICAgdGhyb3cgbSh2ZSwgXCJIaXN0b3J5IHNob3VsZCBub3QgYmUgZW1wdHkuXCIpO1xuICAgIGlmIChzIDwgMCB8fCBzID49IHQubGVuZ3RoKVxuICAgICAgdGhyb3cgbShcbiAgICAgICAgeWUsXG4gICAgICAgIFwiSW5kZXggc2hvdWxkIG5vdCBiZSB6ZXJvIGFuZCBoaWdoZXIgb3IgZXF1YWwgdGhhbiBoaXN0b3J5IHNpemUuXCJcbiAgICAgICk7XG4gICAgdGhpcy5oaXN0b3J5ID0gdC5tYXAoKHIpID0+IEoociwgXCJcIikpO1xuICB9XG4gIC8qKlxuICAgKiBBbGxvd3MgdGhpcyBuYXZpZ2F0b3IgdG8gY29udHJvbCB0aGUgYEJhY2tCdXR0b25gIHZpc2liaWxpdHkgc3RhdGUuIEl0IGFsc28gdHJhY2tzIHRoZVxuICAgKiBgQmFja0J1dHRvbmAgY2xpY2tzIGFuZCBjYWxscyB0aGUgYGJhY2tgIG1ldGhvZC5cbiAgICovXG4gIGF0dGFjaCgpIHtcbiAgICB0aGlzLmF0dGFjaGVkIHx8ICh0aGlzLmF0dGFjaGVkID0gITAsIHRoaXMuc3luYygpLCB5KFwiYmFja19idXR0b25fcHJlc3NlZFwiLCB0aGlzLmJhY2spKTtcbiAgfVxuICAvKipcbiAgICogQ3VycmVudGx5IGFjdGl2ZSBoaXN0b3J5IGl0ZW0uXG4gICAqL1xuICBnZXQgY3VycmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5oaXN0b3J5W3RoaXMuaW5kZXhdO1xuICB9XG4gIC8qKlxuICAgKiBQcmV2ZW50cyBjdXJyZW50IG5hdmlnYXRvciBmcm9tIGNvbnRyb2xsaW5nIHRoZSBCYWNrQnV0dG9uIHZpc2liaWxpdHkgc3RhdGUuXG4gICAqL1xuICBkZXRhY2goKSB7XG4gICAgdGhpcy5hdHRhY2hlZCA9ICExLCB6KFwiYmFja19idXR0b25fcHJlc3NlZFwiLCB0aGlzLmJhY2spO1xuICB9XG4gIC8qKlxuICAgKiBHb2VzIHRvIHRoZSBuZXh0IGhpc3RvcnkgaXRlbS5cbiAgICovXG4gIGZvcndhcmQoKSB7XG4gICAgdGhpcy5nbygxKTtcbiAgfVxuICAvKipcbiAgICogQ2hhbmdlcyBjdXJyZW50bHkgYWN0aXZlIGhpc3RvcnkgaXRlbSBpbmRleCBieSB0aGUgc3BlY2lmaWVkIGRlbHRhLiBUaGlzIG1ldGhvZCBkb2Vzbid0XG4gICAqIGNoYW5nZSBpbmRleCBpbiBjYXNlLCB0aGUgdXBkYXRlZCBpbmRleCBwb2ludHMgdG8gdGhlIG5vbi1leGlzdGluZyBoaXN0b3J5IGl0ZW0uIFRoaXMgYmVoYXZpb3JcbiAgICogaXMgcHJlc2VydmVkIHVudGlsIHRoZSBgZml0YCBhcmd1bWVudCBpcyBzcGVjaWZpZWQuXG4gICAqIEBwYXJhbSBkZWx0YSAtIGluZGV4IGRlbHRhLlxuICAgKiBAcGFyYW0gZml0IC0gY3V0cyB0aGUgZGVsdGEgYXJndW1lbnQgdG8gZml0IHRoZSBib3VuZHMgYFswLCBoaXN0b3J5Lmxlbmd0aCAtIDFdYC5cbiAgICovXG4gIGdvKHQsIHMpIHtcbiAgICBjb25zdCBuID0gdGhpcy5pbmRleCArIHQsIHIgPSBNYXRoLm1pbihcbiAgICAgIE1hdGgubWF4KDAsIG4pLFxuICAgICAgdGhpcy5oaXN0b3J5Lmxlbmd0aCAtIDFcbiAgICApO1xuICAgIChuID09PSByIHx8IHMpICYmIHRoaXMucmVwbGFjZUFuZE1vdmUociwgdGhpcy5oaXN0b3J5W3JdKTtcbiAgfVxuICAvKipcbiAgICogR29lcyB0byB0aGUgc3BlY2lmaWVkIGluZGV4LiBNZXRob2QgZG9lcyBub3RoaW5nIGluIGNhc2UsIHBhc3NlZCBpbmRleCBpcyBvdXQgb2YgYm91bmRzLlxuICAgKlxuICAgKiBJZiBcImZpdFwiIG9wdGlvbiB3YXMgc3BlY2lmaWVkIGFuZCBpbmRleCBpcyBvdXQgb2YgYm91bmRzLCBpdCB3aWxsIGJlIGN1dCB0byB0aGUgbmVhcmVzdFxuICAgKiBib3VuZC5cbiAgICogQHBhcmFtIGluZGV4IC0gdGFyZ2V0IGluZGV4LlxuICAgKiBAcGFyYW0gZml0IC0gY3V0cyB0aGUgaW5kZXggYXJndW1lbnQgdG8gZml0IHRoZSBib3VuZHMgYFswLCBoaXN0b3J5Lmxlbmd0aCAtIDFdYC5cbiAgICovXG4gIGdvVG8odCwgcykge1xuICAgIHRoaXMuZ28odCAtIHRoaXMuaW5kZXgsIHMpO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIG5hdmlnYXRvciBoYXMgaXRlbXMgYmVmb3JlIHRoZSBjdXJyZW50IGl0ZW0uXG4gICAqL1xuICBnZXQgaGFzUHJldigpIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleCA+IDA7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgbmF2aWdhdG9yIGhhcyBpdGVtcyBhZnRlciB0aGUgY3VycmVudCBpdGVtLlxuICAgKi9cbiAgZ2V0IGhhc05leHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXggIT09IHRoaXMuaGlzdG9yeS5sZW5ndGggLSAxO1xuICB9XG4gIC8qKlxuICAgKiBDdXJyZW50bHkgYWN0aXZlIGhpc3RvcnkgaXRlbSBpbmRleC5cbiAgICovXG4gIGdldCBpbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5kZXg7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBuZXcgaGlzdG9yeSBpdGVtIHJlbW92aW5nIGFsbCBhZnRlciB0aGUgY3VycmVudCBvbmUuXG4gICAqIEBwYXJhbSBpdGVtIC0gaXRlbSB0byBhZGQuXG4gICAqL1xuICBwdXNoKHQpIHtcbiAgICB0aGlzLmhhc05leHQgJiYgdGhpcy5oaXN0b3J5LnNwbGljZSh0aGlzLmluZGV4ICsgMSksIHRoaXMucmVwbGFjZUFuZE1vdmUodGhpcy5pbmRleCArIDEsIEoodCwgdGhpcy5jdXJyZW50LnBhdGhuYW1lKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSBjdXJyZW50IGhpc3RvcnkgaXRlbS5cbiAgICogQHBhcmFtIGl0ZW0gLSBpdGVtIHRvIHJlcGxhY2UgdGhlIGN1cnJlbnQgaXRlbSB3aXRoLlxuICAgKi9cbiAgcmVwbGFjZSh0KSB7XG4gICAgdGhpcy5yZXBsYWNlQW5kTW92ZSh0aGlzLmluZGV4LCBKKHQsIHRoaXMuY3VycmVudC5wYXRobmFtZSkpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGhpc3RvcnkgaXRlbSBieSB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgKiBAcGFyYW0gaW5kZXggLSBoaXN0b3J5IGl0ZW0gaW5kZXggdG8gcmVwbGFjZS5cbiAgICogQHBhcmFtIGhpc3RvcnlJdGVtIC0gaGlzdG9yeSBpdGVtIHRvIHNldC5cbiAgICovXG4gIHJlcGxhY2VBbmRNb3ZlKHQsIHMpIHtcbiAgICBjb25zdCBuID0gdCAtIHRoaXMuaW5kZXg7XG4gICAgaWYgKCFuICYmIHRoaXMuY3VycmVudCA9PT0gcylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByID0gdGhpcy5jdXJyZW50O1xuICAgIGlmICh0aGlzLmluZGV4ICE9PSB0KSB7XG4gICAgICBjb25zdCBpID0gdGhpcy5faW5kZXg7XG4gICAgICB0aGlzLl9pbmRleCA9IHQsIHRoaXMuYXR0YWNoZWQgJiYgaSA+IDAgIT0gdCA+IDAgJiYgdGhpcy5zeW5jKCk7XG4gICAgfVxuICAgIHRoaXMuaGlzdG9yeVt0XSA9IHMsIHRoaXMuZWUuZW1pdChcImNoYW5nZVwiLCB7XG4gICAgICBuYXZpZ2F0b3I6IHRoaXMsXG4gICAgICBmcm9tOiByLFxuICAgICAgdG86IHRoaXMuY3VycmVudCxcbiAgICAgIGRlbHRhOiBuXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFjdHVhbGl6ZXMgdGhlIGBCYWNrQnV0dG9uYCB2aXNpYmlsaXR5IHN0YXRlLlxuICAgKi9cbiAgc3luYygpIHtcbiAgICB0aGlzLnBvc3RFdmVudChcIndlYl9hcHBfc2V0dXBfYmFja19idXR0b25cIiwgeyBpc192aXNpYmxlOiAhIXRoaXMuaW5kZXggfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIEYoe1xuICBwYXJhbXM6IGUsXG4gIC4uLnRcbn0pIHtcbiAgcmV0dXJuIHsgLi4uZSB8fCB7IGhhc2g6IFwiXCIsIHNlYXJjaDogXCJcIiB9LCAuLi50IH07XG59XG5mdW5jdGlvbiBNKGUsIHQpIHtcbiAgcmV0dXJuIGUuc3RhcnRzV2l0aCh0KSA/IGUgOiBgJHt0fSR7ZX1gO1xufVxuZnVuY3Rpb24gVShlKSB7XG4gIHJldHVybiBuZXcgVVJMKFxuICAgIHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyBlIDogYCR7ZS5wYXRobmFtZSB8fCBcIlwifSR7TShlLnNlYXJjaCB8fCBcIlwiLCBcIj9cIil9JHtNKGUuaGFzaCB8fCBcIlwiLCBcIiNcIil9YCxcbiAgICBcImh0dHA6Ly9hXCJcbiAgKTtcbn1cbmZ1bmN0aW9uIEgoZSkge1xuICBjb25zdCB0ID0gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IGUuc3RhcnRzV2l0aChcIi9cIikgOiAhIShlLnBhdGhuYW1lICYmIGUucGF0aG5hbWUuc3RhcnRzV2l0aChcIi9cIikpLCBzID0gVShlKTtcbiAgcmV0dXJuIGAke3QgPyBzLnBhdGhuYW1lIDogcy5wYXRobmFtZS5zbGljZSgxKX0ke3Muc2VhcmNofSR7cy5oYXNofWA7XG59XG5mdW5jdGlvbiBRKGUsIHQsIHMpIHtcbiAgbGV0IG4sIHI7XG4gIHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyBuID0gZSA6IChuID0gSChlKSwgcyA9IGUuc3RhdGUsIHIgPSBlLmlkKTtcbiAgY29uc3QgeyBwYXRobmFtZTogaSwgc2VhcmNoOiBvLCBoYXNoOiBhIH0gPSBuZXcgVVJMKG4sIGBodHRwOi8vYSR7TSh0LCBcIi9cIil9YCk7XG4gIHJldHVybiB7IGlkOiByLCBwYXRobmFtZTogaSwgcGFyYW1zOiB7IGhhc2g6IGEsIHNlYXJjaDogbywgc3RhdGU6IHMgfSB9O1xufVxuYXN5bmMgZnVuY3Rpb24gTihlKSB7XG4gIHJldHVybiBlID09PSAwID8gITAgOiBQcm9taXNlLnJhY2UoW1xuICAgIG5ldyBQcm9taXNlKCh0KSA9PiB7XG4gICAgICBjb25zdCBzID0gdHQoXCJwb3BzdGF0ZVwiLCAoKSA9PiB7XG4gICAgICAgIHMoKSwgdCghMCk7XG4gICAgICB9KTtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LmdvKGUpO1xuICAgIH0pLFxuICAgIC8vIFVzdWFsbHksIGl0IHRha2VzIGFib3V0IDFtcyB0byBlbWl0IHRoaXMgZXZlbnQsIGJ1dCB3ZSB1c2Ugc29tZSBidWZmZXIuXG4gICAgbmV3IFByb21pc2UoKHQpID0+IHtcbiAgICAgIHNldFRpbWVvdXQodCwgNTAsICExKTtcbiAgICB9KVxuICBdKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIElzKCkge1xuICBpZiAod2luZG93Lmhpc3RvcnkubGVuZ3RoIDw9IDEgfHwgKHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShudWxsLCBcIlwiKSwgYXdhaXQgTigxIC0gd2luZG93Lmhpc3RvcnkubGVuZ3RoKSkpXG4gICAgcmV0dXJuO1xuICBsZXQgZSA9IGF3YWl0IE4oLTEpO1xuICBmb3IgKDsgZTsgKVxuICAgIGUgPSBhd2FpdCBOKC0xKTtcbn1cbmZ1bmN0aW9uIGVlKGUpIHtcbiAgcmV0dXJuIFUoZSkucGF0aG5hbWU7XG59XG5jb25zdCBQdCA9IDAsIFkgPSAxLCBaID0gMjtcbmNsYXNzIHNlIHtcbiAgY29uc3RydWN0b3IodCwgcywgeyBwb3N0RXZlbnQ6IG4sIGhhc2hNb2RlOiByID0gXCJjbGFzc2ljXCIsIGJhc2U6IGkgfSA9IHt9KSB7XG4gICAgYyh0aGlzLCBcIm5hdmlnYXRvclwiKSwgYyh0aGlzLCBcImVlXCIsIG5ldyBEKCkpLCBjKHRoaXMsIFwiaGFzaE1vZGVcIiksIGModGhpcywgXCJiYXNlXCIpLCBjKHRoaXMsIFwiYXR0YWNoZWRcIiwgITEpLCBjKHRoaXMsIFwib25Qb3BTdGF0ZVwiLCAoeyBzdGF0ZTogbyB9KSA9PiB7XG4gICAgICBpZiAobyA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaCh0aGlzLnBhcnNlUGF0aCh3aW5kb3cubG9jYXRpb24uaHJlZikpO1xuICAgICAgbyA9PT0gUHQgPyB3aW5kb3cuaGlzdG9yeS5mb3J3YXJkKCkgOiBvID09PSBZICYmIHRoaXMuYmFjaygpLCBvID09PSBaICYmIHRoaXMuZm9yd2FyZCgpO1xuICAgIH0pLCBjKHRoaXMsIFwib25OYXZpZ2F0b3JDaGFuZ2VcIiwgYXN5bmMgKHtcbiAgICAgIHRvOiBvLFxuICAgICAgZnJvbTogYSxcbiAgICAgIGRlbHRhOiBwXG4gICAgfSkgPT4ge1xuICAgICAgdGhpcy5hdHRhY2hlZCAmJiBhd2FpdCB0aGlzLnN5bmNIaXN0b3J5KCksIHRoaXMuZWUuZW1pdChcImNoYW5nZVwiLCB7XG4gICAgICAgIGRlbHRhOiBwLFxuICAgICAgICBmcm9tOiBGKGEpLFxuICAgICAgICB0bzogRihvKSxcbiAgICAgICAgbmF2aWdhdG9yOiB0aGlzXG4gICAgICB9KTtcbiAgICB9KSwgYyh0aGlzLCBcIm9uXCIsIHRoaXMuZWUub24uYmluZCh0aGlzLmVlKSksIGModGhpcywgXCJvZmZcIiwgdGhpcy5lZS5vZmYuYmluZCh0aGlzLmVlKSksIHRoaXMubmF2aWdhdG9yID0gbmV3IEFzKFxuICAgICAgdC5tYXAoKG8pID0+IFEobywgXCIvXCIpKSxcbiAgICAgIHMsXG4gICAgICBuXG4gICAgKSwgdGhpcy5uYXZpZ2F0b3Iub24oXCJjaGFuZ2VcIiwgKG8pID0+IHtcbiAgICAgIHRoaXMub25OYXZpZ2F0b3JDaGFuZ2Uobyk7XG4gICAgfSksIHRoaXMuaGFzaE1vZGUgPSByLCB0aGlzLmJhc2UgPSBlZShpIHx8IFwiXCIpO1xuICB9XG4gIC8qKlxuICAgKiBBdHRhY2hlcyBjdXJyZW50IG5hdmlnYXRvciB0byB0aGUgYnJvd3NlciBoaXN0b3J5IGFsbG93aW5nIG5hdmlnYXRvciB0byBtYW5pcHVsYXRlIGl0LlxuICAgKi9cbiAgYXN5bmMgYXR0YWNoKCkge1xuICAgIHRoaXMuYXR0YWNoZWQgfHwgKHRoaXMuYXR0YWNoZWQgPSAhMCwgdGhpcy5uYXZpZ2F0b3IuYXR0YWNoKCksIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgdGhpcy5vblBvcFN0YXRlKSwgYXdhaXQgdGhpcy5zeW5jSGlzdG9yeSgpKTtcbiAgfVxuICAvKipcbiAgICogR29lcyBiYWNrIGluIGhpc3RvcnkgYnkgMS5cbiAgICovXG4gIGJhY2soKSB7XG4gICAgdGhpcy5uYXZpZ2F0b3IuYmFjaygpO1xuICB9XG4gIC8qKlxuICAgKiBEZXRhY2hlcyBjdXJyZW50IG5hdmlnYXRvciBmcm9tIHRoZSBicm93c2VyIGhpc3RvcnkuXG4gICAqL1xuICBkZXRhY2goKSB7XG4gICAgdGhpcy5hdHRhY2hlZCA9ICExLCB0aGlzLm5hdmlnYXRvci5kZXRhY2goKSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCB0aGlzLm9uUG9wU3RhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBHb2VzIGZvcndhcmQgaW4gaGlzdG9yeS5cbiAgICovXG4gIGZvcndhcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMubmF2aWdhdG9yLmZvcndhcmQoKTtcbiAgfVxuICAvKipcbiAgICogQ3VycmVudCBoaXN0b3J5IGN1cnNvci5cbiAgICovXG4gIGdldCBpbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5uYXZpZ2F0b3IuaW5kZXg7XG4gIH1cbiAgLyoqXG4gICAqIEN1cnJlbnQgaGlzdG9yeSBpdGVtIGlkZW50aWZpZXIuXG4gICAqL1xuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMubmF2aWdhdG9yLmN1cnJlbnQuaWQ7XG4gIH1cbiAgLyoqXG4gICAqIENoYW5nZXMgY3VycmVudGx5IGFjdGl2ZSBoaXN0b3J5IGl0ZW0gaW5kZXggYnkgdGhlIHNwZWNpZmllZCBkZWx0YS4gVGhpcyBtZXRob2QgZG9lc24ndFxuICAgKiBjaGFuZ2UgaW5kZXggaW4gY2FzZSwgdGhlIHVwZGF0ZWQgaW5kZXggcG9pbnRzIHRvIHRoZSBub24tZXhpc3RpbmcgaGlzdG9yeSBpdGVtLiBUaGlzIGJlaGF2aW9yXG4gICAqIGlzIHByZXNlcnZlZCB1bnRpbCB0aGUgYGZpdGAgYXJndW1lbnQgaXMgc3BlY2lmaWVkLlxuICAgKiBAcGFyYW0gZGVsdGEgLSBpbmRleCBkZWx0YS5cbiAgICogQHBhcmFtIGZpdCAtIGN1dHMgdGhlIGRlbHRhIGFyZ3VtZW50IHRvIGZpdCB0aGUgYm91bmRzIGBbMCwgaGlzdG9yeS5sZW5ndGggLSAxXWAuXG4gICAqL1xuICBnbyh0LCBzKSB7XG4gICAgcmV0dXJuIHRoaXMubmF2aWdhdG9yLmdvKHQsIHMpO1xuICB9XG4gIC8qKlxuICAgKiBHb2VzIHRvIHRoZSBzcGVjaWZpZWQgaW5kZXguIE1ldGhvZCBkb2VzIG5vdGhpbmcgaW4gY2FzZSwgcGFzc2VkIGluZGV4IGlzIG91dCBvZiBib3VuZHMuXG4gICAqXG4gICAqIElmIFwiZml0XCIgb3B0aW9uIHdhcyBzcGVjaWZpZWQgYW5kIGluZGV4IGlzIG91dCBvZiBib3VuZHMsIGl0IHdpbGwgYmUgY3V0IHRvIHRoZSBuZWFyZXN0XG4gICAqIGJvdW5kLlxuICAgKiBAcGFyYW0gaW5kZXggLSB0YXJnZXQgaW5kZXguXG4gICAqIEBwYXJhbSBmaXQgLSBjdXRzIHRoZSBpbmRleCBhcmd1bWVudCB0byBmaXQgdGhlIGJvdW5kcyBgWzAsIGhpc3RvcnkubGVuZ3RoIC0gMV1gLlxuICAgKi9cbiAgZ29Ubyh0LCBzKSB7XG4gICAgdGhpcy5uYXZpZ2F0b3IuZ29Ubyh0LCBzKTtcbiAgfVxuICAvKipcbiAgICogQ3VycmVudCBoaXN0b3J5IGl0ZW0gaGFzaC5cbiAgICogQHNlZSBVUkwuaGFzaFxuICAgKiBAZXhhbXBsZVxuICAgKiBcIlwiLCBcIiNteS1oYXNoXCJcbiAgICovXG4gIGdldCBoYXNoKCkge1xuICAgIHJldHVybiAodGhpcy5uYXZpZ2F0b3IuY3VycmVudC5wYXJhbXMgfHwge30pLmhhc2ggfHwgXCJcIjtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiBuYXZpZ2F0b3IgaGFzIGl0ZW1zIGJlZm9yZSB0aGUgY3VycmVudCBpdGVtLlxuICAgKi9cbiAgZ2V0IGhhc1ByZXYoKSB7XG4gICAgcmV0dXJuIHRoaXMubmF2aWdhdG9yLmhhc1ByZXY7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgbmF2aWdhdG9yIGhhcyBpdGVtcyBhZnRlciB0aGUgY3VycmVudCBpdGVtLlxuICAgKi9cbiAgZ2V0IGhhc05leHQoKSB7XG4gICAgcmV0dXJuIHRoaXMubmF2aWdhdG9yLmhhc05leHQ7XG4gIH1cbiAgLyoqXG4gICAqIE5hdmlnYXRpb24gaGlzdG9yeS5cbiAgICovXG4gIGdldCBoaXN0b3J5KCkge1xuICAgIHJldHVybiB0aGlzLm5hdmlnYXRvci5oaXN0b3J5Lm1hcChGKTtcbiAgfVxuICAvKipcbiAgICogUGF0aCwgaW5jbHVkaW5nIHBhdGhuYW1lLCBzZWFyY2ggYW5kIGhhc2guXG4gICAqIEBleGFtcGxlIFBhdGhuYW1lIG9ubHkuXG4gICAqIFwiL3BhdGhuYW1lXCJcbiAgICogQGV4YW1wbGUgUGF0aG5hbWUgKyBzZWFyY2guXG4gICAqIFwiL3BhdGhuYW1lP3NlYXJjaFwiXG4gICAqIEBleGFtcGxlIFBhdGhuYW1lICsgaGFzaC5cbiAgICogXCIvcGF0aG5hbWUjaGFzaFwiXG4gICAqIEBleGFtcGxlIFBhdGhuYW1lICsgc2VhcmNoICsgaGFzaC5cbiAgICogXCIvcGF0aG5hbWU/c2VhcmNoI2hhc2hcIlxuICAgKi9cbiAgZ2V0IHBhdGgoKSB7XG4gICAgcmV0dXJuIEgodGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIEN1cnJlbnQgcGF0aG5hbWUuIEFsd2F5cyBzdGFydHMgd2l0aCB0aGUgc2xhc2guXG4gICAqIEBzZWUgVVJMLnBhdGhuYW1lXG4gICAqIEBleGFtcGxlXG4gICAqIFwiL1wiLCBcIi9hYmNcIlxuICAgKi9cbiAgZ2V0IHBhdGhuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hdmlnYXRvci5jdXJyZW50LnBhdGhuYW1lO1xuICB9XG4gIC8qKlxuICAgKiBEZXBlbmRpbmcgb24gdGhlIGN1cnJlbnQgbmF2aWdhdGlvbiB0eXBlLCBwYXJzZXMgaW5jb21pbmcgcGF0aCBhbmQgcmV0dXJucyBpdCBwcmVzZW50ZWQgYXNcbiAgICogYW4gb2JqZWN0LiBJbiBvdGhlciB3b3JkcywgdGhpcyBtZXRob2QgcGFyc2VzIHRoZSBwYXNzZWQgcGF0aCBhbmQgcmV0dXJucyBvYmplY3QsIGRlc2NyaWJpbmdcbiAgICogaG93IHRoZSBuYXZpZ2F0b3IgXCJzZWVzXCIgaXQuXG4gICAqXG4gICAqIEBleGFtcGxlIEhhc2ggbW9kZSBpcyBvbWl0dGVkLlxuICAgKiBwYXJzZVBhdGgoJy9hYmM/YT0xI2hhc2gnKTtcbiAgICogLy8geyBwYXRobmFtZTogJy9hYmMnLCBzZWFyY2g6ICc/YT0xJywgaGFzaDogJyNoYXNoJyB9XG4gICAqIHBhcnNlUGF0aCgnaHR0cDovL2V4YW1wbGUuY29tL2FiYz9hPTEjaGFzaCcpO1xuICAgKiAvLyB7IHBhdGhuYW1lOiAnL2FiYycsIHNlYXJjaDogJz9hPTEnLCBoYXNoOiAnI2hhc2gnIH1cbiAgICpcbiAgICogQGV4YW1wbGUgSGFzaCBtb2RlIGlzIGVuYWJsZWQuXG4gICAqIHBhcnNlUGF0aCgnL2FiYz9hPTEjdG1hP2lzPWNvb2wjeWVhaCcpO1xuICAgKiAvLyB7IHBhdGhuYW1lOiAnL3RtYScsIHNlYXJjaDogJz9pcz1jb29sJywgaGFzaDogJyN5ZWFoJyB9XG4gICAqIHBhcnNlUGF0aCgnaHR0cDovL2V4YW1wbGUuY29tL2FiYz9hPTEjdG1hP2lzPWNvb2wjeWVhaCcpO1xuICAgKiAvLyB7IHBhdGhuYW1lOiAnL3RtYScsIHNlYXJjaDogJz9pcz1jb29sJywgaGFzaDogJyN5ZWFoJyB9XG4gICAqL1xuICBwYXJzZVBhdGgodCkge1xuICAgIGxldCBzID0gVSh0KTtcbiAgICByZXR1cm4gdGhpcy5oYXNoTW9kZSAmJiAocyA9IFUocy5oYXNoLnNsaWNlKDEpKSksIHtcbiAgICAgIHBhdGhuYW1lOiBzLnBhdGhuYW1lLFxuICAgICAgc2VhcmNoOiBzLnNlYXJjaCxcbiAgICAgIGhhc2g6IHMuaGFzaFxuICAgIH07XG4gIH1cbiAgcHVzaCh0LCBzKSB7XG4gICAgY29uc3QgbiA9IFEodCwgdGhpcy5wYXRoKSwgeyBzdGF0ZTogciA9IHMgfSA9IG4ucGFyYW1zO1xuICAgIHRoaXMubmF2aWdhdG9yLnB1c2goeyAuLi5uLCBwYXJhbXM6IHsgLi4ubi5wYXJhbXMsIHN0YXRlOiByIH0gfSk7XG4gIH1cbiAgcmVwbGFjZSh0LCBzKSB7XG4gICAgY29uc3QgbiA9IFEodCwgdGhpcy5wYXRoKSwgeyBzdGF0ZTogciA9IHMgfSA9IG4ucGFyYW1zO1xuICAgIHRoaXMubmF2aWdhdG9yLnJlcGxhY2UoeyAuLi5uLCBwYXJhbXM6IHsgLi4ubi5wYXJhbXMsIHN0YXRlOiByIH0gfSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbWJpbmVzIHRoZSBuYXZpZ2F0b3IgYGJhc2VgIHByb3BlcnR5IHdpdGggdGhlIHBhc3NlZCBwYXRoIGRhdGEgYXBwbHlpbmcgdGhlIG5hdmlnYXRvclxuICAgKiBuYXZpZ2F0aW9uIG1vZGUuXG4gICAqIEBwYXJhbSB2YWx1ZSAtIHBhdGggcHJlc2VudGVkIGFzIHN0cmluZyBvciBVUkxMaWtlLlxuICAgKi9cbiAgcmVuZGVyUGF0aCh0KSB7XG4gICAgY29uc3QgcyA9ICh0aGlzLmJhc2UubGVuZ3RoID09PSAxID8gXCJcIiA6IHRoaXMuYmFzZSkgKyBNKEgodCksIFwiL1wiKTtcbiAgICByZXR1cm4gdGhpcy5oYXNoTW9kZSA/IE0ocy5zbGljZSgxKSwgdGhpcy5oYXNoTW9kZSA9PT0gXCJjbGFzc2ljXCIgPyBcIiNcIiA6IFwiIy9cIikgOiBzO1xuICB9XG4gIC8qKlxuICAgKiBTeW5jaHJvbml6ZXMgY3VycmVudCBuYXZpZ2F0b3Igc3RhdGUgd2l0aCBicm93c2VyIGhpc3RvcnkuXG4gICAqL1xuICBhc3luYyBzeW5jSGlzdG9yeSgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsIHRoaXMub25Qb3BTdGF0ZSk7XG4gICAgY29uc3QgeyBzdGF0ZTogdCB9ID0gdGhpcywgcyA9IHRoaXMucmVuZGVyUGF0aCh0aGlzKTtcbiAgICBhd2FpdCBJcygpLCB0aGlzLmhhc1ByZXYgJiYgdGhpcy5oYXNOZXh0ID8gKHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShZLCBcIlwiKSwgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHQsIFwiXCIsIHMpLCB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoWiwgXCJcIiksIGF3YWl0IE4oLTEpKSA6IHRoaXMuaGFzUHJldiA/ICh3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoWSwgXCJcIiksIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSh0LCBcIlwiLCBzKSkgOiB0aGlzLmhhc05leHQgPyAod2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHQsIHMpLCB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoWiwgXCJcIiksIGF3YWl0IE4oLTEpKSA6ICh3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoUHQsIFwiXCIpLCB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUodCwgXCJcIiwgcykpLCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsIHRoaXMub25Qb3BTdGF0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEN1cnJlbnQgcXVlcnkgcGFyYW1ldGVycy5cbiAgICogQHNlZSBVUkwuc2VhcmNoXG4gICAqIEBleGFtcGxlXG4gICAqIFwiXCIsIFwiP1wiLCBcIj9hPTFcIlxuICAgKi9cbiAgZ2V0IHNlYXJjaCgpIHtcbiAgICByZXR1cm4gKHRoaXMubmF2aWdhdG9yLmN1cnJlbnQucGFyYW1zIHx8IHt9KS5zZWFyY2ggfHwgXCJcIjtcbiAgfVxuICAvKipcbiAgICogQ3VycmVudCBoaXN0b3J5IGl0ZW0gc3RhdGUuXG4gICAqL1xuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuICh0aGlzLm5hdmlnYXRvci5jdXJyZW50LnBhcmFtcyB8fCB7fSkuc3RhdGU7XG4gIH1cbn1cbmZ1bmN0aW9uIGtzKGUpIHtcbiAgZSB8fCAoZSA9IHt9KTtcbiAgY29uc3QgeyBocmVmOiB0LCBoYXNoOiBzIH0gPSB3aW5kb3cubG9jYXRpb247XG4gIGxldCBuID0gSChcbiAgICBlLmhhc2hNb2RlID09PSBudWxsID8gdCA6IHMuaW5jbHVkZXMoXCI/XCIpID8gcy5zbGljZSgxKSA6IGA/JHtzLnNsaWNlKDEpfWBcbiAgKTtcbiAgY29uc3QgciA9IGUuYmFzZSA/IGVlKGUuYmFzZSkgOiB2b2lkIDA7XG4gIGlmIChyKSB7XG4gICAgaWYgKCFuLnN0YXJ0c1dpdGgocikpXG4gICAgICB0aHJvdyBtKFxuICAgICAgICBFZSxcbiAgICAgICAgYFBhdGggXCIke259XCIgZXhwZWN0ZWQgdG8gYmUgc3RhcnRpbmcgd2l0aCBcIiR7cn1cImBcbiAgICAgICk7XG4gICAgbiA9IG4uc2xpY2Uoci5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBuZXcgc2UoW25dLCAwLCBlKTtcbn1cbmZ1bmN0aW9uIHhuKGUpIHtcbiAgY29uc3QgdCA9IGUubWF0Y2goLyMoLispLyk7XG4gIHJldHVybiB0ID8gdFsxXSA6IG51bGw7XG59XG5mdW5jdGlvbiBxcyhlLCB0KSB7XG4gIGlmIChRdCgpKSB7XG4gICAgY29uc3QgcyA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oZSk7XG4gICAgaWYgKHMpXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGluZGV4OiBuLCBoaXN0b3J5OiByIH0gPSBKU09OLnBhcnNlKHMpO1xuICAgICAgICByZXR1cm4gbmV3IHNlKFxuICAgICAgICAgIHIsXG4gICAgICAgICAgbixcbiAgICAgICAgICB0XG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChuKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gcmVzdG9yZSBoYXNoIG5hdmlnYXRvciBzdGF0ZS5cIiwgbik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGtzKHQpO1xufVxuZnVuY3Rpb24gQ24oZSwgdCkge1xuICBjb25zdCBzID0gcXMoZSwgdCksIG4gPSAoKSA9PiBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKGUsIEpTT04uc3RyaW5naWZ5KHtcbiAgICBpbmRleDogcy5pbmRleCxcbiAgICBoaXN0b3J5OiBzLmhpc3RvcnlcbiAgfSkpO1xuICByZXR1cm4gcy5vbihcImNoYW5nZVwiLCBuKSwgbigpLCBzO1xufVxuZnVuY3Rpb24gZChlLCB0KSB7XG4gIGZ1bmN0aW9uIHMobikge1xuICAgIHJldHVybiBmdW5jdGlvbihpLCBvLCBhKSB7XG4gICAgICByZXR1cm4gKHApID0+IHtcbiAgICAgICAgY29uc3QgdSA9IHtcbiAgICAgICAgICAuLi5wLFxuICAgICAgICAgIFtpXTogbihvKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJ0KGEsIHsgLi4udSB9KTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuICByZXR1cm4gW3MoZSksIHModCldO1xufVxuY29uc3QgbmUgPSByZSh2b2lkIDApO1xuZnVuY3Rpb24gT3MoKSB7XG4gIGNvbnN0IGUgPSBpZShuZSk7XG4gIGlmICghZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1c2VTREsgd2FzIHVzZWQgb3V0c2lkZSB0aGUgU0RLUHJvdmlkZXIuXCIpO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIF8oZSkge1xuICBmdW5jdGlvbiB0KG4pIHtcbiAgICBjb25zdCByID0gT3MoKSwgW2ksIG9dID0gcnQoXG4gICAgICBuID8gdm9pZCAwIDogKCkgPT4ge1xuICAgICAgICBpZiAoU3MoKSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2luZyBob29rcyBvbiB0aGUgc2VydmVyIHNpZGUsIHlvdSBtdXN0IGV4cGxpY2l0bHkgc3BlY2lmeSBzc3IgPSB0cnVlIG9wdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIHIudXNlKGUpO1xuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIFIoKCkgPT4ge1xuICAgICAgbyhyLnVzZShlKSk7XG4gICAgfSwgW3JdKSwgaTtcbiAgfVxuICBmdW5jdGlvbiBzKG4pIHtcbiAgICBjb25zdCByID0gdChuKTtcbiAgICBpZiAocikge1xuICAgICAgaWYgKFwiZXJyb3JcIiBpbiByKVxuICAgICAgICB0aHJvdyByLmVycm9yO1xuICAgICAgcmV0dXJuIHIucmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gW3QsIHNdO1xufVxuY29uc3QgW05zLCBEc10gPSBfKEdlKSwgW1NuLCBUbl0gPSBkKFxuICBOcyxcbiAgRHNcbiksIFtCcywgTXNdID0gXyhLZSksIFtBbiwgSW5dID0gZChcbiAgQnMsXG4gIE1zXG4pLCBbVnMsIExzXSA9IF8oRmUpLCBba24sIHFuXSA9IGQoXG4gIFZzLFxuICBMc1xuKSwgWyRzLCBVc10gPSBfKHRzKSwgW09uLCBObl0gPSBkKFxuICAkcyxcbiAgVXNcbiksIFtIcywgV3NdID0gXyhzcyksIFtEbiwgQm5dID0gZChcbiAgSHMsXG4gIFdzXG4pLCBbR3MsIGpzXSA9IF8ocnMpLCBbTW4sIFZuXSA9IGQoR3MsIGpzKSwgW3pzLCBLc10gPSBfKG9zKSwgW0xuLCAkbl0gPSBkKHpzLCBLcyksIFtKcywgRnNdID0gXyhjcyksIFtVbiwgSG5dID0gZChKcywgRnMpLCBbUXMsIFlzXSA9IF8obHMpLCBbV24sIEduXSA9IGQoUXMsIFlzKSwgW1pzLCBYc10gPSBfKHdzKSwgW2puLCB6bl0gPSBkKFpzLCBYcyksIFt0biwgZW5dID0gXyhmcyksIFtLbiwgSm5dID0gZCh0biwgZW4pLCBbc24sIG5uXSA9IF8oYnMpLCBbRm4sIFFuXSA9IGQoXG4gIHNuLFxuICBublxuKSwgW3JuLCBvbl0gPSBfKHlzKSwgW1luLCBabl0gPSBkKHJuLCBvbik7XG5mdW5jdGlvbiBYbihlKSB7XG4gIGNvbnN0IFt0LCBzXSA9IHJ0KCgpID0+IGUgPyB2b2lkIDAgOiBudCgpKTtcbiAgcmV0dXJuIFIoKCkgPT4ge1xuICAgIGUgJiYgcyhudCgpKTtcbiAgfSwgW10pLCB0O1xufVxuY29uc3QgW2FuLCBjbl0gPSBfKFBzKSwgW3RyLCBlcl0gPSBkKGFuLCBjbiksIFtobiwgcG5dID0gXyh4cyksIFtzciwgbnJdID0gZChobiwgcG4pO1xuZnVuY3Rpb24gcnIoeyBjaGlsZHJlbjogZSwgYWNjZXB0Q3VzdG9tU3R5bGVzOiB0LCBkZWJ1ZzogcyB9KSB7XG4gIGNvbnN0IG4gPSBidCghMCksIFtyLCBpXSA9IHJ0KC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpLCBvID0gYnQociksIGEgPSBvZShcbiAgICAodSkgPT4ge1xuICAgICAgbi5jdXJyZW50ICYmIGkoKFMpID0+ICh1ICYmIHUoUyksIG5ldyBNYXAoUykpKTtcbiAgICB9LFxuICAgIFtdXG4gICksIHAgPSBhZSgoKSA9PiAoe1xuICAgIHVzZSh1LCAuLi5TKSB7XG4gICAgICBjb25zdCBndCA9IHIuZ2V0KHUpO1xuICAgICAgaWYgKGd0KVxuICAgICAgICByZXR1cm4gZ3Q7XG4gICAgICBsZXQgYiwgSztcbiAgICAgIHRyeSB7XG4gICAgICAgIGIgPSB1KC4uLlMpO1xuICAgICAgfSBjYXRjaCAoZikge1xuICAgICAgICBLID0gZjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uICQoZikge1xuICAgICAgICByZXR1cm4gci5zZXQodSwgZiksIGY7XG4gICAgICB9XG4gICAgICBpZiAoSylcbiAgICAgICAgcmV0dXJuICQoeyBlcnJvcjogSyB9KTtcbiAgICAgIGxldCBJO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYikgJiYgKEkgPSBiWzFdLCBiID0gYlswXSksICFiKVxuICAgICAgICByZXR1cm4gJCh7IHJlc3VsdDogYiwgY2xlYW51cDogSSB9KTtcbiAgICAgIGZ1bmN0aW9uIGZ0KGYpIHtcbiAgICAgICAgaWYgKFwib25cIiBpbiBmKSB7XG4gICAgICAgICAgY29uc3QgayA9IGYub24oXCJjaGFuZ2VcIiwgKCkgPT4gYSgpKSwgbXQgPSBJO1xuICAgICAgICAgIEkgPSAoKSA9PiB7XG4gICAgICAgICAgICBtdCAmJiBtdCgpLCBrKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByZXN1bHQ6IGYsIGNsZWFudXA6IEkgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiIGluc3RhbmNlb2YgUHJvbWlzZSA/IChiLnRoZW4oXG4gICAgICAgIChmKSA9PiBhKChrKSA9PiBrLnNldCh1LCBmdChmKSkpLFxuICAgICAgICAoZikgPT4gYSgoaykgPT4gay5zZXQodSwgeyBlcnJvcjogZiB9KSlcbiAgICAgICksICQoe30pKSA6ICQoZnQoYikpO1xuICAgIH1cbiAgfSksIFtyXSk7XG4gIHJldHVybiBSKCgpID0+IChuLmN1cnJlbnQgPSAhMCwgKCkgPT4ge1xuICAgIG4uY3VycmVudCA9ICExO1xuICB9KSwgW10pLCBSKCgpID0+IHtcbiAgICBpZiAoaHQoKSlcbiAgICAgIHJldHVybiBDcyh0KTtcbiAgfSwgW3RdKSwgUigoKSA9PiB7XG4gICAgbGUocyB8fCAhMSk7XG4gIH0sIFtzXSksIFIoKCkgPT4ge1xuICAgIG8uY3VycmVudCA9IHI7XG4gIH0sIFtyXSksIFIoKCkgPT4gKCkgPT4ge1xuICAgIG8uY3VycmVudC5mb3JFYWNoKCh1KSA9PiB7XG4gICAgICBcImNsZWFudXBcIiBpbiB1ICYmIHUuY2xlYW51cCAmJiB1LmNsZWFudXAoKTtcbiAgICB9KTtcbiAgfSwgW10pLCAvKiBAX19QVVJFX18gKi8gUnQobmUuUHJvdmlkZXIsIHsgdmFsdWU6IHAsIGNoaWxkcmVuOiBlIH0pO1xufVxuZXhwb3J0IHtcbiAgTmUgYXMgQmFja0J1dHRvbixcbiAgQXMgYXMgQmFzaWNOYXZpZ2F0b3IsXG4gIGplIGFzIEJpb21ldHJ5TWFuYWdlcixcbiAgc2UgYXMgQnJvd3Nlck5hdmlnYXRvcixcbiAgSmUgYXMgQ2xvc2luZ0JlaGF2aW9yLFxuICBYZSBhcyBDbG91ZFN0b3JhZ2UsXG4gIEVlIGFzIEVSUl9JTlZBTElEX1BBVEhfQkFTRSxcbiAgZmUgYXMgRVJSX0lOVk9LRV9DVVNUT01fTUVUSE9EX1JFU1BPTlNFLFxuICB3ZSBhcyBFUlJfTUVUSE9EX1BBUkFNRVRFUl9VTlNVUFBPUlRFRCxcbiAgX2UgYXMgRVJSX01FVEhPRF9VTlNVUFBPUlRFRCxcbiAgdmUgYXMgRVJSX05BVklHQVRJT05fSElTVE9SWV9FTVBUWSxcbiAgeWUgYXMgRVJSX05BVklHQVRJT05fSU5ERVhfSU5WQUxJRCxcbiAgZG4gYXMgRVJSX05BVklHQVRJT05fSVRFTV9JTlZBTElELFxuICBTdCBhcyBFUlJfUEFSU0UsXG4gIF9uIGFzIEVSUl9TU1JfSU5JVCxcbiAgbWUgYXMgRVJSX1RJTUVEX09VVCxcbiAgYmUgYXMgRVJSX1VORVhQRUNURURfVFlQRSxcbiAgZ2UgYXMgRVJSX1VOS05PV05fRU5WLFxuICBEIGFzIEV2ZW50RW1pdHRlcixcbiAgZXMgYXMgSGFwdGljRmVlZGJhY2ssXG4gIG5zIGFzIEluaXREYXRhLFxuICBpcyBhcyBJbnZvaWNlLFxuICBhcyBhcyBNYWluQnV0dG9uLFxuICB1cyBhcyBNaW5pQXBwLFxuICBfcyBhcyBQb3B1cCxcbiAgZ3MgYXMgUVJTY2FubmVyLFxuICBXIGFzIFNES0Vycm9yLFxuICByciBhcyBTREtQcm92aWRlcixcbiAgbXMgYXMgU2V0dGluZ3NCdXR0b24sXG4gIHZzIGFzIFRoZW1lUGFyYW1zLFxuICBFcyBhcyBVdGlscyxcbiAgUnMgYXMgVmlld3BvcnQsXG4gIFplIGFzIGFycmF5LFxuICBibiBhcyBiaW5kTWluaUFwcENTU1ZhcnMsXG4gIHZuIGFzIGJpbmRUaGVtZVBhcmFtc0NTU1ZhcnMsXG4gIHluIGFzIGJpbmRWaWV3cG9ydENTU1ZhcnMsXG4gIEUgYXMgYm9vbGVhbixcbiAgRHQgYXMgY2FwdHVyZVNhbWVSZXEsXG4gIHN0IGFzIGNsYXNzTmFtZXMsXG4gIEllIGFzIGNvbXBhcmVWZXJzaW9ucyxcbiAga3MgYXMgY3JlYXRlQnJvd3Nlck5hdmlnYXRvckZyb21Mb2NhdGlvbixcbiAgcWUgYXMgY3JlYXRlUG9zdEV2ZW50LFxuICBVIGFzIGNyZWF0ZVNhZmVVUkwsXG4gICR0IGFzIGRhdGUsXG4gIHhuIGFzIGdldEhhc2gsXG4gIGVlIGFzIGdldFBhdGhuYW1lLFxuICBHZSBhcyBpbml0QmFja0J1dHRvbixcbiAgS2UgYXMgaW5pdEJpb21ldHJ5TWFuYWdlcixcbiAgRmUgYXMgaW5pdENsb3NpbmdCZWhhdmlvcixcbiAgdHMgYXMgaW5pdENsb3VkU3RvcmFnZSxcbiAgc3MgYXMgaW5pdEhhcHRpY0ZlZWRiYWNrLFxuICBycyBhcyBpbml0SW5pdERhdGEsXG4gIG9zIGFzIGluaXRJbnZvaWNlLFxuICBjcyBhcyBpbml0TWFpbkJ1dHRvbixcbiAgbHMgYXMgaW5pdE1pbmlBcHAsXG4gIENuIGFzIGluaXROYXZpZ2F0b3IsXG4gIHdzIGFzIGluaXRQb3B1cCxcbiAgZnMgYXMgaW5pdFFSU2Nhbm5lcixcbiAgYnMgYXMgaW5pdFNldHRpbmdzQnV0dG9uLFxuICB5cyBhcyBpbml0VGhlbWVQYXJhbXMsXG4gIFBzIGFzIGluaXRVdGlscyxcbiAgeHMgYXMgaW5pdFZpZXdwb3J0LFxuICBDcyBhcyBpbml0V2ViLFxuICBPIGFzIGludm9rZUN1c3RvbU1ldGhvZCxcbiAgVnQgYXMgaXNDb2xvckRhcmssXG4gIGh0IGFzIGlzSWZyYW1lLFxuICBRdCBhcyBpc1BhZ2VSZWxvYWQsXG4gIGN0IGFzIGlzUkdCLFxuICBQZSBhcyBpc1JHQlNob3J0LFxuICBUcyBhcyBpc1NES0Vycm9yLFxuICBSbiBhcyBpc1NES0Vycm9yT2ZUeXBlLFxuICBTcyBhcyBpc1NTUixcbiAgRW4gYXMgaXNUTUEsXG4gIHcgYXMganNvbixcbiAgZ24gYXMgbWVyZ2VDbGFzc05hbWVzLFxuICBQbiBhcyBtb2NrVGVsZWdyYW1FbnYsXG4gIHggYXMgbnVtYmVyLFxuICB6IGFzIG9mZixcbiAgeSBhcyBvbixcbiAgZm4gYXMgcGFyc2VJbml0RGF0YSxcbiAgZHQgYXMgcGFyc2VMYXVuY2hQYXJhbXMsXG4gIFh0IGFzIHBhcnNlVGhlbWVQYXJhbXMsXG4gIEIgYXMgcG9zdEV2ZW50LFxuICBnIGFzIHJlcXVlc3QsXG4gIHplIGFzIHJlcXVlc3RCaW9tZXRyeUluZm8sXG4gIG1uIGFzIHJlcXVlc3RUaGVtZVBhcmFtcyxcbiAgdGUgYXMgcmVxdWVzdFZpZXdwb3J0LFxuICBudCBhcyByZXRyaWV2ZUxhdW5jaFBhcmFtcyxcbiAgSXQgYXMgcmdiLFxuICBsdCBhcyBzZWFyY2hQYXJhbXMsXG4gIFVlIGFzIHNlcmlhbGl6ZUxhdW5jaFBhcmFtcyxcbiAgSnQgYXMgc2VyaWFsaXplVGhlbWVQYXJhbXMsXG4gIFAgYXMgc2V0Q1NTVmFyLFxuICBsZSBhcyBzZXREZWJ1ZyxcbiAgd24gYXMgc2V0VGFyZ2V0T3JpZ2luLFxuICBoIGFzIHN0cmluZyxcbiAgcGUgYXMgc3Vic2NyaWJlLFxuICBDIGFzIHN1cHBvcnRzLFxuICBrZSBhcyB0YXJnZXRPcmlnaW4sXG4gIEF0IGFzIHRvUkdCLFxuICBDdCBhcyB1bnN1YnNjcmliZSxcbiAgSCBhcyB1cmxUb1BhdGgsXG4gIERzIGFzIHVzZUJhY2tCdXR0b24sXG4gIE5zIGFzIHVzZUJhY2tCdXR0b25SYXcsXG4gIE1zIGFzIHVzZUJpb21ldHJ5TWFuYWdlcixcbiAgQnMgYXMgdXNlQmlvbWV0cnlNYW5hZ2VyUmF3LFxuICBMcyBhcyB1c2VDbG9zaW5nQmVoYXZpb3IsXG4gIFZzIGFzIHVzZUNsb3NpbmdCZWhhdmlvclJhdyxcbiAgVXMgYXMgdXNlQ2xvdWRTdG9yYWdlLFxuICAkcyBhcyB1c2VDbG91ZFN0b3JhZ2VSYXcsXG4gIFdzIGFzIHVzZUhhcHRpY0ZlZWRiYWNrLFxuICBIcyBhcyB1c2VIYXB0aWNGZWVkYmFja1JhdyxcbiAganMgYXMgdXNlSW5pdERhdGEsXG4gIEdzIGFzIHVzZUluaXREYXRhUmF3LFxuICBLcyBhcyB1c2VJbnZvaWNlLFxuICB6cyBhcyB1c2VJbnZvaWNlUmF3LFxuICBYbiBhcyB1c2VMYXVuY2hQYXJhbXMsXG4gIEZzIGFzIHVzZU1haW5CdXR0b24sXG4gIEpzIGFzIHVzZU1haW5CdXR0b25SYXcsXG4gIFlzIGFzIHVzZU1pbmlBcHAsXG4gIFFzIGFzIHVzZU1pbmlBcHBSYXcsXG4gIFhzIGFzIHVzZVBvcHVwLFxuICBacyBhcyB1c2VQb3B1cFJhdyxcbiAgZW4gYXMgdXNlUVJTY2FubmVyLFxuICB0biBhcyB1c2VRUlNjYW5uZXJSYXcsXG4gIE9zIGFzIHVzZVNESyxcbiAgbm4gYXMgdXNlU2V0dGluZ3NCdXR0b24sXG4gIHNuIGFzIHVzZVNldHRpbmdzQnV0dG9uUmF3LFxuICBvbiBhcyB1c2VUaGVtZVBhcmFtcyxcbiAgcm4gYXMgdXNlVGhlbWVQYXJhbXNSYXcsXG4gIGNuIGFzIHVzZVV0aWxzLFxuICBhbiBhcyB1c2VVdGlsc1JhdyxcbiAgcG4gYXMgdXNlVmlld3BvcnQsXG4gIGhuIGFzIHVzZVZpZXdwb3J0UmF3LFxuICBUbiBhcyB3aXRoQmFja0J1dHRvbixcbiAgU24gYXMgd2l0aEJhY2tCdXR0b25SYXcsXG4gIEluIGFzIHdpdGhCaW9tZXRyeU1hbmFnZXIsXG4gIEFuIGFzIHdpdGhCaW9tZXRyeU1hbmFnZXJSYXcsXG4gIHFuIGFzIHdpdGhDbG9zaW5nQmVoYXZpb3IsXG4gIGtuIGFzIHdpdGhDbG9zaW5nQmVoYXZpb3JSYXcsXG4gIE5uIGFzIHdpdGhDbG91ZFN0b3JhZ2UsXG4gIE9uIGFzIHdpdGhDbG91ZFN0b3JhZ2VSYXcsXG4gIEJuIGFzIHdpdGhIYXB0aWNGZWVkYmFjayxcbiAgRG4gYXMgd2l0aEhhcHRpY0ZlZWRiYWNrUmF3LFxuICBWbiBhcyB3aXRoSW5pdERhdGEsXG4gIE1uIGFzIHdpdGhJbml0RGF0YVJhdyxcbiAgJG4gYXMgd2l0aEludm9pY2UsXG4gIExuIGFzIHdpdGhJbnZvaWNlUmF3LFxuICBIbiBhcyB3aXRoTWFpbkJ1dHRvbixcbiAgVW4gYXMgd2l0aE1haW5CdXR0b25SYXcsXG4gIEduIGFzIHdpdGhNaW5pQXBwLFxuICBXbiBhcyB3aXRoTWluaUFwcFJhdyxcbiAgem4gYXMgd2l0aFBvcHVwLFxuICBqbiBhcyB3aXRoUG9wdXBSYXcsXG4gIEpuIGFzIHdpdGhRUlNjYW5uZXIsXG4gIEtuIGFzIHdpdGhRUlNjYW5uZXJSYXcsXG4gIFFuIGFzIHdpdGhTZXR0aW5nc0J1dHRvbixcbiAgRm4gYXMgd2l0aFNldHRpbmdzQnV0dG9uUmF3LFxuICBabiBhcyB3aXRoVGhlbWVQYXJhbXMsXG4gIFluIGFzIHdpdGhUaGVtZVBhcmFtc1JhdyxcbiAgTXQgYXMgd2l0aFRpbWVvdXQsXG4gIGVyIGFzIHdpdGhVdGlscyxcbiAgdHIgYXMgd2l0aFV0aWxzUmF3LFxuICBuciBhcyB3aXRoVmlld3BvcnQsXG4gIHNyIGFzIHdpdGhWaWV3cG9ydFJhd1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tma.js/sdk-react/dist/index.js\n");

/***/ })

};
;